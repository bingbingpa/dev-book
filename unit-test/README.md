#  단위 테스트(생산성과 품질을 위한 단위 테스트 원칙과 패턴)
- *블라디미르 코리코프 저/임준혁 역 에이콘출판사*

<br>

### 1장 단위 테스트의 목표

- 지속적인 정리와 리팩터링 등과 같은 적절한 관리가 없으면 시스템은 점점 더 복잡해지고 흐트러진다.
    - 테스트로 이러한 경향을 뒤집을 수 있다.
    - 테스트는 안전망 역할을 하며, 대부분의 회귀에 대한 보험을 제공하는 도구라 할 수 있다.

### 2장 단위 테스트란 무엇인가

- 단위 테스트의 정의
    - 단일 동작 단위를 검증하고
    - 빠르게 수행하고
    - 다른 테스트와 별도로 처리한다.
- 격리 문제에 대한 논쟁으로 고전파(디트로이트)와 런던파(목 추종자)라는 두 개의 단위 테스트 분파로 나뉘었다. 이러한 의견 차이는 무엇이 단위를 의미하는지에 대한 관점과 대상 시스템(System Under Test, SUT)의 의존성 처리 방식에 영향을 미친다.
    - 런던파는 테스트 대상 단위를 서로 분리해야 한다고 한다. 테스트 대상 단위는 코드의 단위, 불변 의존성을 제외한 모든 의존성을 테스트 대역으로 대체해야 한다.
    - 고전파는 단위가 아니라 단위 테스트를 서로 분리해야 한다고 한다. 또한 테스트 대상 단위는 코드 단위가 아니라 동작 단위다. 따라서 공유 의존성만 테스트 대역으로 대체해야 한다.
        - 공유 의존성은 테스트가 서로 실행 흐름에 영향을 미치는 수단을 제공하는 의존성이다.
- `테스트는 코드 단위가 아니라 동작 단위를 검증해야 한다.`

### 3장 단위 테스트 구조

- 모든 단위 테스트는 AAA 패턴(준비, 실행, 검증)을 따라야 한다.
    - `테스트 내 준비나 실행 또는 검증 구절이 여러 개 있으면, 테스트가 여러 동작 단위를 한번에 검증한다는 표시다.`
        - 이 테스트가 단위 테스트라면 각 동작에 하나씩 여러 개의 테스트로 나눠야 한다.
- 실행 구절이 한 줄 이상이면 SUT 의 API 에 문제가 있다는 뜻이다.
    - 클라이언트가 항상 이러한 작업을 같이 수행해야 하고, 이로 인해 잠재적으로 모순으로 이어질 수 있다.

### 4장 좋은 단위 테스트의 4대 요소

- 좋은 단위 테스트의 네 가지 기본 특성
    - 회귀 방지
    - 리팩터링 내성
    - 빠른 피드백
    - 유지 보수성
- `테스트는 SUT 가 수행한 단계가 아니라 SUT 가 만든 최종 결과를 검증해야 한다.`

### 5장 목과 테스트 취약성

- 테스트 대역은 테스트에서 비제품 가짜 의존성의 모든 유형을 설명하는 포괄적인 용어다.
    - 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 등의 다섯 가지 변형이 있는데, 이는 다시 목과 스텁이라는 두 가지 유형으로 분류할 수 있다.
    - 스파이는 기능적으로 목과 같고, 더미와 페이크는 스텁과 같은 역할을 한다.
- 목은 외부로 나가는 상호 작용(SUT에서 의존성으로의 호출로, 해당 의존성의 상태를 변경)을 모방하고 검사하는 데 도움이 된다.
- 스텁은 내부로 들어오는 상호 작용(SUT가 해당 의존성을 호출해 입력 데이터를 가져옴)을 모방하는 데 도움이 된다.
- `스텁과 상호 작용을 검증하면 취약한 테스트로 이어진다.`
- 명령을 대체하는 테스트 대역은 목이고, 조회를 대체하는 테스트 대역은 스텁이다.
- 캡슐화는 코드를 불변성 위반으로부터 보호하는 행위다.
- 육각형 아키텍처는 다음과 같은 세 가지 관점을 강조한다.
    - `도메인 애플리케이션 서비스 계층 간의 영향 분리, 도메인 계층은 비즈니스 로직을 책임져야 하고, 애플리케이션 서비스는 도메인 계층과 외부 애플리케이션 간의 작업을 조정해야 한다.`
    - 애플리케이션 서비스 계층에서 도메인 계층으로의 단방향 의존성 흐름.
        - 도메인 계층 내 클래스는 서로에게만 의존해야 하고, 애플리케이션 서비스 계층의 클래스에 의존해서는 안 된다.
    - 외부 애플리케이션은 애플리케이션 서비스 계층이 유지하는 공통 인터페이스를 통해 연결 된다.
        - 아무도 도메인 계층에 직접 액세스 할 수 없다.
- 애플리케이션에는 시스템 내부 통신과 시스템 간 통신이라는 두 가지 통신 유형이 있다.
    - 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다.
    - 시스템 간 통신은 애플리케이션이 외부 애플리케이션과 통신할 때를 말한다.
- 시스템 내 통신을 검증하고자 목을 사용하면 취약한 테스트로 이어진다.
    - 시스템 간 통신과 해당 통신의 부작용이 외부 환경에서 보일 때만 목을 사용하는 것이 타당하다.

### 6장 단위 테스트 스타일

- 출력 기반 테스트는 SUT 에 입력을 주고 출력을 확인하는 테스트 스타일이다.
- 상태 기반 테스트는 작업이 완료된 후의 시스템 상태를 확인한다.
- 통신 기반 테스트는 목을 사용해서 테스트 대상 시스템과 협력자 간의 통신을 검증한다.
- `출력 기반 테스트가 테스트 품질이 가장 좋다. 이러한 테스트는 구현 세부 사항에 거의 결합되지 않으므로 리팩터링 내성이 있다. 또한 작고 간결하므로 유지 보수하기도 쉽다.`

### 7장 가치 있는 단위 테스트를 위한 리팩터링

- `협력자가 많은 코드를 다루는 단위 테스트는 유지비가 많이 든다. 이러한 테스트는 협력자를 예상 상태로 만들고나서 상태나 상호 작용을 확인하고자 공간을 많이 필요로 한다.`
    - 코드가 중요하거나 복잡할수록 협력자가 적어야 한다.

### 8장 통합 테스트를 하는 이유

- 통합 테스트는 시스템이 프로세스 외부 의존성과 통합해 작동하는 방식을 검증한다.
    - 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 알고리즘과 도메인 모델을 다룬다.
- `단위 테스트를 통해 가능한 한 많은 비즈니스 시나리오의 예외 상황을 확인하라. 통합 테스트를 사용해서 하나의 주요 흐름과 단위 테스트로 확인할 수 없는 예외 상황을 다루도록 하라.`
- 관리 의존성은 애플리케이션을 통해서만 접근할 수 있는 프로세스 외부 의존성이다. 관리 의존성과의 상호 작용은 외부에서 관찰할 수 없다.  ex) 애플리케이션 데이터 베이스
- 비관리 의존성은 다른 애플리케이션이 접근할 수 있는 프로세스 외부 의존성이다. 비관리 의존성과 상호 작용은 외부에서 관찰할 수 있다.  ex) SMTP
- 통합 테스트에서 관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라.
- 구현이 하나뿐인 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다.
    - 이러한 인터페이스에 대한 향후 구현을 예상하면 YAGNI 원칙을 위배한다.
        - You aren't gonna need it (YAGNI): 당장 필요하지 않은 것은 미리 구현하지 말자!
- 순환 의존성이 있으면 코드를 이해하려고 할 때 알아야 하는 부담이 커진다.
- `항상 모든 의존성을 생성자 또는 메서드 인수를 통해 명시적으로 주입하라.`

### 9장 목 처리에 대한 모범 사례

- 시스템 끝에서 비관리 의존성과의 상호 작용을 검증하라. 컨트롤러와 비관리 의존성 사이의 타입 사슬에서 마지막 고리를 목으로 처리하라.
- 스파이는 직접 작성한 목이다. 시스템 끝에 있는 클래스에 대해서는 스파이가 목보다 낫다. 검증 단계에서 코드를 재사용해 테스트 크기가 줄고 가독성이 개선된다.
- 목은 비관리 의존성만을 위한 것이고 이러한 의존성을 처리하는 코드는 컨트롤러뿐이므로 통합 테스트에서 컨트롤러를 테스트할 때만 목을 적용해야 한다. `단위 테스트에서는 목을 사용하지 말라.`

### 10장 데이터베이스 테스트

- 데이터베이스 스키마를 소스 코드와 같이 형상 관리 시스템에 저장하라.
- 개발자마다 데이터베이스 인스턴스를 별도로 두게 하라.
- `테스트 구절마다 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라. 준비, 실행, 검증 구절에 각각 고유의 트랜잭션이나 작업 단위가 있어야 한다.`
- 테스트 시작 시점에 남은 데이터를 정리하라. 이방식은 빠르고 일관성 없는 동작을 일으키지 않으며, 정리 단계를 실수로 건너뛰지 않는다. 이렇게 하면 별도의 종료 단계도 둘 필요가 없다.
- 읽기 테스트는 가장 복잡하거나 중요한 읽기 작업만 테스트 하고, 나머지는 무시하라.
- `리포지터리는 직접 테스트하지 말고 포괄적인 통합 테스트 스위트로 취급하라.` 리포지터리 테스트는 회귀 방지에 대한 이득이 너무 적은 데 반해 유지비가 높다.

### 11장 단위 테스트 안티 패턴

- `단위 테스트를 가능하게 하고자 비공개 메서드를 노출하게 되면 테스트가 구현에 결합되고, 결국 리팩터링 내성이 떨어진다. 비공개 메서드를 직접 테스트하는 대신, 식별할 수 있는 동작으로서 간접적으로 테스트하라.`
- `비공개 메서드가 너무 복잡해서 공개 API 로 테스트 할 수 없다면, 추상화가 누락됐다는 뜻이다. 비공개 메서드를 공개로 하지 말고 해당 추상화를 별도 클래스로 추출하라.`
- 테스트를 작성할 때 특정 구현을 암시하지 말라. 블랙박스 관점에서 제품 코드를 검증하라. 또한 도메인 지식을 테스트에 유출하지 않도록 하라.
- 기능을 지키려고 구체 클래스를 목으로 처리해야 한다면, 이는 단일 책임 원칙을 위반하는 결과다. 해당 클래스를 두 가지 클래스, 즉 도메인 로직이 있는 클래스와 프로세스 외부 의존성과 통신하는 클래스로 분리하라.