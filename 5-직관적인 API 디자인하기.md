### 5. 직관적인 API 디자인하기
- 컨셉에 맞는 직관적인 표현 만들기
- 관련된 에러의 성공 피드백 식별하기
- 효율적인 사용 흐름(Flow) 디자인하기
    #### 5.1 직관적인 표현
    - 이름, 데이터 포맷 데이터와 관련된 의사결정은 API 의 사용성을 크게 향상시킬 수도 반대로 크게 손상시킬 수 있다. 
    - 명확한 이름 정하기
        - **이름을 정할 때는(그 목적이 무엇이건) 세 단어에서 두 단어의 조합까지만 하기를 권한다.**
        - 사용하기 쉬운 데이터 타입과 포맷 정하기
            - API 를 디자인할 때 적절한 데이터 포맷을 선택하는 것은 API 를 명시적으로 표현하기 위해 적절한 이름을 선택하는 것만큼 중요하다.
            - 데이터 타입과 포맷을 정할 때는 반드시 인간 중심적인 사고를 바탕으로 정해야 하며, 항상 정확한 표현을 제공해야 한다.
            - 복잡한 포맷을 사용하는 경우 정보를 확실하고 충분하게 제공하려 노력해야 한다.
            - 컨텍스트에 대한 이해 없이도 이해 할 수 있도록 노력해야 한다.
            - 사용하기 어려운 데이터
            ~~~ json
            {
              "number": 1234567,
              "balanceDate": 1534960860,
              "creationDate": 1423267200,
              "type": 1
            }
            ~~~
            - 사용하기 쉬운 데이터
            ~~~ json
            {
              "number": "00012345678",
              "balanceDate": "2020-08-22T18:01:00z",
              "creationDate": "2021-02-07",
              "type": "checking"
            }
            ~~~
        - 바로 사용할 수 있는 데이터 선택하기
            - 명확하지 않은 데이터 대신 의미있는 데이터를 사용한다.
            - 바로 쓰기 어려운 데이터
            ~~~ json
            GET /accounts/4566222-abdfh3-fkblj2f-ddskdfjd
            {
                "type": 2,
                "balance": 500,
                "overdraftLimit": 100,
                "creationDate": "2015-02-07"
            }
            ~~~
            - 사용 가능한 데이터
                - 식별하기 어려운 uuid 보다는 식별할 수 잇는 고유값을 사용한다.
            ~~~ json
            GET /accounts/0001234567 
            {
                "type": 2,
                "typeName": "checking", //데이터를 추가하여 type 이란 의미를 알수 없는 데이터를 설명
                "balance": 500,
                ""currency": "USD", //컨슈머가 추가적인 작업을 할 필요가 없도록 부가적인 데이터도 제공
                "overdraftLimit": 100,
                "safeToSpend":600,
                "creationDate": "2015-02-07"
            }
            ~~~
    #### 5.2 직관적인 상호작용  
    - 이름은 명확할수록 좋으며, 모호한 약어는 피해야 한다. 
    - 데이터 타입과 포맷은 이해하기 쉬워야 한다.
    - 데이터는 제공하는 사용자가 입력하기 쉬워야 한다.
    - 발생 가능한 모든 에러 피드백 식별하기
        - 규격에 맞지 않는 에러: 잘못된 값이 들어와서 발생하는 에러 
        - 기능적 에러: 비즈니스 로직에 부합하지 않는(예를 들면 송금 금액보다 계좌 잔액이 적은 경우) 경우 발생하는 에러
        - 서버 에러: 데이터 베이스 장애 또는 서버 로직 처리 상의 에러 등 
        - 에러를 나열할 때는 항상 컨슈머의 관점으로 바라봐야 한다.
        - 규격에 맞지 않는 리퀘스트 에러와 기능적 에러에 대한 HTTP 상태 코드
          |유즈 케이스|사용 예|HTTP 상태코드|
          |:--------|:--------|:--------|
          |잘못된 파라미터|GET /accounts/123 리퀘스트에 존재하지 않는 계좌에 대해서 조회|404 Not Found|
          |필수 속성의 누락|amount 가 누락됨|400 Bad Request|
          |잘못된 데이터 타입|"startDate":1423332060|400 Bad Request|
          |기능적 에러|금액이 소비 한도를 초과|403 Forbidden|
          |기능적 에러|보내는 계좌에서 받는 계좌로의 이체가 금지됨|403 Forbidden|
          |기능적 에러|지난 5분이내에 동일한 송금이 발생한 전력이 있음|409 Conflict|
          |예상치 못한 서버 에러|구현에 버그가 숨겨져 있음.|500 Internal Server Error|
        - **에러 리스폰스는 포괄적인 타입(generic type) 형태로 자세하게 보여주자.**
        ~~~ json
        {
            "source": "amount",
            "type": "MISSING_MANDATORY_PROPERTY",
            "message": "금액은 필수입니다."
        }
        ~~~
        - 여러개의 에러 반환하기 
        ~~~ json
        {
            "message": "Invalid request",
            "errors": [
                {
                    "source": "source",
                    "type": "MISSING_MANDATORY_PROPERTY",
                    "message": "Source is mandatory"
                },
                {
                    "source": "destination",
                    "type": "MISSING_MANDATORY_PROPERTY",
                    "message": "Destination is mandatory"
                },
            ] 
        }
        ~~~
    #### 5.3 직관적인 흐름
    - 에러 방지
        - 가능한 오류를 분석하여 이를 예방할 수 있는 추가 값 데이터를 결정한다.
        - 기존 목표의 성공 피드백을 향상시켜 이러한 데이터를 제공한다.
        - 이러한 데이터를 제공하기 위한 새로운 목표를 수립한다.