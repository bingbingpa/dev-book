# 엘레강트 오브젝트(새로운 관점에서 바라본 객체지향)

- *Yegor Bugayenko 저/조영호 역 | 지앤선(志&嬋)*

### 1장 출생

#### 1.1 -er 로 끝나는 이름을 사용하지 마세요

- 클래스는 객체의 팩토리이다.
- 클래스를 객체의 능동적인 관리자(active manager)로 생각해야 한다.
- 클래스는 객체를 꺼내거나 반환할 수 있는 위치이기 때문에, 클래스를 저장소(storage unit) 또는 웨어하우스라고 불러야 한다.
- **클래스의 이름은 무엇을 하늕(what he does)가 아니라 무엇인지(what he is)에 기반해야 한다.**
- 객체는 그의 역량(capability)으로 특징지어져야 한다.
- 객체는 캡슐화된 데이터의 대표자(representative)이다.
- **클래스의 객체들이 무엇을 캡슐화할 것인지를 관찰하고 이 요소들에 붙일 적합한 이름을 찾아야 한다.**

#### 1.2 생성자 하나를 주 생성자로 만드세요

- 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 생성자가 존재한다.
- **생성자가 많아질수록 클라이언트가 클래스를 더 유연하게 만들수 있게 된다. 하지만 메서드가 많아질수록 클래스를 사용하기는 더 어려워진다. 메서드가 많아지면 클래스의 초점이 흐려지고, 단일 책임 원칙(Single
  Responsibility Principle)을 위반한다.**
- 유지보수성을 위해 주 생성자를 모든 부 생성자 뒤에 위치시키자.

#### 1.3 생성자에 코드를 넣지 마세요

- **객체 초기화에는 코드가 없어야하고 인자를 건드려서는 안된다. 대신, 필요하면 인자들을 다른 타입의 객체로 감싸거나 가공하지 않은 형식(raw form)으로 캡슐화해야 한다.**
- 진정한 객체지향에서 인스턴스화(instantiation)란 더 작은 객체들을 **조합해서(compose)** 더큰 객체를 만드는 것을 의미한다. 객체들을 조합해야 하는 단 하나의 이유는 새로운 계약을 준수하는
  새로운 엔티티(entity)가 필요하기 때문이다.
- 생성자는 어떤 일을 수행하는 곳이 아니기 때문에 생성자안에서 인자에게 어떤 작업을 요청하도록 요청해서는 안된다. 다시 말해서 생성자는 코드가 없어야 하고, 오직 할당문만 포함해야 한다.
    - 생성자에 코드가 없을 경우 성능 최적화가 더 쉽기 때문에 코드의 실행 속도가 더 빨라진다.
- 생성자에서 코드를 없애면 사용자가 쉽게 제어할 수 있는 투명한 객체를 만들 수 있으며, 객체를 이해하고 재사용하기 쉬워진다. 객체는 요청을 받을 때만 행동하고 그 전에는 어떤 일도 하지 않는다.

### 2장 학습

#### 2.1 가능하면 적게 캡슐화하세요

- 4개 또는 그 이하의 객체를 캡슐화할 것을 권장한다.

#### 2.2 최소한 뭔가는 캡슐화하세요

- 실행으로부터 인스턴스 생성을 고립시켜야 한다. 다시 말해서 오직 생성자에서만 new 연산자를 허용해야 한다.

#### 2.3 항상 인터페이스를 사용하세요

- 애플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 **분리해야(decouple)** 한다. 기술적인 관점에서 객체 분리란 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수
  있도록 만든다는 것을 믜이한다. 이를 가능하게 하는 가장 훌륭한 도구가 바로 **인터페이스(interface)** 이다.
- 인터페이스는 객체가 다른 객체와 의사소통하기 위해 따라야 하는 계약(contract)이다.

#### 2.4 메서드 이름을 신중하게 선택하세요

- **빌더(builder)의 이름은 명사로, 조정자(manipulator)의 이름은 동사로 짖도록 하자.**
- 빌더란 뭔가를 만들고 새로운 객체를 반환하는 메서드를 가리킨다. 빌더의 반환타입은 절대 void 가 될 수 없으며, 이름은 항상 명사여야 한다.
- 객체로 추상화한 실세계 엔티티를 수정하는 메서드를 조정자라고 부르며, 조정자의 반환 타입은 항상 void 이고, 이름은 항상 동사이다.
- 부적절하게 지은 메서드 이름은 객체의 전체적인 개념을 망가트리고 사용자들이 객체를 데이터 집합이나 프로시저들의 모음으로 다루도록 조용한다.
- 객체는 자신의 의무를 수행하는 방법을 알고 존중 받기를 원하는 **살아있는 유기체**이다.
- 메서드의 이름을 동사로 지을 때에는 객체에게 **무엇을 할지(what to do)** 를 알려주어야 한다.
- 빌더 패턴을 사용할 경우에는 with 로 시작하는 메서드 이름을 사용해도 무방하다.
    - 어떠한 크래스의 모든 메서드 안에서 특정 접두사를 반복하지 않기 위해 간단히 with 접두사를 사용할 수 있다.
- **빌더 패턴은 생성자에 너무 많은 인자를 전달하고 싶지 않을 때 유용하게 사용한다. 하지만 애초에 인자의 수가 많다는 것 자체가 문제이다. 빌더 패턴을 사용하는 대신 복잡한 객체를 더 작은 객체들로 나눠야
  한다.**
- Boolean 값을 반환하는 메서드 규칙에 있어서 예외적인 경우라고 책에서는 말한다. 값을 반환하기 때문에 이 메서드들은 빌더에 속하지만, 가독성 측면에서 이름은 혀용사로 지어야 한다.
    ~~~ java
    boolean empty();
    boolean readable();
    boolean negative();
    ~~~

#### 2.5 퍼블릭 상수(Public Constant)를 사용하지 마세요

- **객체들은 어떤 것도 공유해서는 안된다. 대신 독립적이어야 하고 닫혀 있어야(closed)한다.**
- 퍼블릭 상수를 사용할 때 발생하는 문제점
    - 결합도(coupling)가 높아진다.
    - 응집도(cohesion)가 낮이잔다.
        - 낮은 응집도는 객체가 자신의 문제를 해결하는데 덜 집중한다는 것을 의미한다.
        - 작업을다른 객체에게 위임한다면 각 객체의 응집도를 향상시킬 수 있다.
- 아무리 사소해 보이는 상수라도 항상 작은 클래스를 이용해서 대체하자.

#### 2.6 불변 객체로 만드세요

- 모든 클래스를 상태 변경이 불가능한 불변 클래스(immutable class)로 구현하면 유지보수성을 크게 향상시킬 수 있다.
- 실패 원자성(Failure Atomicity)
    ~~~ java
    class Cash {
        private int dollars;
        private int cents;
        private void mul(int facotr) {
            this.dollars *= factor;
            if(/* 뭔가 잘못 됐다면 */) {
                throw new RuntimeException("oops...");
            }
            this.cents *= factor;
        }
    }
    ~~~
    - mul() 메서드를 실행하는 도중에 예외가 던져진다면 객체의 절반(this.dollars)만 수정되고 나머지 절반(this.cents)은 원래 값을 유지한다. 이로 인해매우 심각하고 발견하기 어려운 버그가
      발생할 수도 있다.
- 가변 객체를 사오ㅛㅇ하더라도 실패 원자성이라는 목표를 달성할 수 있지만, 이를 위해서는 특별한 주의를 기울여야 한다. 반면에 불변 객체를 사용하면 별도의 처리 없이도 원자성을 얻을 수 있다.
- 가변 객체인 경우에는 코드를 수정하기 전에 우선 코드 줄 사이의 시간적인 결합을 이해해야 한다.
    ~~~ java
    Cash price = new Cash();
    price.setDollars(29);
    System.out.println(price); // "$29.00"!
    price.setCents(95);
    ~~~
- 불변성을 활용하면 코드 전반적으로 구문 사이에 존재하는 시간적인 결합을 제거할 수 있다.
- **객체가 더 단순해질 수록 응집도는 더 높아지고, 유지보수하기는 더 쉬워진다.**
- 최고의 소프트웨어는 이해하고, 수정하고, 문서화하고, 지원하고, 리팩토링하기 쉽다.
- **불변성은 클래스르 더 깔끔하고 더 짧게 만든다. 이것이 바로 불변 클래스를 이용할 때 얻을 수 있는 가장 중요한 장점이다.**

#### 2.7 문서를 작성하는 대신 테스트를 만드세요

- **더 읽기 쉬운 코드를 만들기 위해서는, 코드를 읽게 될 사람이 비즈니스 도메인, 프로그래밍 언어, 디자인 패턴, 알고리즘을 거의 이해하지 못하는 주니어 프로그래머라고 가정해야 한다.**
- 코드를 문서화하는 대신 코드를 깔끔(clean)하게 만들자. 깔끔하게 만든다라는 말에는 다누이 테스트도 함께 만든다는 의미가 포함되어 있다.

#### 2.8 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요

- **모킹은 나쁜 프랙티스이며, 최후의 수단으로만 사용해야 한다. 모킹 대신 페이크 객체(fake object)를 사용하자.**
- **페이크 클래스를 만족하도록 테스트를 작성하지 말고, 페이크 클래스가 테스트를 올바르게 지원하도록 만들자.**
- 페이크 클래스를 사용하면 테스트를 더 짧게 만들 수 있기 때문에 유지보수성이 눈에 띄게 향상된다. 반면에 모킹의 경우, 테스트가 장황해지고, 이해하거나 리팩토링하기 어려워진다.
- **모킹은 가정(assumption)을 사실(facts)로 전환시키기 때문에 단위 테스트를 유지보수하기 어렵게 만든다.**
- **클래스의 공개된(public) 행동을 변경하지 않을 경우 단위 테스튼 실패해서는 안된다.**
- **모킹은 클래스 구현과 관련된 내부의 세부사항을 테스트와 결합시킨다. 우리는 가정하고, 이 가정을 모의 객체 안에 하드코딩한 채, 작업을 끝내 버린다. 시간이 흐르고 리팩토링을 할 시간이 됐을 때 테스트가 더
  이상 유효하지 않는 내부 구현에 결합되어 있기 때문에 할 수 있는 일이라고는 테스트를 폐기처분하는 것밖에 없다.**

#### 2.9 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요

- 인터페이스 내부에 스마트 클래스를 구현한다. 이 스마트 클래스는 아주 명확하고 공통적인 작업을 수행하는 많은 메서드들을 포함할 수 있다.
- 인터페이스를 짧게 만들고 스마트 클래스를 인터페이스와 함꼐 배포함으로써 공통 기능을 추출하고코드 중복을 피할 수 있다.
    ~~~ java
    interface Exchange {
        float rate(String source, String target);
        final class Smart {
            private final Exchange origin;
            public float toUsd(String source) {
                return this.origin.rate(source, "USD");
            }
            public float eurToUsd() {
                return this.toUsd("EUR");
            }
        }
    }
    ~~~

### 3장 취업

- **객체지향에서는 데이터를 대체하는 객체가 가장 중요한 지위를 차지한다. 명령, 문장, 연산자는 더 이상 데이터를 책임지지 않는다.**

#### 3.1 5개 이하의 public 메서드만 노출하세요

- 책의 저자가 적절하다고 생각하는 public 메서드의 수는 생성자와 private 메서드를 제외하고 5개...
- **4번째 메서드를 추가하고 나서 5번째 메서드를 추가하기 전에 잠시 숨을 고르고 클래스의 크기에 관해 고민해보자!!!**
- 클래스가 작으면 메서드와 프로퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.
- 클래스에 두 개의 프로퍼티가 있을 때 한 프로퍼티는 두 개의 메서드에서만 사용되고 나머지 프로퍼티는 다른 세 개의 메서드에서만 사용된다면, 거의 연관성이 없는 독립적인 두 부분이 하나의 클래스 안에 뭉쳐있는
  상황이라고 할 수 있다. 이런 클래스는 응집도가 낮다. 클래스가 작을때 클래스의 모든 메서드가 모든 프로퍼티와 사옿작용할 가능성이 더 높아진다.
- **작은 클래스는 테스트하기도 쉽고, 모든 사용 시나리오를 쉽게 재현할 수 있으며, 클래스가 작기 때문에 사용 시나리오의 수도 많지 않다.**

#### 3.2 정적 메서드를 사용하지 마세요

- 정적 메서드는 소프트웨어를 유지보수하기 어렵게 만든다.
- 정적 메서드는 OOP 와 아무런 상관이 없으며, 객체지향 언어의 문법을 이용해서 절차적인 코드를 작성하도록 부추길 뿐이다.
- 명령행 프로그래밍(imperative programming)
    - 프로그램의 상태를 변경하는 문장(statement)를 사용해서 계산 방식을 서술한다.
    - 컴퓨터처럼 연산을 차례대로 실행한다.
- 선언형 프로그래밍(declarative programing)
    - 제어 흐름을 서술하지 않고 계산 로직을 표현 한다.
    - 엔티티와 엔티티 사이의 관계로 구성되는 자연스러운 사고 패러다임에 더 가깝다.
    - 객체 사이의 결합도를 낮출 수 있다.
- 오직 하나의 정적 메서드만 호출하는 경우라면, 당연히 정적 메서드를 호출하는 방식이 객체를 생성한 무 메서드를 호출하는 방식보다 빠르지만, 다수의 정적 메서드를 호출해야 하는 경우에는 다를 수 있다.
- **객체를 다른 객체로부터 완전이 분리하기 위해서는 메서드나 주생성자 어디에서도 new 연산자를 사용하지 말아야 한다.**
- **정적 메서드 대신 다른 코드가 객체를 직접 처리할 수 있도록 정적 메서드를 감싸는 클래스를 만들어 고립시키도록 하자!**
- 싱글톤과 유틸리티 클래스(static class)와의 차이점
    - 싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다.
    - 싱글톤은 getInstance() 와 함께 setInstance() 를 추가 할 수 있다.
    - 캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 유틸리티 클래스보다는 더 좋다. 유틸리티 클래스 안에는 객체가 존재하지 않기 때문에 어떤 것도 변경할 수 없다.
- **올바르게 설계된 객체지향 소프트웨어라면 코드 대부분이 if, for, switch, while 과 같은 절차적인 문장이 포함되어 있어서는 안된다.**
- **작으면서도 조합 가능한 클래스들을 설계하고, 더 큰 객체를 조합하기 위해 작은 클래스들을 재사용할 수 있도록 만들어야 한다.**
- 결론적으로 소프트웨어 어디에서도 static 키워드를 사용하지 않도록 하자?!!!

### 3.3 인자의 값으로 NULL 을 절대 허용하지 마세요

- 객체를 존중한다면 다음과 같이 행동하자. mask == null 과 같이 객체를 피하고 무시하지 말자.
    - 인자의 값으로 NULL 을 허용하면 mask == null 과 같은 비교문을 사용할 수 밖에 없다. 객체와 협력할 때마다 객체의 '실체' 를 확인하는 것말고는 NULL 인지 여부를 판단할 수 있는 방법이
      없다. 그리고 **NULL 여부를 체크함으로써 객체가 맡아야 하는 상당량의 책임을 빼앗게 된다.**
    ~~~ java
    public Iterable<File> find(Mask mask) {
        if(mask.empty()) {
            // 모든 파일을 찾는다.
        } else {
            // 마스크를 사용해서 파일을 찾는다.
        }
    }
    ~~~
- **객체지향에서 '존재하지 않는 인자(absent argument)' 문제는 '널 객체(null object)' 를 이용해서 해결해야 한다. 전달할 것이 없다면, 비어있는 것처럼 행동하는 객체를 전달하면 된다.
  전달한 인자가 객체인지 NULL 인지를 확인하는 짐을 메소드 구현자에게 떠넘겨서는 안된다. 대신 항상 객체를 전달하되, 전달한 객체에게 무리한 요청을 한다면 응답을 거부하도록 객체를 구현해야 한다.**
    ~~~ java
    interface Mask {
        boolean matches(File file);
    }
    
    class AnyFile implements Mask {
        @Ovveride
        boolean matches(File file) {
            return true;
        }
    }
    ~~~
- **중요하지 않는 NULL 확인 로직으로 코드를 오염시켜서는 안된다.** NUllPointerException 은 잘못된 위치에 NULL 이 전달됐다는 사실을 알려주는 올바른 지표이다. 더 똑똑하거나 더 유용한
  정보를 제공하도록 만들 필요가 없다. 올바른 방식으로 설계된 소프트웨어에는 NULL 참조가 존재해서는 안된다. 방어적으로 대응하지 말고 무시함으로써 JVM 에 정의된 표준방식으로 처리해야 한다.

#### 3.4 충성스러우면서 불변이거나, 아니면 상수이거나

- 가변 객체와 불변 객체를 구분할때 객체의 행동이나 메서드의 반환값은 중요하지 않다. 핵심은 객체가 살아있는 동안 상태가 변하지 않는다는 사실이다.

#### 3.5 절대 getter 와 setter 를 사용하지 마세요

- **모든 프로그래밍 스타일의 핵심 목표는 가시성의 범위를 축소해서 사물을 단순화시키는 것이다. 특정한 시점에 이해해야 하는 범위가 작을수록, 소프트웨어 유지보수성이 향상되고 이해하고 수정하기도 쉬어진다.**
- 정확하게 무엇을 캡슐화하고 있고, 자료구조가 얼마나 복잡한 지는 오직 객체만이 알고 있어야한다. 데이터를 **발가벗겨진** 상태로 두어서는 안된다.
- 객체는 대화를 원하지 않는다. 그저 우리가 어떤 데이터를 객체 안에 넣어주거나 다시 꺼내주기를 원할뿐이다.
- 알맞은 접두사를 사용하자!
    - dollars() 는 데이터를 노출하지 않지만, getDollars() 는 데이터를 노출한다. getDollars() 메서드를 통해 데이터가 표면에 완전히 드러나 있으며, 클래스의 모든 사용자는 이
      데이터를 볼 수 있다.
    ~~~ java
    class Cash {
        private final int value;
        public int dollars() {
            return this.value;
        }
    }
    // 부적절한 메서드 이름
    class Cash {
        private final int value;
        public int getDollars() {
            return this.value;
        }
    }
    ~~~

#### 3.6 부 생성자 밖에서는 new 를 사용하지 마세요

- 부 생성자를 제외한 어떤 곳에서도 new 를 사용하지 말자. 부 생성자를 제외한 어떤 곳에서도 new 를 사용할 수 없도록 금지시킨다면, 객체들은 상호간에 충분히 분리되고 테스트 용이성과 유지보수성을 크게 향상
  시킬 수 있다.
- **메서드나 주 생성자 안에서 new 를 사용하는 매순간마다 뭔가 잘못하고 있다는 사실을 떠올리자. new 를 합법적으로 사용할 수 있는 유일한 곳은 부 생성자 뿐이다.**

#### 3.7 인트로스펙션과 캐스팅을 피하세요

- 타입 인트로스펙션(introspection) 과 캐스팅(casting)을 사용하고 싶은 유혹에 빠지더라도 절대 사용하면 안된다. 기술적으로 Java 의 instanceof 연산자와 Class.cast() 메서드
  모두 이 범주에 포함된다.
- 이 접근방법들은 타입에 따라 객체를 **차별하기 때문에** OOP 의 기본 사상을 심각하게 훼손시킨다.
- 런타임에 객체의 타입을 조사(introspect)하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서도 좋지 않다. 의존하는 대상이 늘어날수록 결합도는 높아지기 때문에 유지보수성의 측면에서 좋지
  않다.

### 4장 은퇴

#### 4.1 절대 NULL 을 반환하지 마세요

- **NULL 을 반환해서 NullPinterException 이 발생하는 것인 단지 기술적인 불편함일 뿐이다. 더 큰 문제는 객체에 대한 신뢰가 무너졌다는 것이다. 반환된 값이 객체인지부터 확인해야 하기 때문에,
  객체에게 작업을 요청한 후 안심하고 결과에 의지할 수 없다.**
- **반환값을 검사하는 방식은 애플리케이션에 대한 신뢰가 부족하다는 명백한 신호다.**
- NULL 을 사용하면 전체 소프트웨어에 대한 신뢰가 크게 손상되고, 소프트웨어가 유지보수 불가능할 정도로 엉망이 되고 말 것이다.
- **NULL 을 대체하는 방법들**
    - 메서드를 두개로 나눈다. 첫 번째 메서드는 객체의 존재를 확인하고, 두 번째 메서드는 개체를 반환한다.
    - NULL 을 반환하거나 예외를 던지는 대신 객체 컬렉션을 반환한다.
    - *java.util.Optional 이나 유사한 도구를 사용*
        - java.util.Optional 은 컬렉션과 동일하지만, 오직 하나의 요소만 포함할 수 있다. 이 방법은 의미론적으로 부정확하기 때문에 OOP 와 대립한다고 생각하며 사용을 권하지 않는다.
    - 널 객체(null object) 디자인 패턴
        - 원하는 객체를 발견하지 못할 경우, 겉으로 보기에는 원래의 객체처럼 보이지만 실제로는 다르게 행동하는 객체를 반환한다.

#### 4.2 체크 예외(checked exception)만 던지세요

- 다양한 예외 타입을 만드는 것은 좋지 않은 생각이다.
- 모든 catch 문에는 납득할 수 있는 이유가 있어야 한다. 다시 말해서, 반드시 예외를 잡아야 하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안된다.
- catch 문에서 새로운 메시지를 가지는 새로운 타입의 문제를 발생시키는건 근본 원인에 대한 매우 가치있는 정보가 손실되기 때문에 매우 나쁜 프랙티스이다. **절대로 원래 예외를 무시하지 말자.**

#### 4.3 final 이나 abstract 이거나

- final 클래스는 사용자 관점에서 블랙박스(black box)이다. final 클래스는 상속을 통해 수정할 수 없다. 불투명하고 독립적이며 자신이 어떻게 행동해야 하는지 알고 있고, 어떤 도움도 필요로 하지 않다. 기술적으로
  final 클래스 안의 어떤 메서드도 오버라이딩 할수 없다. 메서드는 영원히 final 이다.
- abstract 클래스는 글래스 박스(glass box)이고 불완전하다. 스스로 행동할 수 없기 때문에 누군가의 도움이 필요하며 일부 요소가 누락되어 있다. 기술적인 관점에서 abstract 클래스는 아직 
클래스가 아니다. 제대로 된 클래스를 생성하기 위해 사용할 수 있는 원재료라고 할 수 있다.
  
#### 4.4 RAII(Resource Acquisition Is Initialization)를 사용하세요

- AutoCloseable 을 사용하자. 