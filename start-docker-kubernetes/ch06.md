# 6장 쿠버네티스 시작하기

# 6.1 쿠버네티스를 시작하기 전에

- 모든 리소스는 오브젝트 형태로 관리된다.
    - `kubectl api-resources` 명령어로 쿠버네티스에서 사용할 수 있는 오브젝트들을 확인할 수 있다.
    - `kubectl expliain "오브젝트명"` 명령어로 오브젝트의 간단한 설명을 볼 수 있다.
- 쿠버네티스는 명령어로도 사용할 수 있지만, YAML 파일을 더 많이 사용한다.
- 쿠버네티스는 여러 개의 컴포넌트로 구성돼 있다.
    - 쿠버네티스 클러스터 구성을 위해 `kubelet` 이라는 에이전트가 모든 노드에서 실행된다.
    - kubelet 은 컨테이너의 생성, 삭제뿐만 아니라 마스터와 워커 노드 간의 통신 역할을 함께 담당하는 매우 중요한 에이전트이다.

## 6.2 포드(Pod): 컨테이너를 다루는 기본 단위

## 6.2.1 포드 사용하기

- 컨테이너 애플리케이션의 기본 단위를 포드(Pod)라고 부르며, 포드는 1개 이상의 컨테이너로 구성된 컨테이너의 집합이다.
- 쿠버네티스의 YAML 파일은 일반적으로 apiVersion, kind, metadata, spec 네 가지 항목으로 구성된다.
    - `apiVersion`: YAML 파일에서 정의한 오브젝트 API 버전을 나타낸다.
    - `kind`: 이 리소스의 종류를 나타낸다.
    - `metadata`: 라벨, 주석(Annotation), 이름 등과 같은 리소스의 부가 정보들을 입력한다.
    - `spec`: 리소스를 생성하기 위한 자세한 정보를 입력한다.
- 포드 생성: `kubectl apply -f "YAML 파일명"`
- 특정 오브젝트의 목록 확인: `kubectl get "오브젝트 이름"`
- 생성된 리소스의 자세한 정보: `kubectl describe`

## 6.2.3 완전판 애플리케이션으로서의 포드

- **하나의 포드는 하나의 완전한 애플리케이션이다.**
- 포드에 정의된 부가적인 컨테이너를 사이드카(sidecar) 컨테이너라고 부르며, 사이드카 컨테이너는 포드 내의 다른 컨테이너와 네트워크 환경 등을 공유하게 된다.

# 6.3. 레플리카셋(Replica Set): 일정 개수의 포드를 유지하는 컨트롤러

## 6.3.1 레플리카셋을 사용하는 이유

- 쿠버네티스의 기본 단위인 포드는 여러 개의 컨테이너를 추상화해 하나의 애플리케이션으로 동작 하도록 만드는 컨테이너 묶음이다.
- YAML 파일은 `---` 를 구분자로 사용해 여러 개의 리소스를 정의할 수 있다.
- 레플리카셋이 수행하는 역할
    - 정해진 수의 동일한 포드가 항상 실행되도록 관리한다.
    - 노드 장애 등의 이유로 포드를 사용할 수 없다면 다른 노드에서 포드를 다시 생성한다.

## 6.3.2 레플리카셋 사용하기

- `spec.replicas`: 동일한 포드를 몇 개 유지시킬 것인지 설정
- `spect.template` : 포드를 생성할 때 사용할 템플릿을 정의
- `kubectl apply -f "YAML 파일명"` : 레플리카셋 생성
- `kubectl get po` : 레플리카셋과 포드의 목록 확인
- kubectl 명령어의 shortName 은 kubectl api-resources 에서 `SHORTNAMES` 항목에서 확인 가능
- 레플리카셋 삭제
    - `kubectl delete -f “YAML 파일명”`
    - `kubectl delete rs "레플리카셋 명"`

## 6.3.3 레플리카셋 동작 원리

- 레플리카셋은 포드와 연결돼 있지 않다.
- 느슨한 연결(loosely coupled)을 유지하고 있으며, 이러한 느슨한 연결은 포드와 레플리카셋의 정의 중 `라벨 셀렉터(Label Selector)` 를 이용해 이뤄진다.
- 레플리카셋은 `spec.selector.matchLabel` 에 정의된 라벨을 통해 생성해야 하는 포드를 찾는다.
    - app: my-nginx-pods-label 라벨을 가지는 포드의 개수가 replicas 항목에 정의된 숫자아 일치하지 않으면 포드를 정의하는 포드 템플릿 항목의 내용으로 포드를 생성한다.
- **레플리카셋의 목적은 ‘포드를 생성하는 것’이 아닌, ‘일정 개수의 포드를 유지하는 것’이다.**

# 6.4 디플로이먼트(Deployment): 레플리카셋, 포드의 배포를 관리

## 6.4.1 디플로이먼트 사용하기

- 디플로이먼트는 레플리카셋의 상위 오브젝트이기 때문에 디플로이먼트를 생성하면 해당 디플로이먼트에 대응하는 레플리카셋도 함께 생성된다.
    - 디플로이먼트를 사용하면 포드와 레플리카셋을 직접 생성할 필요가 없다.
- `kubectl get deploy`: 디플로이먼트 목록 조회

## 6.4.2 디플로이먼트를 사용하는 이유

- **디플로이먼트를 사용하는 핵심적인 이유 중 하나는 애플리케이션의 업데이트와 배포를 더욱 편하게 만들기 위해서이다.**
- 디플로이먼트는 컨테이너 애플리케이션을 배포하고 관리하는 역할을 담당한다.
- 리비전 정보 확인

    ```bash
    kubectl rollout history deployment "디플로이명"
    ```

- `--rocord=true` 옵션으로 디플로이먼트를 변경하면 변경 사항을 디플로이먼트에 기록함으로써 해당 버전의 레플리카셋을 보존한다.

    ```bash
    kubectl set image deployment my-nginx-deployment nginx=nginx:1.11 --record
    ```

- 이전 버전의 레플리카셋으로 되돌리는 롤백 실행

    ```bash
    kubectl rollout undo deployment my-nginx-deployment --to-revision=1
    ```

- 디플로이먼트의 정보 출력

    ```bash
    kubectl describe deploy my-nginx-deployment
    ```

- 리소스 정리

    ```bash
    kubectl delete deployment,pod,rs --all
    ```


# 6.5 서비스(Service): 포드를 연결하고 외부에 노출

- docker run -p 명령어와는 달리 쿠버네티스는 디플로이먼트를 생성할 때 포드를 외부로 노출하지 않으며, 디플로이먼트의 YAML 파일에는 단지 포드의 애플리케이션이 사용할 내부 포트만 정의한다.
- YAML 파일에서 containerPort 항목을 정의했다고 해서 이 포드가 바로 외부로 노출되는 것은 아니다. 이포트를 외부로 노출해 사용자들이 접근하거나, 다른 디플로이먼트의 포드들이 내부적으로 접근하려면 서비스라고 부르는 별도의 쿠버네티스 오브젝트를 생성해야 한다.
- 서비스의 핵심 기능
    - 여러 개의 포드에 쉽게 접근할 수 있도록 고유한 도메인 이름을 부여
    - 여러 개의 포드에 접근할 때, 요청을 분산하는 로드 밸런서 기능을 수행
    - 클라우드 플랫폼의 로드 밸런서, 클러스터 노드의 포트 등을 통해 포드를 외부로 노출
- **서비스에는 IP 뿐만 아니라 서비스 이름 그 자체로도 접근할 수 있다.**

## 6.5.1 서비스의 종류

- ClusterIP 타입
    - 쿠버네티스 내부에서만 포드들에 접근할 때 사용.
    - 외부로 포드를 노출하지 않기 때문에 쿠버네티스 클러스터 내부에서만 사용되는 포드에 적합하다.
- NodePort 타입
    - 포드에 접근할 수 있는 포드를 클러스터의 모든 노드에 동일하게 개방. 외부에서 포드에 접근 할 수 있는 서비스 타입
    - 접근할 수 있는 포트는 랜덤으로 정해지지만, 특정 포트로 접근하도록 설정할 수도 있다.
- LoadBalancer 타입
    - 클라우드 플랫폼에서 제공하는 로드 밸런서를 동적으로 프로비저닝해 포드에 연결
    - NodePort 타입과 마찬가지로 외부에서 포드에 접근할 수 있는 서비스 타입

## 6.5.2 ClusterIP 타입의 서비스 - 쿠버네티스 내부에서만 포드에 접근하기

- `spec.selector`: selector 항목은 이 서비스에서 어떠한 라벨을 가지는 포드에 접근할 수 있게 만들 것인지 결정한다.
- `sepc.ports.port`: 생성된 서비스는 쿠버네티스 내부에서만 사용할 수 있는 고유한 IP(ClusterIP)를 할당받는다. port 항목에는 서비스의 IP 에 접근할 때 사용할 포트를 설정한다.
- 포드에 접근하는 과정
    1. 특정 라벨을 가지는 포드를 서비스와 연결하기 위해 서비스의 YAML 파일에 selector 항목을 정의
    2. 포드에 접근할 때 사용하는 포드(포드에 설정된 containerPort)를 YAML 파일의 targetPort 항목에 정의
    3. 서비스를 생성할 때, YAML 파일의 port 항목에 8080을 명시해 서비스의 ClusterIP 와 8080 포트로 접근할 수 있게 설정
    4. kubectl apply -f 명령어로 ClusterIP 타입의 서비스가 생성되면 서비스는 쿠버네티스 클러스터 내부에서만 사용할 수 있는 고유한 내부 IP 를 할당받는다.
    5. 쿠버네티스 클러스터에서 서비스의 내부 IP 또는 서비스 이름으로 포드에 접근할 수 있다.
- **서비스의 라벨 셀렉터와 포드의 라벨이 매칭돼 연결되면 쿠버네티스는 자동으로 엔드포인트라고 부르는 오브젝트를 별도로 생성한다.**
    - `kubectl get endpoints`
- 서비스의 삭제
    - `kubectl delete svc "서비스명"`
    - `kubectl delete -f "서비스 파일명"`

## 6.5.3 NodePort 타입의 서비스 - 서비스를 이용해 포드를 외부에 노출하기

- NodePort 타입의 서비스는 모든 노드의 특정 포트를 개발해 서비스에 접근하는 방식이다.
- 각 노드에서 개방되는 포트는 기본적으로 30000~32768 포트 중에 랜덤으로 선택되지만, YAML 파일에 nodePort 항목을 정의하면 원하는 포트를 선택할 수도 있다.
- NodePort 타입은 ClusterIP 의 기능을 포함하고 있어서 내부 네트워크와 외부 네트워크 양쪽에서 접근할 수 있다.

## 6.5.5 트래픽의 분배를 결정하는 서비스 속성: externalTrafficPolicy

- `kubectl get svc "서비스명" -o yaml` : 서비스의 모든 속성 출력
- kubectl get 에서 `-o` 옵션을 이용해 리소스의 정보를 yaml, json 등의 형식으로 출력할 수 있다.
- 서비스는 기본적으로 externalTrafficPolicy 속성이 Cluster 로 설정된다. 이 경우 모든 워커 노드에서 동일한 랜덤 포트가 개방된다.
- 서비스의 externalTrafficPolicy 속성을 Local 로 설정해 생성하면 포드가 위치한 노드만 랜덤한 포트를 개방한다. 로드밸런서는 포드가 위치한 노드로만 요청을 전달하며, 해당 노드 내의 포드에서만 요청이 분산된다. 따라서 네트워크 홉이 한 단계 적으며, 클라이언트의 IP 또한 포드의 소스코드 내에서 정상적으로 확인할 수 있다.
    - 특정 노드의 포드에 부하가 집중되거나 적어질수도 있다. (11 장에서 좀 더 자세히 설명)

## 6.5.6 요청을 외부로 리다이렉트하는 서비스: ExternalName

- ExternalName 타입을 사용해 서비스를 생성하면 서비스가 외부 도메인을 가리키도록 설정할 수 있다.
    - 쿠버네티스와 별개로 존재하는 레거시 시스템에 연동해야 하는 상황에서 유용하게 사용 가능