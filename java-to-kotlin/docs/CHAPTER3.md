# CHAPTER 3 자바 클래스에서 코틀린 클래스로

- kotlin 에서 비교 연산 
  - == 는 내부적으로 equals 를 호출한다. 따라서 주소값이 아닌 값(동등성) 비교를 한다.
  - === 는 주소값을 비교할 때 사용한다.
  - 아래 예제에서는 string 값이 string pool 에 저장되기 때문에 true 가 나온다.
  - ~~~kotlin
    val a: String = "hello world!"
    val b: String = "hello world!"

    println(a == b) // true
    println(a === b) // true
    ~~~
- 주 생성자
  - 코틀린 클래스는 주 생성자 안에서 프로퍼티를 선언(클래스 이름 뒤에 있는 파라미터 목록이 주 생성자다.)
    - 파라미터 앞에 val 이 붙어 있어야 프로퍼티로 취급된다.
  - 생성자 파라미터를 한 줄에 하나씩 배치하면 가독성에 도움이 된다.
- getter
  - 클래스에 프로퍼티를 선언하면 코틀린 컴파일러가 비공개 필드와 접근자 메서드(getter)를 생성해 준다.
- 데이터 클래스
  - 클래스 앞에 data 변경자를 붙이면 컴파일러가 사용자가 정의하지 않은 equals, hashCode, toString 메소드를 자동으로 대신 생성해 준다.
  - 데이터 클래스의 한계
    - 데이터 클래스에 있는 copy 메소드는 항상 공개 메서드이기 때문에 불변 조건을 지키지 않는 새로운 값을 만들 수 있다.
    - 이 책의 예제에서는 Money 라는 클래스를 of 라는 스태틱 메서드를 통해 불변 상태를 유지하도록 했는데 data class 로 만들면서 copy 메소드가 생성되고 불변을 유지 할 수 없게 된다.
  - **값 타입이 불변 조건을 유지해야 하거나 내부 표현을 캡슐화해야 한다면 데이터 클래스가 적합하지 않다. 이런 경우에는 직접 값 의미론을 구현해야만 한다.**
- kotlin require, check 와 같은 예외처리 함수
  - 런타임에 오류가 나기 때문에 그렇게 좋은 패턴은 아니다.
- **팩토리 메소드를 만들 때 생성자를 통해서 만드는 것과 동치가 아니라면 생성자는 감추는 것이 좋다.**
- 코틀린의 substring 은 잘못된 인덱스 참조시 런타임 익셉션이 발생하므로 조심해서 사용해야 한다.