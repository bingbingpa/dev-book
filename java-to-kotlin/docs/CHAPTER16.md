# CHAPTER 16 인터페이스에서 함수로

- 자바에서는 기능을 정의하는 코드와 기능이 필요한 코드 사이에 계약을 지정하기 위해 인터페이스를 사용한다.
- 은닉은 클라이언트와 구현자 모두에게 유용하다.
  - 클라이언트는 사용 지점에서 세부 설정을 제공해야만 하는 문제로부터 자유로와지며, 구현자는 사용자와 별도로 구현을 개선할 수 있게 된다(인터페이스로 표현한 API 를 변경하지 않은 경우에)
- 인터페이스를 구현하기 위해 꼭 이름이 붙은 클래스를 작성할 필요는 없다. 대신, 익명으로 제공할 수도 있다.
  - 이렇게 처리하면 클라이언트가 특정 구현 클래스에 의존해서 객체를 다운 캐스팅한 후 다른 메서드를 호출하는 등의 조작이 불가능해진다.
- 코틀린 1.4 에서는 인터페이스를 `fun interface`(추상 메서드가 단 하나뿐인 인터페이스: Single Abstract Method(SAM))로 정의할 수 있다.
  - fun interface 로 정의하면 메서드가 하나뿐인 객체를 선언하는 대신에 람다를 사용해 인터페이스의 유일한 연산을 정의할 수 있다.
  - [kotlin SAM interface 참고](https://kotlinlang.org/docs/fun-interfaces.html#sam-conversions)
- 함수용 용어 `부분 적용`
  - 부분 적용은 함수의 인자 중 일부를 고정시키면서 인자가 더 적은 새 함수를 만들어내는 기법이다.
  - 코틀린에서 부분 적용을 사용하는 가장 쉬운 접근 방법은 설정 정보를 일부만 적용하는 함수를 작성하는 것이다.
- 함수적 해법과 객체 지향 해법을 하나로 합치는 한 가지 방법은 함수를 오직 invoke 라는 메서드만 제공하는 객체로 간주하는 것이다.
  - 정확히 자바 8이 람다를 도입할 때 취한 전략이 이 방법이다.
  - 함수 타입을 가리키기 위해 자바는 원하는 시그니처의 단일 추상 메서드(SAM) 인터페이스를 사용한다.
  - 자바 람다는 SAM 인터페이스를 구현하기 위해 허용되는 특별한 문법이다.
- 코틀린의 () -> Unit 과 같은 타입의 결과를 자바의 Consumer\<T> 타입의 변수에 대입할 수 없다.
  - 이는 코틀린 런타임은 자체적인 함수 타입을 사용해서 컴파일러가 FunctionN 타입으로 컴파일하기 때문이다.
- **자바와 코틀린에서 함수 타입은 인터페이스에 불과하다.**
- **더 큰 인터페이스에 의존하면 우리에게 필요한 연산이 무엇인지 명확히 의사소통할 수 있는 기회가 사라지고, 클라이언트가 어쩔 수 없이 모든 인터페이스를 구현하게 된다.**
- **고객의 필요를 함수 타입으로 표현하는 쪽을 디폴트로 택하고, 함수를 사용하는게 너무 힘들어지면 그 때 클래스로 전환해야 한다???????.**