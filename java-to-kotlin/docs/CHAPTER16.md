# CHAPTER 16 인터페이스에서 함수로

- 인터페이스는 계약의 두 당사자를 서로 결합시키기 때문에 소프트웨어가 더 유지 보수하기 어려워진다.
  - 구체적인 구현에 의존하는거 보다 낫긴 하지만 인터페이스를 바꾸기 어려워진다.
  - 추상화보다 더 유연하게 하려면?
    - 시그니처만 전달한다?
    - 인터페이스에 메소드 하나만 정의해서 람다로 전달한다?
    - 유연성과 암시적인 코드 사이에서 적절한 조율이 필요하다.
- 자바에서는 기능을 정의하는 코드와 기능이 필요한 코드 사이에 계약을 지정하기 위해 인터페이스를 사용한다.
- 은닉은 클라이언트와 구현자 모두에게 유용하다.
  - 클라이언트는 사용 지점에서 세부 설정을 제공해야만 하는 문제로부터 자유로와지며, 구현자는 사용자와 별도로 구현을 개선할 수 있게 된다(인터페이스로 표현한 API 를 변경하지 않은 경우에)
- 익명 클래스 (object: ISendEmail {}) 는 컴파일 타임에 만들어진다.
- 인터페이스를 구현하기 위해 꼭 이름이 붙은 클래스를 작성할 필요는 없다. 대신, 익명으로 제공할 수도 있다.
  - 이렇게 처리하면 클라이언트가 특정 구현 클래스에 의존해서 객체를 다운 캐스팅한 후 다른 메서드를 호출하는 등의 조작이 불가능해진다.
- 코틀린 1.4 에서는 인터페이스를 `fun interface`(추상 메서드가 단 하나뿐인 인터페이스: Single Abstract Method(SAM))로 정의할 수 있다.
  - fun interface 로 정의하면 메서드가 하나뿐인 객체를 선언하는 대신에 람다를 사용해 인터페이스의 유일한 연산을 정의할 수 있다.
  - [kotlin SAM interface 참고](https://kotlinlang.org/docs/fun-interfaces.html#sam-conversions)
- 함수용 용어 `부분 적용`
  - 부분 적용은 함수의 인자 중 일부를 고정시키면서 인자가 더 적은 새 함수를 만들어내는 기법이다.
  - 코틀린에서 부분 적용을 사용하는 가장 쉬운 접근 방법은 설정 정보를 일부만 적용하는 함수를 작성하는 것이다.
- **언제 ISenderEmail(인터페이스) 을 안쓰고 (Email) -> Unit 을 쓸까?**
  - 언제 강타입을 쓰고, 언제 Pair 를 쓸것인가와 비슷한 문제다.
  - 메서드가 하나인 인터페이스 쓰기 귀찮을때 함수형으로 쓴다.😅
  - 단점도 Pair 를 쓸때와 똑같다. Pair 가 first, second 만 알 수 있는 것처럼 함수형으로 쓰면 받은 파라미터 말고는 알 수가 없다.
  - **통제 할 수 있는 작은 범위 내에서만 사용하도록 하자.**
- 함수적 해법과 객체 지향 해법을 하나로 합치는 한 가지 방법은 함수를 오직 invoke 라는 메서드만 제공하는 객체로 간주하는 것이다.
  - 정확히 자바 8이 람다를 도입할 때 취한 전략이 이 방법이다.
  - 함수 타입을 가리키기 위해 자바는 원하는 시그니처의 단일 추상 메서드(SAM) 인터페이스를 사용한다.
  - 자바 람다는 SAM 인터페이스를 구현하기 위해 허용되는 특별한 문법이다.
- 코틀린의 () -> Unit 과 같은 타입의 결과를 자바의 Consumer\<T> 타입의 변수에 대입할 수 없다.
  - 이는 코틀린 런타임은 자체적인 함수 타입을 사용해서 컴파일러가 FunctionN 타입으로 컴파일하기 때문이다.
- 자바와 코틀린에서 함수 타입은 인터페이스에 불과하다.
  - 코틀린에서는 함수가 일급 객체이기 때문에 타입으로 들어갈 수도 있다.
- **더 큰 인터페이스에 의존하면 우리에게 필요한 연산이 무엇인지 명확히 의사소통할 수 있는 기회가 사라지고, 클라이언트가 어쩔 수 없이 모든 인터페이스를 구현하게 된다.**
- **고객의 필요를 함수 타입으로 표현하는 쪽을 디폴트로 택하고, 함수를 사용하는게 너무 힘들어지면 그 때 클래스로 전환해야 한다???????.**
- 부모가 operator 이면 override 할때는 operator 를 붙일 필요는 없다. 
