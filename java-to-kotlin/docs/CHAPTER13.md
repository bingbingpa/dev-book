# CHAPTER 13 스트림에서 이터러블이나 시퀀스로

- 자바 스트림은 지연 계산을 수행한다.
  - 지연 계산은 뒤쪽 파이프라인 단계가 앞쪽 단계에서 수행해야 하는 작업의 양을 제한한다는 뜻이다.
  - [지연연산 관련 참고](https://bugoverdose.github.io/development/stream-lazy-evaluation/)
- 스트림은 모든 CPU 코어를 최대한 활용하고 싶을 정도로 대규모로 데이터를 처리하는 경우에 유용하다.
  - 장바구니에 있는 다섯 가지 상품의 가격 합계를 계산할 때는 적당하지 않다.
- 다른 Stream 을 반환하는 Stream.filter 와 달리 코틀린 filter 는 List 를 반환한다.(List 도 Iterable 이기 때문에 함수 호출을 계속 연쇄할 수 있다)
- 코틀린 코드는 컬렉션 크기가 크지 않다면 빠르게 작동한다. 컬렉션이 크다면 코틀린에서는 시퀀스로 전환할 수 있다.
- 코틀린 시퀀스느 자바 스트림과 같은 지연 계산을 제공한다.
- **Iterable 에 대한 연산은 즉시 계산이지만 Sequence 에 대한 연산은 지연 계산이기 때문에 이 둘을 아무 불이익 없이 바꿔 사용할 수는 없다.**
- 시퀀스를 사용하면 각 단계의 결과를 저장하기 위한 중간 리스트 생성 비용이 들지 않는다.
  - 하지만 원소 갯수가 적다면 파이프라인을 만들고 실행하는 비용이 리스트를 생성하는 비용보다 더 비싸진다.
- sumBy 는 Int 를 반환하는 함수를 파라미터로 받는 박싱으로 박싱을 피한다.
- 지연 계산이 필요한 경우
  - 입력을 읽는 작업을 다 끝내기 전에 결과를 얻어야 할 필요가 있다.
  - (중간 결과를 포함했을 때) 메모리 용량보다 더 큰 데이터를 처리해야 할 필요가 있다.
  - 파이프라인 단계가 긴 큰 컬렉션, 이런 컬렉션에서는 중간 단계의 컬렉션을 만들어내는 과정이 느릴 수 있다.
  - 파이프라인 뒤쪽 단계에서만 얻을 수 있는 정보를 활용해 파이프라인 앞쪽 단계에서 원소 중 일부를 건너뛸 수 있는 경우
- 연산을 연쇄시킬 때 확장 함수를 사용하면 메소드 호출 없이 가독성을 더 좋게 할 수 있는것 같다.
- **코틀린의 시퀀스는 자바의 스트림 대체제가 아니다. 전혀 다르다.**
  - 시퀀스는 지연 연산이 아니라 suspend 가 걸려 있는거다.
- 자바에서 parallelStream 은 commonForkJoinPool 을 조정해서 병렬처리에 대한 스레드풀을 조정할 수 있다.
- 코틀린에 parallelStream 이 없는 이유는 시퀀스가 코루틴을 사용하기 때문에 디스패처를 뭘 쓰냐에 따라 병렬 처리가 가능하다.
- 자바는 스트림이 멀티스레드 관련 처리까지 하기 때문에 무겁다. 그래서 데이터양이 많아야 스트림이 효과가 있다.
- 코틀린은 컬렉션의 대부분의 연산이 인라인으로 들어가기 때문에 대부분의 연산이 for 문으로 대체되기 때문에 가볍다.
  - 대신 iterable 의 연산마다 새로운 컬렉션을 반환하기 때문에 메모리를 생각해서 사용해야 한다.
  - 코틀린에서 시퀀스를 쓸지 iterable 을 쓸지는 데이터의 양 뿐만 아니라 연산이 얼마나 중첩 되었는지를 가지고 판단하는게 좋다.
- subBy 는 박싱을 하지 않는다.
  - subBy 하기 전에는 map 을 만들면서 박싱을 해서 만들고 sum() 을 하면서 언박싱이 이루어지는데 subBy 는 map 을 만들지 않아서 박싱을 하지 않는다.
- constrainOnce() 는 시퀀스를 두 번 소비하려고 시도하면 IllegalStateException 을 던진다.
- [iterable vs sequence 참고](https://kotlinlang.org/docs/sequences.html#sequence-processing-example)
- typealias 는 가급적 쓰지 말자. 코드의 강타입 체계를 무너뜨린다.
  - 271 페이지에 있는 것처럼 쓰면 Event 를 기대하지만 Map<String, Any?> 타입 이기 때문에 의도하지 않은 값을 받을 수도 있다.