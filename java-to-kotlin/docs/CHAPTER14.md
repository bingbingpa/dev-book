# CHAPTER 14 누적시키는 객체에서 변환으로

- 가변 상태를 사용하는 방식의 단점
  - 에일리어싱 오류를 일으킬 가능성이 있다.
    - 예로 함수가 자신에게 전달된 가변 리스트 파리머터를 정렬해서 호출한 쪽에 문제가 생겼던 6장의 경우가 있다.
  - 가변 상태를 리셋하지 않는 실수가 발생할 수도 있고, 가변 상태에 변경하는 메소드를 사용할 때는 더 넓은 문맥에서 이 메소드가 어떻게 쓰이는지를 이해해야한다.
  - 알고리즘 구현이 여기저기 흩어져 있다.
    - 가변 상태를 공유해서 계산을 수행하면 책임이 여러 클래스에서 지저분하게 분산되는 경우가 흔하다.
- [백킹 필드 네이밍 컨벤션](https://kotlinlang.org/docs/coding-conventions.html#names-for-backing-properties)
  - 클래스에 개념적으로 동일한 두 개의 속성이 있지만 하나는 공용 API 의 일부이고 다른 하나는 구현 세부 정보인 경우 세부 속성 이름을 접두사로 밑줄을 사용한다.
- **일단 가변성을 넣고 나면 나중에 제거하기가 힘든 경우가 많다.**
- 누적 시키는 가변 변수의 경우는 fold 를 활용해보자.
- toList() 계열의 함수는 컬렉션을 복사해서 리턴한다.
- reduce vs fold
  - reduce 는 빈 경우 예외를 발생시키고 fold 는 빈 경우 기본값을 리턴한다.
  - reduce 는 예외 발생시키니까 되도록 fold 를 쓰는걸 추천. 그치만 fold 는 초기값 주는게 귀찮다... 
- 가변 상태를 런타임의 책임으로 만든다.
  - 가변 상태를 지역 변수로만 사용하겠다는 뜻