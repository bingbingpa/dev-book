# CHAPTER 15 캡슐화한 컬렉션에서 타입 별명으로

- 코틀린에서는 변이 제어에 신경을 덜 써도 된다?
  - 코틀린에서는 불변 컬렉션이 있기 때문에 변이 제어가 조금 더 수월하다.
- 자바 컬렉션 인터페이스는 객체 지향이라는 뿌리를 따라서 근본적으로 가변적이다. 반면 코틀린은 컬렉션을 값 타입으로 다룬다.
- 코틀린은 정적 함수를 더 쉽게 발견할 수 있게 도와주는 확장 함수와 불변 컬렉션을 제공하기 때문에, 도메인 모델을 컬렉션 타입으로 나누고 연산을 도메인 모델과 분리하는 쪽이 더 편하다.
- 정적 함수의 발견 가능성이 낮다?
  - 스태틱 객체를 먼저 찾아야 하기 때문에 발견 가능성이 낮다.
  - 인스턴스 메소드와 비교하면 발견 가능성이 현격하게 낮다.
- 일급 컬렉션을 data class 로 사용하는것도 괜찮을까?
  - data class 의 목적은 생성자로 받은 프로퍼티를 public 으로 사용하는 것이지만 일급 컬렉션은 생성자로 받은 컬렉션을 private 로 사용하기 때문에 data class 바꿀 수는 있지만 적합하지는 않다.
- typealias 는 private 으로만 쓰자!
  - typealias DDD = String 과 같이 쓰고 typealias 의 확장함수를 정의해도 확장함수만 import 하면 된다. 
  - typealias 의 import 가 강제 되지 않기 때문에 가급적 private 으로만 쓰자.
- 책에서 나온것처럼 List\<Journey> 의 확장 함수로 쓸 것인가? 컬렉션을 감싸서 일급 컬렉션으로 쓸 것인가?
  - 규모가 작다면 확장 함수로 사용해도 괜찮다. 문맥적으로 충분히 이해할 수 있기 때문에...
  - 규모가 커지면 해당 타입(List\<Journey>)에 대한 소유권이 불분명해진다. 여기저기 확장함수가 추가 되고 중구 난방... 
  - 그래서 확장 함수보다는 컬렉션을 감싸서 사용하는 것이 코드에 대한 소유권이 분명해지고 규모가 커져도 이해하기 쉽다.
  - 컬렉션에 대해 제공해야 할 기능들이 많다면 delegate 를 사용하고, 꼭 사용 못하게 해야할 메소드가 있다면 override 해서 nothing 처리 또는 Ex 를 던지는 것도 괜찮을듯?
  - delegate 를 쓸 때 생성자로 받는 파라미터는 val 을 붙일 필요는 없다.(프로퍼티가 아니라 파라미터여도 된다.)