# CHAPTER 8 정적 메서드에서 최상위 함수로

- 독립적인 함수들은 소프트웨어의 토대를 이루는 빌딩 블록들이다.
- 정적 함수는 그 함수가 작용할 대상 타입에 메서드를 추가하지 않고 기능을 추가하고 싶을 때 유용하다.
  - 메서드를 추가하지 않고 기능을 추가하고 싶어지는 이유는 클래스가 이미 너무 많은 메서드로 인해 축 늘어져 있거나, 클래스를 우리가 소유하지 않아서 메서드를 해당
  클래스에 추가할 수 없기 때문이다.
  - 또 다른 이유로 해당 함수의 기능이 제네릭 타입의 몇 가지 인스턴스에만 적용되기 때문에 제네릭 클래스의 멤버로 선언할 수 없는 때도 있다.
- **JVM 은 실제로 진정한 최상위 함수가 아니라 정적 메서드만 지원한다.**
- 코틀린은 함수(그리고 프로퍼티와 상수)를 클래스 밖에 선언하도록 허용한다.
  - JVM 에서는 이런 함수를 둘 곳이 없으므로 코틀린 컴파일러는 이런 최상위 선언을 넣기 위해 정적 멤버가 들어있는 클래스를 생성해 준다.
  - 컴파일러는 디폴트로 함수 정의가 들어있는 파일 이름으로부터 클래스 이름을 파생시킨다.
  - @file:JvmName 애너테이션을 파일 맨 앞에 추가해서 정적 클래스의 이름을 지정할 수도 있다.
- 자바의 정적 메서드를 자동으로 코틀린으로 변환하면 object 선언이 생기고, 이 선언을 자바와 코틀린에서 함께 접근 할 수 있다.
  - object 의 모든 멤버는 그 객체의 이름과 똑같은 이름의 클래스 안에 멤버로 들어가는데, @JvmStatic 으로 지정하지 않는 경우 실제 정적 멤버로 컴파일되지는 않는다.
- 인터페이스를 구현하는 능력이 필요하거나 함수들을 좀 더 밀접하게 묶고 싶은 경우에만 함수를 최상위 함수 대신 싱글턴 객체안의 메서드로 정의하는 쪽을 선택해야 한다.
- Stream.sorted()는 스트림의 요소들이 어떤 기준으로 정렬되어 전달되는 새로운 스트림 객체를 리턴한다.
- `with` 나 `without` 같은 전치사는 해당 함수가 **원본 객체를 변경하지 않고 복사본을 반환**한다는 사실을 코드을 읽은 사람에게 알려 주는 유용한 단어다.
- **최상위 함수는 언제 써야 하나? 좋은건가?**
  - object 안에 가두던가 companion object 안에 쓰는게 좋지 않을까? 함수를 찾거나 잘못 임포트 하기 쉽다.
  - 패키지를 잘 나누면 쓸데없이 클래스를 만들지 않고 패키지로 잘 구분해서 유용하게 쓸 수도 있지 않을까?
- 제너럴한 타입에 대한 확장 함수가 좋은가?
  - 해당 프로젝트에서는 편하게 쓰일 수 있지만 다른 프로젝트에서 해당 확장 함수가 없다면?? 그렇다면 관리는 어떻게 할것인가?
  - 특정 타입에 대해서만 쓰는게 좋지 않을까가 다수의 의견