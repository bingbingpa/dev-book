# 프로그래머의 뇌(훌륭한 프로그래머가 알아야 할 인지과학의 모든 것)
- *펠리너 헤르만스 저/차건회 역 제이펍*

<br>

- 코딩에 영향을 주는 인지 과정
    - 장기 기억 공간(long-term memory, LTM): 기억하는 내용을 반 영구적으로 저장하는 곳
    - 단기 기억 공간(short-term memory, STM): 정보를 수집할 때 단기 기억 장소에 일시적으로 저장
    - 작업 기억 공간(working memory): 많은 정보를 처리할 때 사용
- 코드가 이해하기 어렵고 혼란을 초래하는 원인 세가지
    - 프로그래밍 언어나 알고리즘 혹은 업무 영역에 대한 지식이 없는 경우(LTM 의 문제)
    - 코드를 이해하기 위해 필요한 정보를 충분히 가지고 있지 못하는 경우, ex) 라이브러리에 대한 정보 같은… (STM 의 문제)
    - 코드가 너무 복잡해서 혼란이 생기는 경우, 이건 두뇌의 처리 용량이 부족하기 때문이다.(작업 기억 공간의 문제)
- 코드를 기억해내는 일은 프로그래밍에 대한 지식이 어느 정도인지 가늠해볼 수 있는 자가 진단 도구로 사용될 수 있다.
    - 이미 알고 있는 것을 기억하는 것은 쉽기 때문에 기억해낸 코드는 자기가 이미 잘 알고 있는 디자인 패턴, 프로그래밍 구성 요소, 도메인 지식 등을 드러내준다.
- 리팩터링은 코드를 읽는 사람이 이미 가지고 있는 지식에 맞춰 코드를 변경함으로써 외재적 인지 부하를 줄이는 방법이다.
- 모델은 실재를 간단하게 표현한 것으로, 주된 목적은 문제에 대해 생각하고 해결하는데 도움을 주기 위한 것이다.
- 문제를 풀 때 코드의 모델을 명시적으로 사용하는 것의 두 가지 장점
  - 모델은 프로그램에 대한 정보를 다른 사람과 공유할 때 유용하다.
    - 상태표를 만들어서 다른 사람에게 보여주면 각 단계에서의 변수의 값을 통해 코드가 어떻게 작동하는지 이해하는데 도움이 된다.
  - 두뇌에서 한 번에 처리할 수 있는 한계에 도달했을 때 모델을 만들면 인지 부하를 줄일 수 있어 문제를 풀 때 도움이 된다.
- 모델을 개선하기 위한 질문들
  - 시스템에서 가장 중요한 요소(클래스, 객체, 페이지) 는 무엇인가? 모델에 그것들이 포함되었는가?
  - 이 중요한 요소들 사이의 관계는 무엇인가?
  - 프로그램의 주요 목표는 무엇인가?
  - 목표가 핵심 요소 및 그 관계와 어떻게 관련되어 있는가?
  - 일반적인 사용 사례는 무엇인가? 모델이 그것을 보여주는가?
- 기존 프로그래밍 지식을 활용할 가능성을 높이는 방법
  - 숙달
    - LTM 에 이미 저장되어 있는 지식과 관련한 작업을 얼마나 잘 숙달했는지에 대한 것이다. 
    - 작업을 더 잘 알수록 다른 도메인에 더 잘 적용할 수 있다.
  - 중요 특성
    - 새로운 프로그래밍 언어나 프레임워크를 배우기 전에 공통점을 적극적으로 찾고 곰곰이 생각해보는 것이 중요할 수 있다.
    - 새 작업에 도움이 될 수 있는 기존 지식은 무엇일지 스스로 질문해보고 그에 대한 답을 찾아야 한다.
- 새로운 프로그래밍 언어를 배울 때 오개념 방지하기
  - 자신이 옳다고 확신하더라도 여전히 틀릴 수도 있다는 것을 아는 것이 중요하다. 열린 마음을 유지하는 것이 핵심이다.
  - 흔하게 발생하는 오개념에 대해 의도적으로 연구해봄으로써 그런 오개념에 빠지는 것을 방지 할 수 있다.
  - 같은 프로그래밍 언어를 같은 순서로 학습한 다른 프로그래머들에게 조언을 구한다.
- 오개념을 방지하는 데 도움이 되기 위해 코드베이스 내의 테스트 및 문서화를 사용하자.
- 이름 짓는 일은 어렵지만, 코드에서 우리가 추론하는 객체에 맞는 이름을 고르는 것은 중요하다.
  - 이름은 코드베이스 내에서 바로 사용할 수 있기 때문에 일종의 중요한 문서로 기능한다.
  - 잘못된 이름을 사용하면 코드에 미치는 영향이 심각하고, 코드 이해를 어렵게 하며, 버그 발생 가능성도 높아진다.
- 코드 스멜은 작동은 하지만 개선의 여지가 있는 코드를 의미한다.

| 코드 스멜             | 설명                                                                                                         | 수준    |
|-------------------|------------------------------------------------------------------------------------------------------------|-------|
| 긴 메서드             | 메서드는 여러 가지 다른 일을 수행하느라 라인이 길어져서는 안 된다.                                                                     | 메서드   |
| 많은 인수             | 메서드는 인수가 많으면 안 된다.                                                                                         | 메서드   |
| 스위치 문             | 스위치 문이 길면 안 된다. 다형성을 통해 해결할 수 있다.                                                                          | 메서드   |
| 다른 것처럼 보이나 같은 클래스 | 처음 보면 다른 것처럼 보이지만 유사한 필드와 메서드를 갖는 클래스가 두 개 있으면 안 된다.                                                       | 클래스   |
| 너쿠 큰 클래스          | 너무 많은 메서드와 필드를 가지고 있어서 클래스가 제공하는 추상화를 불명확하게 만들어서는 안 된다.                                                    | 클래스   |
| 게으른 클래스           | 클래스가 하는 일이 너무 적으면 존재할 이유가 없다.                                                                              | 클래스   |
| 산재한 수정            | 일반적으로 코드 수정은 한 클래스의 한 부분에서만 이루어져야 한다. 클래스의 여러 부분을 수정해야 한다면 코드 구조가 잘못된 것을 의미한다.                             | 코드베이스 |
| 기능 이전             | 클래스 A 의 많은 메서드가 클래스 B 에 의해 참조되면 그 메서드들은 B 로 옮겨야 한다.                                                        | 코드베이스 |
| 상속 거절             | 클래스가 자신이 사용하지 않는 것을 상속받는다면 상속은 필요 없는 일일지도 모른다.                                                             | 코드베이스 |
| 샷건 수술             | 일반적으로 코드 수정은 한 클래스에 대해서만 이루어져야 한다. 하나의 사항에 대해 여러 클래스를 수정해야 한다면 코드 구조에 문제가 있으므로 수정할 여러 부분을 하나의 클래스로 묶어야 한다. | 코드베이스 |
| 추측에 근거한 일반성       | 만일의 경우를 대비한 코드를 추가하지 말고 필요한 기능만 추가하라.                                                                      | 코드베이스 |

- 문제 해결 검토
  - 달성하고자 하는 목표 상태는 무엇이었는가?
  - 목표 상태를 어떻게 확인했는가? 직접 혹은 다른 사람이, 수동으로 혹은 단위 테스트나 합격 테스트를 통해 했는가?
  - 시작 상태는 무엇이었는가?
  - 어떤 규칙과 제약 조건이 적용되었는가?
- **전문가들이 하는 일을 한다고 해서 여러분이 전문가가 되는 것은 아니다.**