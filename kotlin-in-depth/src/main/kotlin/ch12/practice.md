# 12장 정리 문제

1. 합성 프로퍼티란 무엇인가? 자바 접근자 메서드를 코틀린에서 사용할 때 적용되는 규칙은 무엇인가?

    - 합성프로퍼티란?
    - 자바 게터 세터가 코틀린의 합성 프로퍼티로 사용되기 위한 규칙
      - 게터는 파라미터가 없는 메서드여야 하며, 메서드 이름이 get 으로 시작해야 한다.
      - 세터는 파라미터가 하나만 있는 메서드여야 하며, 메서드 이름이 set 으로 시작해야 한다.
      - 게터 이름은 is 로 시작할수도 있다.

2. 플랫폼 타입이란 무엇인가? 코틀린이 지원하는 플랫폼 타입의 종류를 설명하라.

   - 자바 코드로부터 비롯된 객체
   - byte/Byte -> Byte
   - short/Short -> Short
   - int/Integer -> Int
   - long/Long -> Long
   - char/Character -> Char
   - float/Float -> Float
   - double/Double -> Double

3. 자바 코드의 널 가능성 애너테이션이 코틀린 타입에 어떤 영향을 미치는가?

   - 자바 코드에 붙은 애너테이션에 따라 널이 될 수 있거나 널이 될 수 없는 타입 중 하나로 정해지며, 플랫폼 타입으로 지정되지 않는다.

4. 코틀린 타입이 자바 타입으로 매핑되는 방식과 자바 타입이 코틀린 타입으로 매핑되는 방식을 설명하라.

   - 자바 원시 타입이나 원시 타입에 상응하는 박싱 타입은 코틀린의 기본 타입에 대응한다.
     - 이 매핑은 역방향으로도 적용된다.
   - java.lang 패키지에 들어 있는 원시 타입이 아닌 내장 클래스 중 일부도 kotlin 패키지에 있는 상응하는 코틀린 클래스로 매핑된다.
     - 유일한 차이는 코틀린 Any 는 자바 Object 로 매핑된다.
   - 코틀린으로 매핑된 자바 클래스의 정적 멤버를(예: Long.valueOf())를 코틀린 쪽 동반 객체에서 직접 접근할 수 없다.
     - 정적 멤버를 사용하려면 해당 자바 클래스의 전체 이름을 언급해야 한다.
   - 제네릭 타입의 매핑
      - 자바의 extends 와일드카드는 코틀린 공변 프로젝트로 변환된다. 예를 들어 TreeNode\<? extends Person> 은 TreeNode\<out Person>으로 바뀐다.
      - 자바의 super 와일드카드는 코틀린 반공변 프로젝션으로 변환된다. 예를 들어 TreeNode\<? super Person> 은 TreeNode\<in Person>으로 바뀐다.
      - 자바의 로우 타입은 코틀린 스타 프로젝션으로 바뀐다. 예를 들어 TreeNode 는 TreeNode\<*>가 된다.

5. 코틀린의 SAM 변환과 SAM 생성자를 설명하라. 코틀린의 함수형 인터페이스를 설명하라.

   - 코틀린은 자바 SAM 인터페이스가 필요한 위치에 람다를 널김 수 있게 지원하는데, 이를 SAM 변환이라고 한다.
   - 대상 타입을 지정해서 변환을 명시하는것을 SAM 생성자라고 부른다.
   - SAM 변환은 인터페이스에 대해서만 적용되고, 메서드가 하나뿐인 클래스에는 적용될 수 없다.
   - 코틀린 1.4 부터는 함수형 인터페이스를 선언하면 코틀린에서도 인터페이스 인스턴스 대신 람다를 쓸 수 있다.
     - 함수형 인터페이스는 추상 메서드가 하나뿐인 인터페이스 정의의 interface 앞에 fun 키워드를 붙인 인터페이스다.

6. 코틀린 프로퍼티를 자바 코드에서 어떻게 접근할 수 있는가?

   - 게터는 파라미터가 없는 메서드이며 게터의 반환 타입은 원래의 프로퍼티 타입과 같다. 
   - 게터의 이름은 프로퍼티 이름의 첫 번째 글자를 대문자로 바꾼 다음, 앞에 get 을 붙여서 생성된다.
   - 세터는 새로운 값에 해당하는 파라미터를 하나만 받는 메서드다.
   - 세터의 이름은 프로퍼티 이름의 첫 번째 글자를 대문자로 바꾼 다음, 앞에 set 을 붙여서 생성된다.
   - 프로퍼티 이름이 is 로 시작하는 경우 
     - 게터 이름은 프로퍼티와 같다.
     - 세터 이름은 맨 앞의 is 를 set 으로 바꾼 이름이다.

7. 자바 코드 쪽에서 코틀린 프로퍼티를 뒷받침하는 필드에 접근할 수 있는 경우는 언제인가?

   - @JvmField 애너테이션을 프로퍼티 앞에 넣는다.
   - lateinit 프로퍼티를 활용

8. 파일 퍼사드란 무엇인가? 코틀린 최상위 함수와 프로퍼티를 자바에서 사용하는 방법을 설명하라.

   - 최상위 함수와 프로퍼티를 위해 자동으로 생성된 클래스 
     - 기본적으로 퍼사드 클래스 이름은 소스코드 이름 뒤에 Kt 를 덧붙인 이름이 된다.
   - 퍼사드 클래스에 생성된 메서드는 정적 메서드이므로 자바 코드에서 최상위 메서드에 접근할 때 퍼사드 클래스를 인스턴스화할 필요가 없다. 

9. 여러 코틀린 파일을 한 파사드 클래스로 합치는 방법은 무엇인가?

   - 합치려는 파일마다 @JvmMultifileClass 라는 애너테이션을 붙이고 @JvmName 으로 클래스 이름을 지정한다.
   - 그러면 코틀린 컴파일러가 자동으로 퍼사드 클래스 이름이 같은 파일들의 선언을 한데 모아준다.

10. @JvmName 애너테이션 사용법을 설명하라.

    - @file:JvmName("퍼사드 클래스 이름")

11. 코틀린 객체 선언의 인스턴스가 자바 코드에서 어떤 식으로 노출되는지 설명하라.

    - 코틀린 객체 선언은 정적인 INSTANCE 필드가 있는 일반적인 클래스로 컴파일 된다.

12. 코틀린 객체 멤버를 자바에서 정적 멤버로 접근할 수 있게 하려면 어떻게 해야 하는가?

    - @JvmStatic 애너테이션을 사용한다.

13. @JvmOverloads 애너테이션은 어떤 효과가 있는가?

    - @JvmOverload 를 적용하면 원래 코틀린 함수 외에 오버로딩된 함수를 추가로 생성해준다.
      - 오버로딩된 첫 번째 함수는 마지막 파라미터를 제외한 나머지 인자를 받는 함수이며, 이 함수는 원래 함수의 마지막 파라미터를 디폴트 값으로 지정해준다.
      - 오버로딩된 두 번째 함수는 마지막 두 파라미터를 제외한 나머지 인자를 받는 함수이며, 이 함수는 원래 함수의 마지막 두 파라미터를 디폴트 값으로 지정해준다.
      - 세 번째, 네번째 함수도 이런식으로 점점 파라미터 수를 줄여나가면서 디폴트 값을 적용해준다.
      - 오버로딩된 마지막 함수는 파라미터를 하나만 받고, 나머지 파라미터를 디폴트 값으로 적용해준다.

14. 코틀린 함수에서 발생할 수 있는 검증 요류를 어떻게 기술할 수 있는가?

    - @Throws 애너테이션을 사용해 예외 클래스를 지정한다.