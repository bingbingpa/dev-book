# 4장 정리 문제

1. 코틀린 클래스의 기본적인 구조를 설명하라. 자바 클래스와 비교하면 어떤 차이가 있는가?
    - class 키워드 다음에 클래스 이름이 오고 그 다음에 클래스 본문이 오는 형태로 정의된다.
    - 자바와 달리 기본적인 가시성이 클래스가 포함된 패키지 내부로 제한된다.
    - 클래스의 파라미터를 기본 생성자로 사용할 수 있다. 
    - new 키워드를 통해 인스턴스를 생성하지 않는다.
    - 코틀린 클래스는 본문을 생략할 수 있다.
2. 주생성자란 무엇인가?
    - 클래스 헤더의 파라미터 목록 
    - 주생성자는 프로퍼티 초기화와 초기화 블록이 등장하는 순서대로 구성된다. 초기화 블록이란 init 이라는 키워드가 앞에 붙은 블록이다.
    - 클래스 안에 init 블록은 여럿 들어갈 수 있다. 이런 경우 각 블록은 프로퍼티 초기화와 함께 순서대로 실행된다.
    - init 블록 안에서 프로퍼티를 초기화하는 것도 허용한다.
    - 주생성자 파라미터를 프로퍼티 초기화나 init 블록 밖에서 사용할 수는 없다.
3. 부생성자란 무엇인가? 클래스에 어떤 생성자(또는 생성자들)를 포함시킬지와 주생성자 외에 부생성자가 더 필요할지를 어떻게 결정하는가?
    - constructor 키워드를 사용해 정의한 생성자
    - init 블록은 생성자 블록보다 먼저 실행된다.
    - 여러 생성자를 사용해 클래스 인스턴스를 서로 다른 방법으로 초기화 해야 할 때 사용
4. 코틀린이 지원하는 멤버 가시성은 무엇인가? 자바의 가시성과 어떤 차이가 있는가?
    - public: 멤버를 어디서나 볼 수 있다. 
    - internal: 멤버를 멤버가 속한 클래스가 포함된 컴파일 모듈 내부에서만 볼 수 있다.
    - protected: 멤버를 멤버가 속한 클래스와 멤버가 속한 클래스의 모든 하위 클래스 안에서 볼 수 있다.
    - private: 멤버를 멤버가 속한 클래스 내부에서만 볼 수 있다.
    - 코틀린에는 자바의 패키지 전용에 해당하는 가시성이 없다.
    - 자바의 기본 가시성은 패키지 전용이고, 코틀린은 기본 가시성이 public 이다.
5. 내포된 클래스 중에서 내부 클래스와 비내부 클래스의 차이는 무엇인가? 각각에 해당하는 자바 클래스와는 어떤 차이가 있는가 비교하라.
    - 자바 클래스는 디폴트로 내부 클래스이며, 내부 클래스가 외부 클래스 인스턴스와 연관되길 원하지 않으면 명시적으로 static 을 붙여야 한다.
    - 반면 코틀린의(inner 가 없는) 내포된 클래스는 외부 클래스 인스턴스와 연관되지 않는다.
    - 자바와 달리, 바깥쪽 클래스는 자신에게 내포된 클래스의 비공개 멤버에 접근할 수 없다.
    - 내포된 클래스를 둘러싸고 있는 클래스의 본문 밖에서는 내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.
6. 함수 본문에 클래스를 정의할 수 있는가? 정의할 수 있다면, 이렇게 정의한 클래스에는 어떤 제약이 있을까?
    - 자신을 둘러싼 코드 블록 안에서만 쓰일 수 있다.
    - 지역 클래스에는 가시성 변경자를 붙일 수 없다.
    - 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획할 수 있지만, 공유되는 값을 패러 객체로 둘러싸기 위한 비용이 발생한다.
7. 지연 초기화 메커니즘의 요지는 무엇인가? 널이 될 수 있는 프로퍼티 대신 lateinit 프로퍼티를 사용할 경우 어떤 장점이 있는가?
    - 어떠한 프로퍼티를 초기화 하는 시점을 지연시킨다. 
    - null 이 아닌 타입을 사용할 수 있기 때문에 타입 안정성이 생긴다.
8. 커스텀 프로퍼티 접근자란 무엇인가? 코틀린 접근자와 게터/세터를 비교하라.
    - 프로퍼티 값을 읽거나 쓸 때 호출되는 특별한 함수 
    - 인스턴스의 프로퍼티를 읽으면 자동으로 게터를 호출한다. 
    - 인스턴스의 프로퍼티에 값을 쓰면 자동으로 세터를 호출한다.
9. 클래스를 사용하는 클라이언트 입장에서 볼 때 실질적으로 val 과 같은 역할을 하는 읽기 전용 프로퍼티를 val 을 쓰지 않고 만들 수 있는가?
반대로 쓸수만 있는 프로퍼티는 어떻게 만들 수 있을까?
    - 커스텀한 getter, setter 를 프로퍼티에 정의한다. 
    - 읽기 전용으로 사용한다면 private set 으로 변경이 불가능하게 만들 수 있다.
10. lazy 프로퍼티를 사용해 지연 계산을 달성하는 방법은 무엇인가? lazy 와 lateinit 프로퍼티를 비교해보라.
    - 값 변경 가능여부 
      - lateinit: 가능(var 사용)
      - by lazy: 불가능(val 사용)
    - 용법 구분
      - lateinit: 초기화 이후에 계속하여 값이 바뀔 수 있을 때
      - by lazy: 초기화 이후에 읽기 전용 값으로 사용할 때
11. 객체 선언이란 무엇인가? 코틀린 객체와 자바에서 일반적인 싱글턴 구현 패턴을 비교하라.
    - 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 생성을 동시에 처리해준다.
    - 자바로 싱글턴을 구현할 경우 static block 에서 객체 하나를 생성해 놓고 이를 활용하는 형태로 사용
    - 코틀린에서는 object 라는 키워드를 사용해서 싱글턴 패턴을 구현 할 수 있다.
12. 클래스와 비교할 때 객체 선언은 어떤 제약이 있는가?
    - 주/부 생성자를 사용할 수 없다.(객체 선언과 동시에 생성자 호출 없이 바로 만들어지기 때문)
    - 객체의 본문에 들어있는 클래스에는 inner 가 붙을 수 없다.(객체 선언은 항상 인스턴스가 하나뿐이므로 inner 변경자가 불필요해진다.)
    - 객체의 모든 멤버가 필요할 때 임포트 문으로 임포트 할 수 없다.
      - 객체 정의 안에는 다른 클래스 정의와 같이 toString(), equals() 와 같은 공통 메서드 정의가 들어있기 때문이다.
      - 이로 인해 필요시 임포트를 사용하면 이런 공통 메서드까지 임포트돼 문제가 생길 수 있다.
13. 일반 객체와 동반 객체의 차이는 무엇인가?
    - 동반 객체는 companion 이라는 키워드를 덧붙인 내포된 객체다.
    - 동반 객체의 멤버에 접근할 때는 동반 객체의 이름을 사용하지 않고 동반 객체가 들어있는 외부 클래스의 이름을 사용할 수 있다.
14. 코틀린 동반 객체와 자바의 static 내포 객체를 비교하라.
    - 코틀린 동반 객체의 문맥은 객체 인스턴스라는 차이점이 있다.
    - 이로 인해 자바의 정적 클래스 보다 코틀린 동박 객체가 더 유연하다. 코틀린 동반 객체는 다른 상위 타입을 상속할 수도 있고, 일반 객체처럼 여기저기에 전달될 수 있기 때문이다.
    - 자바의 static 초기화 블록처럼 동반 객체 안에서도 init 블록을 사용할 수 있다.
15. 자바의 익명 클래스에 해당하는 코틀린 기능은 무엇인가? 이런 코틀린 언어의 기능을 어떻게 사용할 수 있을까?
    - 객체 식은 명시적인 선언 없이 객체를 바로 생성할 수 있는 특별한 식이다. 자바 익명 클래스와 아주 비슷하다.
    - 클래스나 객체 식과 달리 객체를 함수 안에 정의할 수 없다.
      - 객체 선언이 싱글턴을 표현하지만 지역 객체들은 자신을 둘러싼 바깥 함수가 호출될 때마다 매번 다시 생성되야 하기 때문이다.
    - 익명 객체 타입은 지역 선언이나 비공개 선언에만 전달될 수 있다.
    - 객체 식은 클래스 상속과 조합했을 때 강력해진다?
    - 객체 식은 기존 클래스의 하위 클래스를 선언하지 않고도 기존 클래스를 약간만 변경해 기술하는 간결한 방법을 제공한다.