# 9장 정리 문제

1. 코틀린에서 제네릭 클래스, 함수, 프로퍼티를 정의하는 방법은 무엇인가?

    - 클래스 이름 뒤에 선언 
    - 타입 파라미터를 fun 이나 val/var 바로 뒤에 위치 시킨다.
    - 클래스 멤버 프로퍼티는 타입 파라미터를 가질 수 없고, 오직 확장 프로퍼티만 타입 파라미터를 가질수 없다.
    - 코틀린에서는 로타입 사용 불가

2. 타입 파라미터에 대해 제약을 거는 방법을 설명하라. 자바와 코틀린 타입 파라미터 제약 기능을 비교해 설명하라.

    - 타입 파라미터에 상위 바운드가 있으면, 컴파일러는 이 타입 파라미터에 공급된 타입 인자의 타입이 상위 바운드의 하위 타입인지 검사한다.
    - 타입 파라미터 바운드로 타입 파라미터를 사용할 수도 있으며, 이런 경우를 재귀적 타입 파라미터라고 말한다.
    - 바운드가 자신보다 앞에 있는 타입 파라미터를 가리킬 수도 있다.
    - 자바에서는 T extends Number 로 표현하지만 코틀린에서는 T: Number 로 표현한다.
    - 코틀린에서는 where 절을 클래스 선언 본문 앞에 추가하고 바운드할 타입 목록을 표시할 수 있다.
    - 자바에서는 클래스 선언지점에는 변성을 지정할 수 없다.

3. 타입 소거란 무엇인가? 타입 파라미터의 한계를 일반 타입과 비교해 설명하라.

    - 제네릭스가 자바 5부터 도입되었는데 새 버전 자바 컴파일러와 가상 머신은 기존 코드와의 하위 호환성을 위해 기존 타입 표현 방식을 유지해야 했다.
    - 그 결과 JVM 에서 타입 인자에 대한 정보는 코드에서 지워지고, 소스코드에서 List\<String> 이나 List\<Number> 와 같은 타입은 JVM 에서 List 라는 동일한 타입으로 합쳐진다.
    - 런타임에 제네릭 코드는 파라미터 타입의 차이를 인식할 수 없다.
    - 자바는 선언지점 변성을 사용할 수 없다.
      - class SomeClazz<? extends T> { .. } 와 같은 표현이 불가능하다는 이야기
    - as 는 사용 가능하지만 is 는 사용할 수 없다.
      - **런타임에 타입 파라미터 T 를 is 로 판별해야 한다면 LSP 를 위반하는게 아닌지 잘 생각해보자.**
      - **바운드 제약을 잘 걸자!**

4. 구체화한 타입 파라미터를 사용해 어떻게 타입 소거를 우회할 수 있는가? 구체화한 타입 파라미터의 한계는 무엇인가?

    - 인라인 함수에 대해서만 구체화한 타입 파라미터를 쓸 수 있다.
    - 함수 본문을 호출 위치로 인라인시키기 때문에 컴파일러가 인라인된 함수에 제공되는 타입 인자의 실제 타입을 항상 알 수 있다.
    - 파라미터를 구체화하려면 reified 키워드로 해당 타입 파라미터를 지정해야 한다.
    - 인라인 함수는 재귀 함수일 수는 없다.
    - 인라인 함수를 사용하면 컴파일된 코드의 크기가 커지는 경향이 있다는 점을 조심해야 한다.
    - 인라인 함수 안에서만 구체화한 타입 파라미터를 쓸 수 있기 때문에 구체화한 타입을 클래스나 프로퍼티와 함께 쓸 수는 없다.
    - 구체화한 타입 파라미터를 통해 생성자를 호출하거나 동반 객체 멤버에 접근할 수 없다.
      - 인라인이 복사 될때 생성자로서의 T 는 복사해주지 않는다.
      - T 를 꾸미기는 복사해주지 않는다.(T(), T.xxx())
      - T 를 단순히 타입으로 치환만 해준다.
    - 구체화한 타입 파라미터를 구체화하지 않은 타입 파라미터로 대신할 수는 없다.
      - 인라인 체인이 깨지는 경우 대신할 수 없다.
    - **추상 팩토리 메소드 패턴을 공부해보자?**

5. 변성이란 무엇인가? 제네릭 코드에서 변성이 중요한 이유는 무엇인가?

    - 변성은 타입 파라미터가 달라질 때 제네릭 타입의 하위 타입 관계가 어떻게 달라지는지를 설명하는 제네릭 타입의 한 측면이다.
    - 변성을 합리적으로 사용하면 타입 안전성을 해치지 않으면서 API 유연성을 향상시킬 수 있다.
    - 변성이 중요한 이유는?
      - **대표타입<내부타입> 일때 내부 타입의 제약을 걸 수 있다.**
      - 다른 대표타입의 내부타입을 내가(대표타입) 사용할 수 있다.
        - ~~~kotlin
          a = Array<Int>
          b = Array<Number>
          a.xx(b)
          ~~~
      - 즉, **변성이란 제네릭끼리 교류를 하려는데 내부타입의 교환이나 참조가 일어날 때 문제를 일으키므로 미리 가이드를 정하는 것이다.** 

6. 코틀린에서 선언 지점 변성을 어떻게 사용하는지 설명하라.

    - 타입 파라미터의 변성을 선언 자체에 지정하는 방식
    - 어떤 타입 파라미터가 항상 out 위치에서 쓰이는 경우에만 이 타입 파라미터를 공변적으로 선언할 수 있다.
    - out 위치는 기본적으로 값을 만들어내는 위치다.
    - 프로퍼티나 함수의 반환값 타입이나 제네릭 타입의 공변적인 타입 파라미터 위치가 out 위치다.
    - in 위치는 값을 함수 인자나 제네릭 타입의 반공변 타입 인자로 소비하는 경우를 뜻한다.

7. 코틀린 사용 지점 변성과 자바 와일드카드를 비교해 설명하라.

    - 선언 지점은 무공변으로 사용하고 사용 지점에서 in/out 을 사용해서 생산자/소비자를 지정한다.
      - 선언지점에 in/out 을 지정해서 모든 메소드를 다 사용하는 경우는 드물다. 그래서 사용 지점 변성을 사용한다.
    - 함수뿐만 아니라 변수 선언 시에도 사용할 수 있다.

8. 스타 프로젝션의 목적이 무엇인지 설명하라.

    - 타입 인자가 중요하지 않거나 알려져 있지 않은 제네릭 타입을 간결하게 표현 할 수 있다.
    - 변수 선언시는 \<Any?> 와 같고, 사용 시는 \<Nothing> 과 같다.
    - out Any? 대신 * 를 쓰는 이유는?
      - 이게 더 효율적이다. 

9. 타입 별명 구문을 설명하라. 임포트 별명이나 상속과 같은(기존 타입 이름에 대한 새로운 타입 이름을 소개하는)언어 기능과 타입 별명을 비교하라.

    - typealias 키워드로 이뤄지며, 그다음에 별명이 오고 = 기호 다음에 실제 타입이 온다.
    - 임포트 별명의 영역은 항상 임포트 디렉티브가 포함된 파일 안으로 제한되지만, 공개 타입 별명은 더 넓은 영역에 쓰일 수 있다.
    - 전처리기이기 때문에 런타임에 영향을 미치는 모든 곳에는 사용할 수 없다.
