# 5장 정리 문제

1. 고차 함수란 무엇인가?
   - 람다를 인자로 받거나 반환하는 함수

2. 람다 식의 문법을 설명하라. 자바 람다와 코틀린 람다를 비교하라.
   - 문법 
      - 중괄호로 감싼다. { .. }
      - 인자와 본문은 ->로 구분한다.
      - 인자는 ()로 감싸지 않는다.
      - 인자는 형식추론이 가능하므로 타입을 생략할 수 있다.
      - 변수에 람다식을 담는경우에는 인자의 타입을 생략할 수 없다.
      - 함수 호출 시 맨 마지막 인자가 람다식이면 이를 괄호 밖으로 빼낼 수 있다.
      - 람다가 어떤 함수의 유일한 인자인 경우, 함수 호출 괄호를 없애도 된다.
      - 람다의 파라미터가 하나뿐이고, 그 타입을 컴파일러가 추론할 수 있는 경우 it 을 바로 쓸 수 있다.
   - 자바 람다와 차이점
     - 자바에서는 람다가 함수 내부에서 실행될 때, 로컬 변수에 접근하기 위해서는 해당 변수의 값이 final 이어야만 한다.
       - 이는 stack 영역에 로컬 변수의 메모리가 잡히고, 함수의 소멸과 함께 stack 에서 날아가기 때문이다.
       - final 인 경우 해당 변수값을 복사해서 람다 내부에서 사용하며, 이를 lambda capturing 이라고 한다.
     - 코틀린에서는 final 변수의 경우 똑같이 복사하여 람다 코드와 함께 저장된다.
        - 다만 final 이 아닌 변수의 경우 특별한 wrapper class 에 변수로 담고, 그 wrapper 를 final 변수에 담아 이 변수의 참조값을 람다 코드와 함께 저장한다.
        - 따라서 람다에서 해당 변수에 항상 접근하여 읽고 쓰기가 가능해진다.

3. 함수 타입이란 무엇인가? 코틀린 함수 타입과 자바 함수형 인터페이스의 차이점은 무엇인가?
   - 함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이다.
   - 자바 8부터는 SAM 인터페이스를 문맥에 따라 적절히 함수 타입처럼 취급하기 때문에 람다식이나 메서드 참조로 SAM 인터페이스를 인스턴스화 할 수 있다.
   - 하지만 코틀린에서 함숫값은 항상 (P1, ..., Pn) -> R 형태의 함수 타입에 속하기 때문에 임의의 SAM 인터페이스로 암시적으로 변환할 수 없다.
   - 코틀린 1.4부터는 코틀린 인터페이스 앞에 fun 을 붙이면 코틀린 인터페이스를 SAM 인터페이스로 취급하고, 이 기능을 사용하면 코틀린 인터페이스를 람다로 인스턴스화할 수 있다.

4. 수신 객체가 있는 함수 타입과 수신 객체가 없는 함수 타입을 비교해 설명하라.
   - 클래스 멤버나 확장 선언을 바탕으로 수신 객체가 있는 함숫값을 정의하는 호출 가능 참조를 만들 수 있다.
   - 문법적으로 바인딩된 호출 가능 참조와 비슷하지만, 수신 객체를 계산하는 식 대신 수신 객체 타입이 앞에 붙는다는 점이 다르다.
   - 수신 객체가 없는 호출 가능 참조를 수신 객체가 필요한 함수 타입의 값 대신 사용할 수도 있다.
   - 수신 객체가 아닌 일반 함수 타입의 파라미터를 받는 함수에 수신 객체가 지정된 호출 가능 참조를 전달할 수도 있다.
   - 클래스 멤버인 동시에 확장 함수로 정의된 함수에 대한 호출 가능 참조는 지원하지 않는다. 이런 함수의 경우 타입::함수 이름 형태로는 여러 수신 객체 타입을 지정할 방법이 없기 때문이다.

5. 람다와 익명 함수의 차이는 무엇인가? 람다를 쓰는 것보다 익명 함수를 쓰는 것이 더 좋은 때는 언제인가?
   - 람다식에선 return, break, continue 와 같은 제어문을 사용하기 어렵다.
   - 람다가 인라인될 경우에는 인라인된 코드를 둘러싸고 있는 함수에서 반환할 때 return 문을 사용할 수 있다.
     - 하지만 인라인을 한 이후 람다에서 사용하는 return 문이 고차 함수를 호출하는 쪽의 함수를 반환시킬수는 없다.
     - 인라인을 했음에도 불구하고 람다의 return 과 람다를 실행해주는 함수가 서로 다른 실행 스택 프레임을 차지하기 때문이다.
   - 함수내 조건에 따라 실행을 중단하고 리턴해야 하는 경우에는 익명함수를 사용하는게 좋을거 같다.

6. 인라인 함수의 장단점을 설명하라. 인라인 함수에는 어떤 제약이 있는가?
   - 고차 함수나 함숫값을 사용하면 함수가 객체로 표현되기 때문에 성능 차원에서 부가 비용이 발생한다.
   - 익명 함수나 람다가 외부 영역의 변수를 참조하면 고차 함수에 함숫값을 넘길 때 마다 이런 외부 영역의 변수를 포획할 수 있는 구조도 만들어서 넘겨야 한다.
   - 함숫값을 호출할 때는 컴파일러가 함숫값의 정적인 타입을 알 수 없기 때문에 동적으로 가상 호출을 사용해 어떤 함수 구현을 사용할지 디스패치해야 한다.
   - 코틀린은 함숫값을 사용할 때 발생하는 런타임 비용을 줄일 수 있는 해법으로 인라인(inline) 기법을 제공한다.
   - 코틀린 버전 1.1 부터는 프로퍼티 접근자를 인라인하도록 허용한다.
   - 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워지기 때문에 제네릭 함수의 본문에서 타입 인자를 쓸 수 없다.
     - 이런 제약을 피하기 위해 함수를 inline 함수로 만들고 타입 파라미터를 reified 로 지정하면 타입 인자를 사용 할 수 있다.
   - 인라인 함수 제약 사항
     - 인라인 함수를 쓰면 컴파일된 코드의 크기가 커지기 때문에, 인라인 함수의 크기를 적절하게 조절해야 한다.
     - 인라인 함수는 실행 시점에 별도의 존재가 아니므로 변수에 저장되거나 인라인 함수가 아닌 함수에 전달될 수 없다.
     - 인라인이 될 수 있는 람다를 사용해 할 수 있는 일은 람다를 호출하거나 다른 인라인 함수에 인라인이 되도록 넘기는 두 가지 경우뿐이다.

7. 호출 가능 참조란 무엇인가? 호출 가능 참조의 여러 가지 형태를 설명하라. 각각의 형태를 자바의 메서드 참조와 비교하라.
   - 함수를 가리키는 참조를 만들려면 함수 이름 앞에 :: 을 붙이면 된다.
   - :: 을 클래스 이름 앞에 적용하면 클래스의 생성자에 대한 호출 가능 참조를 얻는다.
   - 코틀린 1.1 부터는 바인딩된 호출 가능 참조라는 :: 사용법이 도입됐다.
     - 주어진 클래스 인스턴스의 문맥 안에서 멤버 함수를 호출하고 싶을 때는 바인딩된 호출 가능 참조를 사용한다.
   - 수신 객체가 있는 함숫값을 정의하는 호출 가능 참조를 만들 수 있다.
     - 클래스 멤버나 확장 선언을 바탕으로 이런 참조를 만들 수 있다.
   - 코틀린 프로퍼티에 대한 호출 가능 참조를 만들 수도 있다.
   - 자바와 차이점
     - 코틀린의 호출 가능 참조는 일급 시민 식이지만, 자바 메서드 참조는 함수형 인터페이스 내에서만 의미가 있다.
     - 즉. 자바의 메서드 참조에는 정해진 타입이 없다.

8. 람다와 익명 함수 안에서 return 이 어떻게 작동하는지 설명하라. 한정시킨 return 문이랑 무엇인가?
   - 6번 참고

9. 함수 타입 파라미터의 디폴트 인라인 모드와 noinline, crosssinline 모드를 서로 비교하라.
   - 디폴트 인라인 모드는?...
   - 어떤 함수에 인라인할 수 있는 파라미터가 없다면 이 함수를 호출한 지점을 함수 본문으로 대치해도 런타임에 크게 이득이 없으므로,
   보통 이런 함수는 인라인할 만한 가치가 없는 것으로 여겨지고, 코틀린 컴파일러는 이런 함수에 대해 경고릂 표시한다.
   - 특정 람다를 인라인하지 말라고 파라미터 앞에 noinline 변경자를 붙일 수 있다.
   - crossinline 변경자를 붙이면 함숫값을 인라인시키도록 남겨두는 대신 람다 안에서 비지역 return 을 사용하지 못하게 막는 역할을 한다.
     - 인라인을 한 이후 람다에서 사용하는 return 문이 고차 함수를 호출하는 쪽의 함수를 반환시킬 수 없는 경우 사용

10. 확장 함수를 정의하는 방법은 무엇인가? 확장 함수는 확장이 적용된 함수를 변경하는가?
    - 확장 함수는 어떤 클래스의 멤버인 것처럼 호출할 수 있는 함수를 뜻한다.
    - 함수를 호출할 때 사용할 수신 객체의 클래스 이름을 먼저 표시하고, 점을 추가한 다음에 함수 이름을 표시한다.
    - 확장 함수는 클래스가 아닌 타입에 정의하는 것이다. 그래서 nullable 또는 구체적인 제네릭 타입에도 확장 함수를 정의할 수 있으며, 확장이 적용된 함수를 변경하지도 않는다. 
    - 확장 함수는 근본적으로(특정 클래스 타입의 객체를 첫번째 인자로 받는)일반 함수를 마치 클래스 멤버인 것처럼 쓸 수 있게 해주는 편의 문법일 뿐이다. 
      - 확장 함수는 클래스 타입을 기준으로 항상 정적으로 함수가 결정되기 때문에 자바에서는 static 메서드로 컴파일 된다. 

11. 동반 객체 확장을 사용하는 방법을 설명하라.
    - 동반 객체가 존재하는 경우에만 동반 객체에 대한 확장을 정의할 수 있다.
    - Any 에는 동반 객체가 존재하지 않으므로 Any 의 동반 객체에 대한 확장을 정의할 수는 없다.

12. 확장 프로퍼티에는 어떤 제약이 있는가?
    - 확장 프로퍼티를 정의하려면 프로퍼티 이름 앞에 수신 객체의 타입을 지정하면 된다.
    - 멤버와 확장 프로퍼티의 결정적인 차이는 어떤 클래스의 인스턴스에 안정적으로 상태를 추가할 방법이 없기 때문에 확장 프로퍼티에 뒷받침하는 필드를 쓸 수 없다는 점이다.
    - 이 말은 확장 프로퍼티를 초기화할 수도 없고, 접근자 안에서 field 를 사용할 수도 없다는 뜻이다.
    - 그리고 lateinit 으로 확장 프로퍼티를 정의할 수도 없다. lateinit 은 뒷받침하는 필드에 의존하는 기능이기 때문이다.
    - 하지만 위임은 사용할 수 있다. 다만 위임식이 프로퍼티의 수신 객체에 접근 할 수 없다.
    - 마찬가지 이유로 확장 프로퍼티 정의에서는 항상 명시적인 게터를 정의해야 하고, 가변 프로퍼티인 경우에는 세터도 명시해야 한다.

13. 여러 가지 형태의 this 식을 설명하라. 한정시킨 this 를 언제 어떻게 사용하는가?
    - 클래스 안에서 확장 함수나 프로퍼티를 선언하면 일반적인 멤버나 최상위 확장과 달리 이런 함수나 프로퍼티에는 수신 객체가 두 개 있다.
    - 이때 확장 정의의 수신 객체 타입의 인스턴스를 확장 수신 객체(extension receiver)라 부르고, 확장이 포함된 클래스 타입의 인스턴스를 디스패치 수신 객체(dispatch receiver)라 부른다.
    - 두 수신 객체를 가리킬 때는 this 앞에 클래스 이름이나 확장 이름을 붙여서 한정시킨다.
    - 일반적으로 한정시키지 않은 this 는 this 를 가장 가깝게 둘러싸는 선언의 수신 객체를 잠조한다.
    - 따라서 지역적인 클래스나 수신 객체 지정 람다 또는 내포된 확장 함수 선언이 있지 않는 한, 일반적으로 this 는 this 가 속한 확장 함수의 확장 수신 객체가 된다.
    - **수신 객체의 영역을 자신이 포함된 선언 내부로 제한하는 쪽을 더 권장한다.**

14. 클래스 내부에서 확장 함수를 선언하는 경우 주의해야 할 점을 설명하라.
    - 레퍼런스를 지원하지 않는다. 
    - 암묵적 접근을 할 때, 두 리시버 중에 어떤 리시버가 선택될지 혼동된다.
    - 확장 함수가 외부에 있는 다른 클래스를 리시버로 받을 때, 해당 함수가 어떤 동작을 하는지 명확하지 않다.

15. 영역 함수란 무엇인가? 어떤 일을 처리할 때 어떤 영역 함수를 사용할지 판단하는 기준이 무엇인지 설명하라.
    - run 과 with 함수
      - run() 함수는 확장 람다를 받는 확장 함수이며 람다의 결과를 돌려준다.
      - **기본적인 사용 패턴은 객체 상태를 설정한 다음, 이 객체를 대상으로 어떤 결과를 만들어내는 람다를 호출하는 것이다.**
      - with() 함수는 run() 과 상당히 비슷하다. 유일한 차이는 with()가 확장 함수 타입이 아니므로 문맥 식을 with 의 첫 번째 인자로 전달해야 한다는 점뿐이다.
          - **이 함수를 일반적으로 사용하는 경우는 문맥 식의 멤버 함수와 프로퍼티에 대한 호출을 묶어 동일한 영역 내에서 실행하는 경우다.**
    - 문맥이 없는 run
        - 이 함수는 문맥 식이 없고 람다의 값을 반환하기만 한다. 람다 자체에는 수신 객체도 없고 파라미터도 없다.
        - **주로 이 함수를 사용하는 경우는 어떤 식이 필요한 부분에서 블록을 사용하는 것이다.**
            - 어떠한 인스턴스만을 처리하기 위한 영역을 따로 만들 때 사용 할 수 있다.
        - run 은 인라인 함수이므로 람다 내부에서 바깥쪽 함수의 제어를 반환시키기 위해 return 을 사용해도 된다.
            - 그냥 블록을 사용하면 블록을 람다로 취급하기 때문에 제대로 작동하지 않는다.
    - let 함수
        - let 함수는 run 과 비슷하지만 확장 함수 타입의 람다를 받지 않고 인자가 하나뿐인 함수 타입의 람다를 받는다는 점이 다르다.
        - 따라서 문맥 식의 값은 람다의 인자로 전달된다.
        - 외부 영역에 새로운 변수를 도입하는 일을 피하고 싶을 때 주로 이 함수를 사용한다.
        - **널이 될 수 있는 값을 안전성 검사를 거쳐서 널이 될 수 없는 함수에 전달할 때 사용한다.**
        - **연산을 아규먼트 처리 후로 이동시킬 때 사용한다.**
    - apply/also 함수
        - apply() 함수는 확장 람다를 받는 확장 함수이며 자신의 수신 객체를 반환한다.
        - **이 함수는 일반적으로 run() 과 달리 반환값을 만들어내지 않고 객체의 상태를 설정하는 경우에 사용한다.**
        - **also()함수는 apply() 와 달리 인자가 하나 있는 람다를 파라미터로 받는다.**