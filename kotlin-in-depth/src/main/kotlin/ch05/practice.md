# 5장 정리 문제

1. 고차 함수란 무엇인가?
   - 람다를 인자로 받거나 반환하는 함수

2. 람다 식의 문법을 설명하라. 자바 람다와 코틀린 람다를 비교하라.
   - 문법 
      - 중괄호로 감싼다. { .. }
      - 인자와 본문은 ->로 구분한다.
      - 인자는 ()로 감싸지 않는다.
      - 인자는 형식추론이 가능하므로 타입을 생략할 수 있다.
      - 변수에 람다식을 담는경우에는 인자의 타입을 생략할 수 없다.
      - 함수 호출 시 맨 마지막 인자가 람다식이면 이를 괄호 밖으로 빼낼 수 있다.
      - 람다가 어떤 함수의 유일한 인자인 경우, 함수 호출 괄호를 없애도 된다.
      - 람다의 파라미터가 하나뿐이고, 그 타입을 컴파일러가 추론할 수 있는 경우 it 을 바로 쓸 수 있다.
   - 자바 람다와 차이점
     - 자바에서는 람다가 함수 내부에서 실행될 때, 로컬 변수에 접근하기 위해서는 해당 변수의 값이 final 이어야만 한다.
       - 이는 stack 영역에 로컬 변수의 메모리가 잡히고, 함수의 소멸과 함께 stack 에서 날아가기 때문이다.
       - final 인 경우 해당 변수값을 복사해서 람다 내부에서 사용하며, 이를 lambda capturing 이라고 한다.
     - 코틀린에서는 final 변수의 경우 똑같이 복사하여 람다 코드와 함께 저장된다.
        - 다만 final 이 아닌 변수의 경우 특별한 wrapper class 에 변수로 담고, 그 wrapper 를 final 변수에 담아 이 변수의 참조값을 람다 코드와 함께 저장한다.
        - 따라서 람다에서 해당 변수에 항상 접근하여 읽고 쓰기가 가능해진다.

3. 함수 타입이란 무엇인가? 코틀린 함수 타입과 자바 함수형 인터페이스의 차이점은 무엇인가?
   - 함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이다.
   - 자바 8부터는 SAM 인터페이스를 문맥에 따라 적절히 함수 타입처럼 취급하기 때문에 람다식이나 메서드 참조로 SAM 인터페이스를 인스턴스화 할 수 있다.
   - 하지만 코틀린에서 함숫값은 항상 (P1, ..., Pn) -> R 형태의 함수 타입에 속하기 때문에 임의의 SAM 인터페이스로 암시적으로 변환할 수 없다.
   - 코틀린 1.4부터는 코틀린 인터페이스 앞에 fun 을 붙이면 코틀린 인터페이스를 SAM 인터페이스로 취급하고, 이 기능을 사용하면 코틀린 인터페이스를 람다로 인스턴스화할 수 있다.

4. 수신 객체가 있는 함수 타입과 수신 객체가 없는 함수 타입을 비교해 설명하라.
   - 클래스 멤버나 확장 선언을 바탕으로 수신 객체가 있는 함숫값을 정의하는 호출 가능 참조를 만들 수 있다.
   - 문법적으로 바인딩된 호출 가능 참조와 비슷하지만, 수신 객체를 계산하는 식 대신 수신 객체 타입이 앞에 붙는다는 점이 다르다.
   - 수신 객체가 없는 호출 가능 참조를 수신 객체가 필요한 함수 타입의 값 대신 사용할 수도 있다.
   - 수신 객체가 아닌 일반 함수 타입의 파라미터를 받는 함수에 수신 객체가 지정된 호출 가능 참조를 전달할 수도 있다.
   - 클래스 멤버인 동시에 확장 함수로 정의된 함수에 대한 호출 가능 참조는 지원하지 않는다. 이런 함수의 경우 타입::함수 이름 형태로는 여러 수신 객체 타입을 지정할 방법이 없기 때문이다.

5. 람다와 익명 함수의 차이는 무엇인가? 람다를 쓰는 것보다 익명 함수를 쓰는 것이 더 좋은 때는 언제인가?
   - 람다식에선 return, break, continue 와 같은 제어문을 사용하기 어렵다.
   - 람다가 인라인될 경우에는 인라인된 코드를 둘러싸고 있는 함수에서 반환할 때 return 문을 사용할 수 있다.
     - 하지만 인라인을 한 이후 람다에서 사용하는 return 문이 고차 함수를 호출하는 쪽의 함수를 반환시킬수는 없다.
     - 인라인을 했음에도 불구하고 람다의 return 과 람다를 실행해주는 함수가 서로 다른 실행 스택 프레임을 차지하기 때문이다.
   - 함수내 조건에 따라 실행을 중단하고 리턴해야 하는 경우에는 익명함수를 사용하는게 좋을거 같다.

6. 인라인 함수의 장단점을 설명하라. 인라인 함수에는 어떤 제약이 있는가?
   - 고차 함수나 함숫값을 사용하면 함수가 객체로 표현되기 때문에 성능 차원에서 부가 비용이 발생한다.
   - 익명 함수나 람다가 외부 영역의 변수를 참조하면 고차 함수에 함숫값을 넘길 때 마다 이런 외부 영역의 변수를 포획할 수 있는 구조도 만들어서 넘겨야 한다.
   - 함숫값을 호출할 때는 컴파일러가 함숫값의 정적인 타입을 알 수 없기 때문에 동적으로 가상 호출을 사용해 어떤 함수 구현을 사용할지 디스패치해야 한다.
   - 코틀린은 함숫값을 사용할 때 발생하는 런타임 비용을 줄일 수 있는 해법으로 인라인(inline) 기법을 제공한다.
   - 코틀린 버전 1.1 부터는 프로퍼티 접근자를 인라인하도록 허용한다.
   - 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워지기 때문에 제네릭 함수의 본문에서 타입 인자를 쓸 수 없다.
     - 이런 제약을 피하기 위해 함수를 inline 함수로 만들고 타입 파라미터를 reified 로 지정하면 타입 인자를 사용 할 수 있다.
   - 인라인 함수 제약 사항
     - 인라인 함수를 쓰면 컴파일된 코드의 크기가 커지기 때문에, 인라인 함수의 크기를 적절하게 조절해야 한다.
     - 인라인 함수는 실행 시점에 별도의 존재가 아니므로 변수에 저장되거나 인라인 함수가 아닌 함수에 전달될 수 없다.
     - 인라인이 될 수 있는 람다를 사용해 할 수 있는 일은 람다를 호출하거나 다른 인라인 함수에 인라인이 되도록 넘기는 두 가지 경우뿐이다.

7. 호출 가능 참조란 무엇인가? 호출 가능 참조의 여러 가지 형태를 설명하라. 각각의 형태를 자바의 메서드 참조와 비교하라.
8. 람다와 익명 함수 안에서 return 이 어떻게 작동하는지 설명하라. 한정시킨 return 문이랑 무엇인가?
9. 함수 타입 파라미터의 디폴트 인라인 모드와 noinline, crosssinline 모드를 서로 비교하라.
10. 확장 함수를 정의하는 방법은 무엇인가? 확장 함수는 확장이 적용된 함수를 변경하는가?
11. 동반 객체 확장을 사용하는 방법을 설명하라.
12. 확장 프로퍼티에는 어떤 제약이 있는가?
13. 여러 가지 형태의 this 식을 설명하라. 한정시킨 this 를 언제 어떻게 사용하는가?
14. 클래스 내부에서 확장 함수를 선언하는 경우 주의해야 할 점을 설명하라.
15. 영역 함수란 무엇인가? 어떤 일을 처리할 때 어떤 영역 함수를 사용할지 판단하는 기준이 무엇인지 설명하라.