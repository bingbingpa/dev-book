# 7장 정리 문제

1. 코틀린 컬렉션 타입의 개요를 설명하라. 자바 컬렉션 라이브러리와 코틀린 컬렉션 라이브러리의 가장 중요한 차이는 무엇인가?

    - 코틀린 컬렉션 타입은 기본적으로 네 가지로 분류 할 수 있다. 배열, 이터러블, 시퀀스, 맵
    - 배열: 미리 정해진 숫자만큼 같은 타입의 원소를 모아서 저장하고 각각을 인덱스로 참조할 수 있게 해준다.
    - 이터러블: Iterable<T> 타입으로 표현되며, 일반적으로 즉시 계산되는 상태가 있는 컬렉션을 표현한다.
    - 시퀀스
      - 이터러블과 비슷하게 시퀀스도 iterator() 메서드를 제공한다.
      - 하지만 시퀀스는 지연 계산을 가정하기 때문에 iterator() 의 의도가 이터러블과 다르다.
      - 대부분의 시퀀스 구현은 객체 초기화 시 원소를 초기화하지 않고 요청에 따라 원소를 계산한다.
      - 대부분의 시퀀스 구현은 상태가 없다. 이 말은 지연 계산한 컬렉션 원소 중에 정해진 개수의 원소만 저장한다는 뜻이다.
      - 반면 이터러블은 원소 개수에 비례해 메모리를 사용한다.
    - 맵: 키와 값 쌍으로 이뤄진 집합. 여기서 키는 유일해야 한다.
    - 자바 컬렉션 vs 코틀린 컬렉션
      - 코틀린 Iterator 타입은 remove() 가 없다. 이 메서드는 MutableIterator 로 옮겨졌다.
      - kotlin.collections 패키지에 있는 별명을 통해 ArrayList 등과 같은 대부분의 표준 컬렉션을 쓸 수 있다.

2. 컬렉션 타입이 제공하는 기본 연산은 무엇인가?

    - 이터레이션
      - Iterator 객체를 사용해 컬렉션 원소를 순회할 수는 있지만, 코틀린이 더 간결한 방법을 제공하므로 이터레이터를 사용하는 경우는 드물다.
      - iterator() 함수가 있다는 사실은 모든 컬렉션에 대해 for 루프를 쓸 수 있다는 뜻이다.
      - 원소 인덱스를 참조해야 한다면 forEachIndexed() 함수를 쓰면 된다.
    - size 프로퍼티는 원소 개수를 돌려준다.
    - isEmpty() 함수는 컬렉션에 원소가 없는지 검사한다.
    - contains() / containsAll() 함수는 인자로 지정한 워소나 인자로 지정한 컬렉션의 모든 원소가 수신 객체 컬렉션에 들어있는지 검사한다.
      - contains() 함수 호출을 in 연산자로 대신할 수 있다.

3. 컬렉션 원소를 이터레이션하는 여러 가지 방법을 설명하라.

   - for 루프
   - forEach(): 컬렉션의 각 워소를 제공하면서 인자로 받은 람다를 실행해준다.
   - forEachIndexed(): 원소 인덱스를 참조하면서 순회

4. 컬렉션 원소에 접근할 때 쓸 수 있는 공통 함수를 나열하고 설명하라.

   - first() / last(): 각각 주어진 컬렉션의 첫 번째와 마지막 원소를 반환
     - firstOrNull()/lastOrNull() 도 있다.
   - single(): 싱글턴 컬렉션의 원소를 반환. 컬렉션이 비어있거나 원소가 두 개 이상이면 예외
     - singleOrNull() 은 동일한 경우 예외 대신 널을 반환
   - elementAt(): 인덱스를 사용해 컬렉션 원소를 읽을 수 있다.
     - 이 함수를 임의 접근 컬렉션이 아닌 컬렉션에 사용하면 인덱스 값에 비례한 실행 시간인 걸린다는 점을 유의해야 한다.
   - 배열이나 리스트에 대한 구조 분해를 통해 앞에서부터 최대 다섯 개의 원소를 추출할 수 있다.

5. 코틀린 라이브러리가 제공하는 공통 집계 함수를 설명하라.

   - count(): 컬렉션의 원소 개수를 반환
     - 컬렉션 원소에 대한 술어를 적용하는 오버로딩된 버전이 있다. 이경우 주어진 조건을 만족하는 원소의 개수를 반환
   - sum(): 수로 이뤄진 배열, 이터러블, 시퀀스의 산술 합계를 구한다.
     - sumOf(): 원소 타입을 수로 변환할 수만 있다면 어떤 타입의 원소로 이뤄진 컬렉션에 대해서 합계를 구할 수 있다.
   - average(): 수로 이뤄진 배열, 이터러블, 시퀀스의 산술 평균을 구한다.
     - 컬렉션이 비어있으면 average() 함수는 항상 Double.NaN 을 반환
   - minOrNull()/maxOrNull(): 비교 가능한 타입의 값이 들어있는 배열, 이터러블, 시퀀스의 최솟값과 최댓값을 계산한다.
     - min()/max() 는 코틀린 1.4부터 금치 처리됐다.
     - minByOrNull()/maxByOrNull(): 비교할 수 없는 원소들로 이뤄진 컬렉션의 최댓값/최솟값을 구할 수도 있다.
     - minWithOrNull()/maxWithOrNull(): 변환 함수 대신 비교기를 받는다.
   - joinToString(): 컬렉션 원소를 문자렬로 엮는다.
   - reduce()
     - 파라미터가 두 개인 함수를 받는다.
     - 첫 번째 인자는 누적된 값이고, 두 번째 인자는 컬렉션의 현재 값이다.
     - 집계 과정
       - 누적값은 최초에 컬렉션의 첫 번째 원소로 초기화된다.
       - 컬렉션의 매 원소에(두 번째 원소부터) 현재 누적값과 현재 원소를 파라미터로 받은 함수에 적용하고 이 함수 적용의 결과를 누적값에 대입한다.
       - 누적의 결과를 반환한다.
     - 컬렉션이 비어 있으면 누적값을 초기화 할 수 없으므로 reduce() 함수는 예외를 던진다.
     - 집계 규칙이 원소의 인덱스에 따라 달라진다면 reduceIndexed() 를 사용할 수 있다.
       - 이 함수는 현재 인덱스를 집계 연산의 첫 번째 파라미터로 전달해준다.
   - fold()
     - 누적의 초깃값을 원하는 대로 지정하고 싶을 때 사용
     - 프로그래머가 항상 누적값의 초깃값을 지정하기 때문에 리스트가 비어있어도 fold() 는 reduce() 와 달리 예외를 발생시키지 않는다.
   - reduce()/reduceIndexed()/fold()/foldIndexed() 함수에 대해 컬렉션의 마지막 원소부터 반대 방향으로 계산을 수행해주는 함수도 있다.
     - 배열이나 리스트의 맨 뒤(오른쪽)부터 처리한다는 사실을 알려주기 위해 이런 함수의 이름 뒤에는 Right 가 붙는다.

6. fold() 와 reduce() 연산을 설명하라.

   - 5번에 설명

7. all() / any() / none() 함수의 목적은 무엇인가?

   - 컬렉션에 대한 조건 검사를 목적으로 한다.
   - all() 함수는 컬렉션의 모든 원소가 주어진 술어를 만족하면 true 를 반환한다.
   - none() 함수는 all() 과 반대다. 컬렉션에 주어진 조건을 만족하는 원소가 하나도 없을 때 true 를 반환한다.
   - any() 함수는 컬렉션 원소 중 적어도 하나가 주어진 술어를 만족할 때 true 를 반환한다.
   - 빈 컬렉션의 경우 all() 과 none() 함수는 true 를, any() 함수는 false 를 반환한다.
   - any() 와 none() 함수에는 파라미터를 전혀 받지 않은 오버로딩된 버전이 있다. 이런 함수들은 단순히 컬렉션 객체가 비어있는지만 검사한다.

8. 컬렉션의 걸러내기 함수를 설명하라.

   - 컬렉션에서 조건을 만족하지 못하는 원소를 걸러내 버리고, 원하는 원소만 남긴다.
     - 걸러내기 연산은 워본 컬렉션을 변경하지 않는다.
     - 대신 전혀 새로운 컬렉션을 만들거나 원본 컬렉션과 구별되는 기본 가변 컬렉션에 선택된 원소를 추가한다.
   - 가장 기본적인 걸러내기 연산은 filter() 함수에 의해 제공된다.
   - 맵에서 키나 값으로만 걸러내고 싶다면 filterKeys, filterValues 를 사용할 수 있다.
   - filterNot() 함수는 조건을 부정해 걸러낼 수 있게 해준다.
   - filterIsInstance() 는 원소 중 특정 타입만 남기는 경우 사용
   - 위의 걸러내기 함수들은 호출될 때마다 새로운 불변 컬렉션을 만든다.
   - 걸러낸 결과를 이미 존재하는 가변 컬렉션에 집어 넣고 싶다면 To 로 끝나는 함수를 사용하자.
      - filterTo(), filterNotNullTo(), filterNotTo() ...
   - 주어진 술어를 만족하는 부분 컬렉션과 만족하지 않는 부분 컬렉션의 쌍으로 만들어주는 partition() 함수가 있다.
      - 맵은 partition() 을 제공하지 않는다.

9. 하위 컬렉션을 추출하는 방법을 설명하라.

    - 배열 원소를 다른 배열로 추출하고 싶다면 sliceArray() 를 써야 한다.
    - take() 와 takeLast() 함수는 이터러블이나 배열에서 원소를 주어진 개수만큼 추출한다.
        - take() 는 맨 앞에서부터, takeLast() 맨 뒤에서부터 개수를 센다.
    - drop() / dropLast() 함수는 take() / takeLast() 를 반전시킨 연산이라고 볼 수 있다. 이들은 주어진 개수만큼 원소를 제거한 나머지 원소들을 돌려준다.
    - 코틀린 1.2 에 추가된 chunked() 함수를 사용하면 이터러블이나 시퀀스를 주어진 개수를 넘지 않는 작은 리스트들로 나눠준다.
    - 코틀린 1.2 에 도입된 windowed() 함수를 사용하면 일정한 간격으로 청크를 연속적으로 얻어낸 슬라이딩 윈도우를 얻을 수 있다.
        - 슬라이딩 윈도우를 생성하는 규칙을 정하는 선택적인 파라미터를 지정할 수도 있다.
        - step: 서로 인접한 윈도우의 첫 번째 워소 사이의 거리(디폴트 1)
        - partialWindows: 컬렉션의 마지막 부분에서 지정한 윈도우 크기보다 작은 크기의 윈도우를 포함시킬지 여부(디폴트는 false)
    - zipWithNext(): 윈소가 두 개뿐인 윈도우를 만든다. windowed() 와 달리 리스트가 아니라 쌍(Pair)의 시퀀스나 리스트를 만들어 낸다.

10. 컬렉션에 적용할 수 있는 표준 변환 함수들을 설명하라. 매핑(예: map 등), 평평하게 하기(예: flatten 등), 연관 짓기(예: associateBy 등)를 설명하라.

    - map() 함수를 맵에 적용 할 수도 있다.
      - 추가로 키와 값만 변환한 새 맵을 돌려주는 mapKeys() 와 mapValues() 함수도 있다.
    - flatMap(): 원래 컬렉션의 각 원소를 컬렉션으로 변환한 다음, 각 컬렉션을 차례로 이어 붙여서 한 컬렉션으로 합쳐준다.
    - flatten(): 원소가 컬렉션인 모든 컬렉션에 적용할 수 있고 각각의 컬렉션을 이어 붙인 한 컬렉션을 내놓는다.
    - 주어진 변환 함수를 바탕으로 원본 컬렉션 원소를 맵의 키나 맵의 값으로 만들 수 있는 변환
        - associateWith(): 원래 컬렉션을 키의 근원으로 사용해 새로운 맵을 만들어 준다.(배열에는 적용할 수 없다.)
        - associateBy(): 컬렉션 원소를 값으로 취급하고 변환 함수를 통해 키를 얻는다. 어떤 키에 대해 같은 값이 여럿 존재하는 경우, 오직 한 값만 반환되는 맵에 남는다.
        - associate(): 컬렉션의 원소를 사용해서 키와 값을 만들어낸다.

11. 코틀린 표준 라이브러리가 제공하는 컬렉션 순서 지정 및 정렬 유틸리티를 설명하라.

    - sorted(): 원소 타입이 비교 가능한 배월/이터러벌/시퀀스에 적용할 수 있고 원소들의 자연스러운 순서에 따라 오름차순으로 원소를 정렬
    - sortedDescending(): 내림차순으로 원소를 정렬
    - 배열의 경우는 sortedArray()/sortedArrayDescending() 이라는 함수가 있다.
    - reversed(): 원본 컬렉션의 원소를 역순으로 나열한 새 리스트를 반환
      - 배열의 경우 reversedArray()
    - reverse(): 새 컬렉션을 만들지 않고 제자리에서 가변 리스트나 배열의 원소 순서를 뒤집는다.

12. 스트림 생성과 변환 유틸리티를 설명하라.
    
    - bufferedReaders()/bufferedWriter(): 지정한 File 객체에 대해 BufferedReader/BufferedWriter 인스턴스를 만들 수 있다.
    - reader()/writer(): 버퍼가 없는 FileReader/FileWriter 객체를 만든다.
    - printWriter(): 형식화된 출력에 적합한 PrintWriter 인스턴스를 만든다.
    - 리더/라이터 관련 함수를 사용할 때는 선택적으로 인코딩 문자 집합을 지정할 수도 있다(디폴트는 UTF-8)
    - InputStream.reader(), InputStream.bufferedReader(), InputStream.buffered()
      - 일반적인 InputStream 클래스의 인스턴스를 바탕으로 Reader, BufferedReader, BufferedInputStream 객체를 만들 수 있다.
    - OutputStream 을 Writer, BufferedWriter, BufferedOutputStream 에 연결할 때 사용할 수 있는 함수도 있다.
      - writer(), bufferedWriter(), buffered()
      - Reader 와 Writer 에 대해 정의된 buffered() 함수도 있다.

13. 파일이나 I/O 스트림의 콘텐츠에 접근하기 위해 사용할 수 있는 함수를 나열하고 설명하라.

    - Reader.readText(), Reader.readLines()
      - BufferedReader 클래스에 있는 readLine() 은 스트림에서 한 줄을 가져오지만, 두 함수는 스트림 끝까지 콘텐츠를 읽어서 전체를 한 문자열이나 각 줄을 나타내는 문자열의 리스트로 반환한다.
    - readText() 와 달리 readLines() 함수는 값을 반환하면서 스트림을 닫아준다.
    - forEachLine() 과 userLines() 함수는 줄 단위 이터레이션을 허용하고, 스트림을 자동으로 닫기 때문에 스트림을 닫는 일을 신경 쓰지 않아도 된다.

14. 파일 시스템 유틸리티 함수를 설명하라.

    - deleteRecursively()
      - 파일이나 디렉터리를 자신에게 포함된 자손들까지 포함해 쉽게 지울 수 있다.
      - 삭제가 성공하면 true, 그렇지 않으면 false 를 반환
      - 자바의 mkdirs() 메서드와 비슷하다.
    - copyTo()
        - 자신의 수신 객체를 다른 파일에 복사하고 복사본을 가리키는 파일 객체를 돌려준다.
        - 디폴트로 대상 파일을 덮어 쓰지는 않는다. 따라서 대상 파일이 이미 존재하는 경우 FileAlreadyExistsException 을 발생시킨다.
        - overwirte 파라미터를 지정할 수도 있다.
        - 디렉터리에 적용할 수도 있다. 하지만 디렉터리의 경우 하위 디렉터리나 디렉터리에 들어있는 파일을 복사하지는 않고 대상 경로에 맞춰 빈 디렉터리만 만들어 준다.
            - 디렉터리와 내용물을 모두 복사하고 싶다면 copyRecursively() 함수를 사용해야 한다.
    - copyRecursively()
        - copyTo() 와 마찬가지로 overwrite 파라미터를 통해 덮어 쓸지 여부를 정해줄 수 있다.
        - 어떤 파일을 복사하다가 IOException 이 발생하면 호출할 액션을 설정할 수도 있다.
            - 선택적인 OnError 파라미터를 통해 (File, IOException) -> OnErrorAction 타입의 람다를 넘기면 된다.
            - 람다의 결과값은 문제가 되는 파일을 어떻게 처리할지를 결정한다.
                - SKIP: 파일을 무시하고 복사를 계속 진행
                - TERMINATE: 복사를 중단.
    - walk()
        - 깊이 우선 디렉터리 구조 순회를 구현한다.
        - TOP_DOWN: 자식보다 부모를 먼저 방문(디폴트 값)
        - BOTTOM_UP: 자식을 부모보다 먼저 방문
        - walk() 대신 walkTopDown() 또는 walkBottomUp() 을 명시적으로 쓸 수도 있다.
    - onEnter() 와 onLeave() 함수는 순회가 디렉터리에 들어가거나 디렉터리에서 나올 때 호출할 동작을 지정한다.
    - createTempFile() / createTempDir() 함수를 사용해 임시 파일이나 디렉터리를 만들 수 있다.
        - createTempFile() 과 createTempDir() 은 사용 금지 예고 처리됐으며, 각각 kotlin.io.path 패키지에 있는 createTempFile() 과 crateTempDirectory() 로 대치될 예정이다.