# 13장 정리 문제

1. 일시 중단 함수란 무엇인가? 일시 중단 함수의 동작과 일반적인 함수의 동작이 어떻게 다른가?

    - 함수 본문의 원하는 지점에서 함수에 필요한 모든 런타임 문맥을 저장하고 함수 실행을 중단한 다음, 나중에 필요할 때 다시 실행을 계속 진행할 수 있게 한다.
      - 코틀린에서는 이런 함수에 `suspend` 라는 변경자를 붙인다.
      - 런타임 문맥이란 실행하는 함수의 지역변수 등을 모두 저장하는 것을 말한다.
    - 일반 함수 호출은 함수 실행이 다 끝난 뒤 호출한 함수로 제어가 돌아온다.

2. launch() 와 async() 빌더로 코루틴을 만드는 방법은 무엇인가? launch() 와 async() 의 차이는 무엇인가?

    - 코틀린 빌더는 CoroutineScope 인스턴의 확장함수로 쓰인다.
      - GlobalScope 객체를 사용해서 독립적인 코루틴을 만든다.
      - CoroutineScope.() -> Unit 타입의 일시 중단 람다를 받는다.
    - launch()
      - 코루틴을 시작하고, 코루틴을 실행 중인 작업의 상태를 추적하고 변경할 수 있는 Job 객체를 돌려준다.
      - 예외를 부모 코루틴에게 전달한다.
    - async()
      - Deferred 의 인스턴스를 돌려주고, 이 인스턴스는 Job 의 하위 타입으로 await() 메서드를 통해 계산 결과에 접근할 수 있게 해준다.
      - await() 는 계산이 완료되거나 계산 작업이 취소될 때까지 현재 코루틴을 일시 중단시킨다.
      - 던져진 예외를 저장했다가 예외가 발생한 계산에 대한 await() 호출을 받았을 때 다시 던진다.

3. runBlocking() 빌더의 목적을 설명하라.

   - runBlocking() 은 블러킹 호출과 넌블러킹 호출 사이의 다리 역할을 하기 위해 고안된 코루틴 빌더이므로,
     테스트나 메인 함수에서 최상위 빌더로 사용되는 경우에만 runBlocking() 을 써야 한다.
   - runBlocking() 빌더는 디폴트로 현재 스레드에서 실행되는 코루틴을 만들고 코루틴이 완료될 때까지 현재 스레드의 실행을 블럭시킨다.

4. 구조적 동시성이란 무엇인가?

   - 코루틴이 어떤 연산을 수행하는 도중에만 실행될 필요가 있는 경우, 동시성 작업 사이의 부모 자식 관계로 인해 이런 실행 시간 제한이 가능하다.
   - **어떤 코루틴을 다른 코루틴의 문맥에서 실행하면 후자가 전자의 부모가 된다.**
   - 이 경우 자식의 실행이 모두 끝나야 부모가 끝날 수 있도록 부모와 자식의 생명 주기가 연관된다.
   - coroutineScope() 호출로 코드 블럭을 감싸면 커스텀 영역을 도입할 수도 있다.
      - coroutineScope() 와 runBlocking() 의 가장 큰 차이는 coroutineScope() 가 일시 중단 함수라 현재 스레드를 블럭시키지 않는다는 점이다.

5. 동시성 잡의 생명 주기를 설명하라. 코루틴 트리에서 잡 취소가 어떻게 전파되는지 설명하라.

   - 잡은 동시성 작업의 생명 주기를 표현하는 객체다. 잡을 사용하면 작업 상태를 추적하고 필요할 때 작업을 취소할 수 있다.
   - CoroutineStart.DEFAULT: 디플트 동작이며, 잡을 즉시 시작한다.
   - CoroutineStart.LAZY: 잡을 자동으로 시작하지 말라는 뜻이다. 이 경우에는 잡이 신규 상태가 되고 시작을 기다리게 된다.
   - 잡의 cancel() 메서드를 호출하면 잡을 취소할 수 있다.
     - 이 메서드는 더 이상 필요 없는 계산을 중단시킬 수 있는 표준적인 방법을 제공한다.
     - isActive 확장 프로퍼티는 현재 잡이 활성화된 상태인지 검사한다.
     - 부모 코루틴이 취소되면 자동으로 모든 자식의 실행을 취소한다. 이 과정은 부모에게 속한 모든 잡 계층이 취소될 때까지 계속된다.

6. 코루틴 디스패처란 무엇인가? 코루틴 라이브러리가 제공하는 공통적인 디스패처 구현을 설명하라.

   - 코루틴 라이브러리에는 특정 코루틴을 실행할 때 사용할 스레드를 제어하는 작업을 담당하는 특별한 컴포넌트가 있는데 이를 `코루틴 디스패처(dispatcher)`라고 부른다.
   - 디스패처는 코루틴 문맥의 일부다. 따라서 launch() 나 runBlocking() 등의 코루틴 빌더 함수에서 이를 지정할 수 있다.
   - 디스패처는 그 자체로 원소가 하나뿐인 문맥이기도 하므로, 코루틴 빌더에 디스패처를 넘길 수 있다.
   - 코루틴 라이브러리에서 제공하는 디스패처 구현
      - Dispatchers.Default
         - 공유 스레드 풀로, 풀 크기는 디폴트로 사용 가능한 CPU 코어 수이거나 2다(둘 중 큰 값).
         - 이 구현은 일반적으로 작업 성능이 주로 CPU 속도에 의해 결정되는 CPU 위주의 작업에 적합하다.
      - Dispatchers.IO
         - 파일을 읽고 쓰는 것처럼 잠재적으로 블러킹될 수 있는 I/O 를 많이 사용하는 작업에 최적화돼 있다.
         - 이 디스패처는 스레드 풀을 디폴트 구현과 함께 공유하지만, 필요에 따라 스레드를 추가하거나 종료시켜 준다.
      - Dispatchers.Main
         - 사용자 입력이 처리되는 UI 스레드에서만 베타적으로 작동하는 디스패처

7. 코루틴 내부에서 디스패처를 바꾸는 방법은 무엇인가?

   - 명시적으로 문맥을 전달받아서, withContext() 함수를 사용해 디스패처를 오버라이드 한다?

8. 코루틴 라이브러리가 사용하는 예외 처리 메커니즘을 설명하라. CoroutineExceptionHandler 의 역할은 무엇인가?

   - 코루틴 빌더들은 두 가지 기본 전략 중 하나를 따른다.
   - 첫번째
      - launch() 같은 빌더가 선택한 전략으로, 예외를 부모 코루틴에게 전달한다. 이 경우 예외는 다음과 같이 전파된다.
         - 부모 코루틴이(자식에게서 발생한 오류) 똑같은 오류로 취소된다. 이로 인해 부모의 나머지 자식도 모두 취소된다.
         - 자식들이 모두 취소되고 나면 부모는 예외를 코루틴 트리의 윗부분으로 전달한다.
         - 전역 영역에 있는 코루틴에 도달할 때까지 이 과정이 반복된다.
         - 그 후 예외가 CoroutineExceptionHandler.Consider 에 의해 저리된다.
            - CoroutineExceptionHandler 는 전역 영역에서 실행된 코루틴에 대해서만 정의할 수 있고, CoroutineExceptionHandler 가 정의된 코루틴의 자식에 대해서만 적용된다.
   - 두번째
      - async() 빌더에서 사용하는 방법으로, 던져진 예외를 저장했다가 예외가 발생한 계산에 대한 await() 호출을 받았을 때 다시 던지는 것이다.

9. 슈퍼바이저 잡이란 무엇인가? 내포된 코루틴에서 발생한 예외를 처리할 때 어떻게 슈퍼바이저 잡을 활용할 수 있는가?

   - 내포된 코루틴에서 발생한 예외를 전역 핸들러를 통하지 않고 부모 수준에서 처리하고 싶을 때는 `슈퍼바이저(supervisor) 잡`을 사용해야 한다.
     - 슈퍼바이저 잡이 있으면 취소가 아래 방향으로만 전달된다.
     - 슈퍼바이저를 취소하면 슈퍼바이저 잡은 자동으로 자신의 모든 자식을 취소한다.
     - 하지만 슈퍼바이저가 아니라 자식이 취소된 경우, 슈퍼바이저나 슈퍼바이저의 다른 자식들은 아무 영향을 받지 않는다.

10. 채널이란 무엇인가? 코루틴 라이브러리가 지원하는 채널에는 어떤 종류가 있는가?

    - 채널은 임의의 데이터 스트림을 코루틴 사이에 공유할 수 있는 방법이다.
    - Channel.UNLIMITED(= Int.MAX_VALUE)
      - 채널의 용량은 제한이 없고, 내부 버퍼는 필요에 따라 증가한다.
      - 이런 채널은 send() 시에 결코 중단되는 일이 없다. 다만 receive() 를 하는 버퍼가 비어있으면 일시 중단될 수 있다.
    - Channel.RENDEZVOUS(= 0)
       - 이 경우 채널은 아무 내부 버퍼가 없는 랑데부 채널이 된다.
       - send() 호출은 다른 어떤 코루틴이 receive() 를 호출할 때까지 항상 일시 중단된다.
       - 마찬가지로 receive() 호출은 다른 어떤 코루틴이 send() 를 호출할 때까지 일시 중단된다.
       - **채널 생성시 용량을 지정하지 않으면 이 방식의 채널이 생성된다.**
    - Channel.CONFLATED(= -1)
       - 이 경우에는 송신된 값이 합쳐지는 채널이다.
       - 이 말은 send() 로 보낸 원소를 최대 하나만 버퍼에 저장하고 이 값이 누군가에 의해 수신되기 전에 다른 send() 요청이 오면 기존 값을 덮어 쓴다는 뜻이다.
       - 따라서 수신되지 못한 원소 값은 소실된다.
       - 이 채널의 경우 send() 메서드는 결코 일시 중단되지 않는다.
    - Channel.UNLIMITED 보다 작은 임의의 양수를 지정하면 버퍼 크기가 일정하게 제한된 채널이 생긴다.
    - 랑데부 채널은 생산자와 소비자 코루틴이 교대로 활성화되도록 보장한다.

11. produce() 함수를 사용해 채널을 만드는 방법은 무엇인가?

    - `produce()` 라는 코루틴 빌더를 사용하면 컬렉션의 sequence() 함수와 비슷하게 동시성 데이터 스트림을 생성할 수 있다.
      - 이 빌더는 채널과 비슷한 send() 메서드를 제공하는 `ProducerScope` 영역을 도입해준다.
      - 이 경우 채널을 명시적으로 닫을 필요가 없다. 코루틴이 종료되면 produce() 빌더가 채널을 자동으로 닫아준다.

12. 티커 채널의 동작을 설명하라.

    - 이 채널은 Unit 값을 계속 발생시키되 한 원소와 다음 원소의 발생 시점이 주어진 지연 시간만큼 떨어져 있는 스트림을 만든다.
    - 티커는 리시브 채널을 반환한다.

13. 액터 모델의 기본 개념을 설명하라. 액터를 코루틴 동시성 라이브러리에서 활용하는 방법은 무엇인가?

    - 가변 상태를 스레드 안전하게 공유하는 방법을 구현하는 일반적인 방법으로 액터(actor)모델이 있다.
    - 액터는 내부 상태와 다른 액터에게 메시지를 보내서 동시성 통신을 진행할 수 있는 수단을 제공하는 객체다.
    - 액터는 자신에게 들어오는 메시지를 리슨하고, 자신의 상태를 바꾸면서 메시지에 응답할 수 있으며, 다른 메시지를(자기 자신이나 다른 액터에게)
      보낼 수 있고, 새로운 액터를 시작할 수 있다.
    - **액터의 상태는 액터 내부에 감춰져 있으므로 다른 액터가 직접 이 상태에 접근할 수 없다. 다른 액터는 단지 메시지를 보내고 응답을 받아서 상태를 알 수 있을 뿐이다.**
    - 액터는 특별한 영역(ActorScope)을 만들며, 이 영역은 기본 코루틴 영역에 자신에게 들어오는 메시지에 접근할 수 있는 수신자 채널이 추가된 것이다.

14. 코틀린 표준 라이브러리가 제공하는 스레드 생성 유틸리티 함수를 설명하라.

    - thread() 함수
      - start: 스레드를 생성하자마자 시작할지 여부(디폴트는 true)
      - isDaemon: 스레드를 데몬 모드로 시작할지 여부(디폴트는 false). 데몬 스레드는 JVM 의 종료를 방해하지 않고 메인 스레드가 종료될 때 자동으로 함께 종료된다.
      - contextClassLoader: 스레드 코드가 클래스와 자원을 적재할 때 사용할 클래스 로더(디폴트는 널)
      - name: 커스텀 스레드 이름. 디폴트는 널인데, 이는 JVM 이 이름을 자동으로 지정한다는 뜻이다
      - priority: Thread.MIN_PRIORITY(=1) 부터 Thread.MAX_PRIORITY(=10) 사이의 값으로 정해지는 우선순위로, 어떤 스레드가 다른 스레드에 비해 얼마나 많은
        CPU 시간을 배정받는지 결정한다. 디폴트 값은 -1 이며, 이 값은 자동으로 우선순위를 정하라는 뜻이다.
      - block: () -> Unit 타입의 함숫값으로 새 스레드가 생성되면 실행할 코드다.
    - timer(): 어떤 작업을 이전 작업이 끝난 시점을 기준으로 고정된 시간 간격으로 실행하는 타이머를 설정한다.

15. 코틀린 코드에서 스레드 간의 동기화와 락을 어떻게 사용하는지 설명하라.

    - @Synchronized 애너테이션을 붙인다.
    - Lock 객체를 사용해 주어진 람다를 실행하게 해주는 withLock() 함수를 사용
    - ReentrantReadWriteLock 의 읽기와 쓰기 락을 사용해 주어진 작업을 수행하는 read() 와 write() 함수 사용
    - 코틀린에서는 [mutex](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/) 를 사용한다.
      - suspend 내에서만 쓸 수 있다.