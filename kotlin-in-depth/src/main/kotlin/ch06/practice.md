# 6장 정리 문제

1. 이넘 클래스란 무엇인가? 이넘 클래스에는 어떤 내장된 연산들이 있는가?

    - 이넘 클래스는 미리 정의된 상수들로 이뤄진 제한된 집합을 표현하는 특별한 클래스다.
    - 코틀린의 모든 이넘 클래스는 암시적으로 kotlin.Enum 클래스의 하위 타입이다.
      - 모든 이넘 값에는 ordinal 과 name 이라는 한 쌍의 프로퍼티가 들어있다.
      - ordinal 은 이넘 클래스 안에 정의된 이넘 값의 순서에 따른 인덱스이고, name 은 이넘 값의 이름이다.
      - 특정 이넘 클래스의 값을 이넘 본문에 있는 정의의 위치에 따라 서로 비교할 수 있다.
      - 자바와 코틀린의 이넘이 모두 Comparable 인터페이스를 암시적으로 구현하기는 하지만, 자바에서는 이넘 값에 대해 < 나 > 등의 연산을 적용할 수 없다.
      - valueOf(): 이넘 값의 이름을 문자열로 넘기면 그에 해당하는 이넘 값을 돌려주거나 이름이 잘못된 경우 예외를 던진다.
      - values(): 정의된 순서대로 모든 이넘 값이 들어있는 배열을 돌려준다.
      - **이 메서드를 호출할 때마다 배열이 새로 생긴다는 점에 유의하라.**
      - 따라서 이 메서드에서 얻은 배열의 내용을 바꾸더라도 나머지 배열에는 영향이 없다.
      - 코틀린 1.1 부터는 values() 나 valueOf() 대신에 제네릭 최상위 메서드인 enumValues() 와 enumValueOf() 를 사용할 수도 있다.

2. when 식에서 이넘 클래스를 사용하는 경우를 자세히 설명하라.

    - 이넘 변수를 각각의 값과 비교할 수 있다.
    - when 식에서 모든 이넘 상수를 다룬 경우에는 else 브랜치를 생략해도 된다. 
    - 빠뜨린 부분이 없는 형태의 when 식을 사용하면, 새 이넘 값을 추가하는 경우에 깨질 수 있는 코드가 생기는 일을 방지 할 수 있다.
      - 사용하지 않는 이넘이 있으면 컴파일 시점에 컴파일러가 when 에 빠뜨린 부분이 있다고 경고하기 때문에 이런 오류를 쉽게 방지할 수 있다.

3. 커스텀 함수나 프로퍼티가 있는 이넘 클래스를 어떻게 정의하는가?
    - 함수, 프로퍼티, 주생성자와 부생성자, 초기화 블록, 내부 클래스/내포된 클래스, 객체(동반 내포 객체와 일반 내포 객체)등이 포함된다.
    - 이넘 클래스에 정의된 이런 요소들은 반드시 이넘 상수 목록 뒤에 와야 한다. 이런 경우에는 상수 목록과 다른 부분을 구분하기 위해 상수 목록을 세미콜론으로 끝내야 한다.
    - 모든 이넘 클래스 상수에서 이넘 클래스의 본문에 정의된 멤버를 사용할 수 있다.

4. 데이터 클래스란 무엇인가? 데이터 클래스에 대해 컴파일러가 자동으로 생성해주는 연산(함수)은 어떤 것이 있는가? 어떻게 데이터 클래스의 인스턴스를 복사할 수 있는가?

    - toString: 클래스의 이름과 기본 생성자 형태로 모든 프로퍼티와 값을 출력해준다. 로그 출력할 때나 디버그할 때 유용하다.
    - equals: 기본 생성자의 프로퍼티가 같은지 확인해 준다. 그리고 hashCode 는 equals 와 같은 결과를 나타낸다.
    - copy
      - immutable 데이터 클래스를 만들 때 편리하다.
      - copy 는 기본 생성자 프로퍼티가 같은 새로운 객체를 복제한다. 새로 만들어진 객체의 값은 이름있는 아규먼트를 활용해서 변경할 수 있다.
        ~~~kotlin
        val newObj = player.copy(name = "Thor")
        print(newObj) // Player(id=0, name=Thor, points=9999)
        ~~~
      - copy 메서드는 객체를 얕은 복사하지만, 이것은 객체가 immutable 이라면 상관이 없다. immutable 객체는 깊은 복사한 객체가 필요 없기 때문이다.
    - componentN
      - 위치를 기반으로 객체를 해제할 수 있게 해준다.
        ~~~kotlin
        val player = Player(0, "Gecko", 9999)
        val id: Int = player.component1()
        val name: String = player.component2()
        val pts = player.component3()
        ~~~
      - componentN 함수만 있다면, List 와 Map.Entry 등의 원하는 형태로도 객체를 해제할 수 있다.

5. 구조 분해 선언이란 무엇인가? 어떤 용도로 구조 분해 선언을 사용할 수 있는가?
    - 각각의 프로퍼티에 대응하는 지역 변수를 정의하는 좀 더 간결한 구문 

6. 인라인 클래스의 목적은 무엇인가? 어떤 클래스를 인라인으로 선언하기 위해 필요한 요구 사항은 무엇인가?

    - 일반적인 워시 타입의 값과 마찬가지로 부가 비용 없이 값 클래스를 사용하기 위해 사용한다.
    - 인라인 클래스의 주생성자에는 불변 프로퍼티를 하나만 선언해야 한다.
    - 인라인 클래스의 프로퍼티는 상태를 포함할 수 없다. 현재 코틀린 컴파일러는 오직 한 프로퍼티만 인라인하도록 지원하기 때문이다.
    - 초기화 블록을 쓸 수 없다. 인라인 클래스는 런타임에 어떠한 커스텀 코드도 실행할 수 없다.

7. 코틀린의 부호 없는 타입과 이런 타입이 제공하는 내장 연산에 대해 설명하라. 부호가 있는 정수와 비교할 때 부호가 없는 정수 타입의 특징은 무엇인가?

    - +,-,*,/,% 연산자 사용 가능 
    - 부호가 있는 값과 달리, 부호가 없는 정수의 단항 부호 반전(-) 연산자를 지원하지 않는다.
    - 부호가 없는 값에 대해 증가, 감소, 복합 대입 연산자를 쓸 수 있다.
    - 비트 반전, AND, OR, XOR 과 같은 기본적인 비트 연산 지원
      - 이때 비트 수를 UInt 가 아니라 일반적인 Int 타입의 값으로 지정한다는 점의 유의하자.
      - 부호 없는 오른쪽 시프트 연산인 ushr 을 별도로 제공하지 않는다.
    - <,>,<=,>=,==,!= 연산 사용 가능