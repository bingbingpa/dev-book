# 코틀린 완벽 가이드 *입문부터 활용까지, 필요한 지식 총망라!*
- *알렉세이 세두노프 저/오현석 역 | 길벗*

<br>

## 1장. 강력하고 실용적인 코틀린 

- [awesome kotlin 웹사이트(https://kotlin.link/)](https://kotlin.link/)

## 3장. 함수 정의하기

### 3.1 함수

- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
- 파라미터 앞에 val 이나 var 를 표시할 수 없다.
- **코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다.**
  - 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다.
  - 하지만 파라미터가 참조(예) 배열)라면 호출한 쪽의 데이터는 그대로 남아 있고 이 데이터에 대한 참조만 복사된다.
  - 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.
    - 예를 들어 정수 배열을 가리키는 (불변)참조를 받아서 첫 번째 원소를 변경하면, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
- 위치 기반 인자와 이름 붙은 인자
  - 코틀린 1.4 이전에는 이름 붙은 인자를 쓰기 시작하면 그 이후의 모든 인자에 이름을 붙여야 했다.
  - **1.4 부터는 이름 붙은 인자를 중간에 섞어 쓸 수 있다.**
  - 다만 이 경우에는 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리 된다.
    - 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.
- 오버로딩과 디폴트 값
  - 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다.
- vararg
  - 스프레드(spread) 연산자인 * 를 사용하면 배열을 가변 인자 대신 넘길수 있다.
  - **스프레드는 배열을 복사한다는 점의 유의하자. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.**
  - 하지만 이때 얕은(shallow)복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
  - 둘 이상을 vararg 파라미터로 선언하는 것은 금지 된다.
  - vararg 파라미터가 맨 마지막에 있는 파라미터가 아니라면, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.
    - **디폴트 값과 비슷하게 vararg 파라미터도 목록의 맨 뒤에 위치시키는 것이 좋은 코딩 스타일이다.**
  - vararg 파라미터를 이름 붙은 인자로 전달할 수는 없다. 
    - ~~~kotlin
      printSorted(items = 1, 2, 3) // error
      printSorted(items = *intArrayOf(1, 2, 3)) // ok
      ~~~
- 함수의 영역과 가시성
  - internal 변경자를 적용하면 함수가 적용된 모듈 내부에서만 함수를 사용할 수 있게 제한한다.
  - 코틀린에서 모듈은 기본적으로 함께 컴파일되는 파일 전부를 뜻한다.

### 3.3 조건문

- if 문을 식으로 사용할때는 양 가지가 모두 있어야 한다.(if/else 모두)
- Nothing 타입은 모든 코틀린 타입의 하위 타입으로 간주되기 때문에 식이 필요한 위치에 return 을 사용해도 타입 오류가 발생하지 않는다.
- 범위, 진행, 연산
  - 수 타입, Char, Boolean, String 등 모든 비교 가능한(comparable) 타입에 대해 .. 연산을 쓸 수 있다.
  - 기본적으로 <= 와 >= 를 쓸 수 있는 타입이라면 이 타입에 대해 .. 를 사용해 범위를 만들 수 있다.
  - **.. 연산에 의해 만들어지는 범위는 닫혀 있다. 즉, 시작 값과 끝 값이 범위에 포함된다.**
  - until 은 끝값은 범위에 포함되지 않는다.
  - 내장 범위 연산에서 끝 값이 시작 값보다 확실히 더 작으면 빈 범위가 된다. 
    - ~~~kotlin
      println(5 in 10..1) // false
      ~~~
  - 진행: 정해진 간격(step)만큼 떨어져 있는 정수나 Char 값들로 이뤄진 시퀀스
    - 정수나 Char 에 대해 정의된 범위는 실제로는 간격이 1인 진행이라 할 수 있다.
    - downTo: 아래로 내려가는(descending)진행을 만들 수 있다.
    - step: 진행의 간격을 지정(진행의 간격은 양수여야 한다.) 
      - ~~~kotlin
        1..10 step 3 // 1, 4, 7, 10
        15 downTo 9 step 2 // 15, 13, 11, 9
        ~~~
  - 범위를 사용하면 문자열이나 배열의 일부분을 뽑아 낼 수 있다.
    - ~~~kotlin
      "Hello, World".substring(1..4) // ello
      IntArray(10) { it*it }.sliceArray(2..5) // 4, 9, ,16, 25
      ~~~
  - 우선순위로 보면 범위 연산인 .. 는 덧셈과 중위 연산 사이에 속하며, in 과 !in 연산은 중위와 비교 연산 사이에 속한다.
- when
  - 코틀린 1.3 부터는 다음과 같이 식의 대상을 변수에 연결 할 수 있다. 이때 정의한 변수는 when 블록 내부에서만 사용할 수 있고 var 로 선언할 수는 없다.
    - ~~~kotlin
      fun readHexDigit() = when(val n = readLine()!!.toInt()) {
          in 0..9 -> '0' + n
          in 10..15 -> 'A' + n - 10
          else -> '?'
      }
      ~~~

### 3.4 루프

- 문자열과 배열에는 원소나 문자의 인덱스 범위를 제공하는 indices 라는 프로퍼티가 들어있다.
- break: 즉시 루프를 종료시키고, 실행 흐름이 루프 바로 다음 문으로 이동하게 만든다.
- continue: 현재 루프 이터레이션(iteration)을 마치고 조건 검사로 바로 진행하게 만든다.
- **코틀린에서는 함수에 tailrec 을 붙이면 컴파일러가 재귀 함수를 비재귀적인 코드로 자동으로 변환해준다.**

## 4장 클래스와 객체 다루기

### 4.1 클래스 정의하기 

- 클래스에 주생성자를 선언하지 않은 경우, 모든 부생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 init 블록을 실행한다. 
  - 이렇게 하면 어떤 부생성자를 호출하든지 공통적인 초기화 코드가 정확히 한 번만 실행되게 보장할 수 있다.
- 생성자 파라미터 목록 뒤에 콜론(:)을 넣고 그 뒤에 일반 함수를 호출하는 것처럼 코드를 작성하되, 함수 이름 대신 this 를 사용하면 생성자 위임 호출이 된다.
- 부생성자의 파라미터 목록에는 val/var 키워드를 쓸 수 없다.
- 코틀린에는 자바의 패키지 전용에 해당하는 가시성이 없다.
- 주생성자의 가시성을 지정하려면 constructor 키워드를 꼭 명시해야 한다.
  - ~~~kotlin
    class Person private constructor(val test: String)
    ~~~
- 내포된 클래스(nested class)
  - 내포된 클래스는 내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.
  - **자바와 달리, 바깥쪽 클래스는 자신에게 내포된 클래스의 비공개 멤버에 접근할 수 없다.**
    - 내포된 클래스에 inner 를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.
  - 일반적으로 this 는 항상 가장 내부의 클래스 인스턴스를 카리킨다. 내부 클래스 본문에서 외부 클래스 인스턴스를 가리켜야 한다면
  한정시킨 this 식을 사용해야 한다. 한정시킨 this 식에서 @ 기호 다음에 오는 식별자는 외부 클래스의 이름이다. (예) this@Person)
- 지역 클래스
  - 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획할 수 있고, 심지어는 변경할 수도 있다.
  - 하지만 코틀린이 제공하는 포획 변수를 변경하는 기능은 그에 따른 비용을 수반한다. 컴파일러는 공유되는 값을 특별한 래퍼 객체로 둘러싼다.
  - 불변 변수는 값이 바뀌지 않기 때문에 래퍼가 필요 없으므로 이런 부가 비용이 없다.
  - 내포된 클래스와 달리 지역 클래스에는 가시성 변경자를 붙일 수 없다. 지역 클래스의 영역은 항상 자신을 둘러싼 블록으로 제한된다.
  - 지역 클래스에 내포된 클래스는 반드시 inner 클래스여야만 한다.

### 4.2 널 가능성

- 스마트 캐스트는 when 이나 루프 같은 조건 검사가 들어가는 다른 문이나 식 안에서도 작동한다.
- **널 검사와 사용 지점 사이에서 값이 변경되는 경우에는 스마트 캐스트가 작동하지 않는다.**
  - (객체의) 가변 프로퍼티에 대해서는 절대 스마트 캐스트를 적용할 수 없다. 언제든 코드의 다른 부분에서 프로퍼티 값을 바꿀 수 있기 때문이다.

### 4.3 단순한 변수 이상인 프로퍼티

- 커스텀 접근자
  - 프로퍼티 값을 읽거나 쓸 때 호출되는 특별한 함수
  - get() 함수에는 파라미터가 없다.
  - get() 함수의 반환 타입은 프로퍼티의 타입과 같아야 한다.
  - 커스텀 접근자는 뒷받침하는 필드가 없기 때문에 클래스 인스턴스에서 전혀 메모리를 차지하지 않는다. 대신 프로퍼티를 읽을 때마다 매번 다시 계산하여 결과를 리턴한다.
  - 필드 참조는 field 라는 키워드를 사용하며 접근자의 본문 안에서만 유용하다.
  - **공식 코틀린 코딩 관습은 값을 계산하는 과정에서 예외가 발생할 여지가 없거나, 값을 계산하는 비용이 충분히 싸거나, 값을 캐시해 두거나, 클래스 인스턴스의
  상태가 바뀌기 전에는 여러번 프로퍼티를 읽거나, 함수를 호출해도 항상 똑같은 결과를 내는 경우에는 함수보다 프로퍼티를 사용하는 쪽을 권장한다.**
  - 프로퍼티 세터의 파라미터는 단 하나이며, 타입은 프로퍼티 자체의 타입과 같아야 한다.
    - 보통은 파라미터 타입을 항상 미리 알 수 있기 때문에 세터에서는 파라미터 타입을 생략한다.
    - 관습적으로 파라미터 이름을 value 로 정하는 경우가 많지만 원하는 다른 이름을 붙여도 좋다.
  - lateinit 프로퍼티의 경우 항상 자동으로 접근자가 생성되기 때문에 프로그래머가 직접 커스텀 접근자를 정의할 수 없다.
  - 주생성자 파라미터로 선언된 프로퍼티에 대한 접근자도 지원하지 않는다. 
- 지연 계싼 프로퍼티와 위임
  - lazy 프로퍼티는 일단 초기화된 다음에는 변경되지 않는다.
  - 디폴트로 lazy 프로퍼티는 thread-safe 하다.
  - 코틀린 1.1 부터는 지역 변수에도 위임을 쓸 수 있다.
  - 위임 프로퍼티에 대해서는 스마트 캐스트를 사용할 수 없다.

### 4.4 객체

- 동반 객체의 멤버에 접근할 때는 동반 객체의 이름을 사용하지 않고 동반 객체가 들어있는 외부 클래스의 이름을 사용할 수 있다.
- 자바 static class vs 코틀린 companion object
  - 코틀린 동반 객체의 문맥은 객체 인스턴스라는 차이점이 있다.
  - 이로 인해 자바의 정적 클래스 보다 코틀린 동박 객체가 더 유연하다. 코틀린 동반 객체는 다른 상위 타입을 상속할 수도 있고, 일반 객체처럼 여기저기에 전달될 수 있기 때문이다.
  - 자바의 static 초기화 블록처럼 동반 객체 안에서도 init 블록을 사용할 수 있다.
- 객체 식
  - 명시적인 선언 없이 객체를 바로 생성할 수 있는 특별한 식. 자바 익명 클래스와 아주 비슷하다.
  - 클래스나 객체 식과 달리 객체를 함수 안에 정의할 수 없다.
  - **익명 객체 타입은 지역 선언이나 비공개 선언에만 전달될 수 있다.** 
  - 지역 함수나 클래스와 마찬가지로 객체 식도 자신을 둘러싼 코드 영역의 변수를 포획할 수 있다.
  - 지연 초기화되는 객체 선언과 달리 객체 식이 만들어내는 객체는 객체 인스턴스가 생성된 직후 바로 초기화 된다.

## 5장 고급 함수와 함수형 프로그래밍 활용하기

### 5.1 코틀린을 활용한 함수형 프로그래밍

- 함수형 언어는 함수를 일급 시민(first class)값으로 취급한다. 이 말은 함수를 다른 일반적인 타입의 값과 똑같이 취급한다는 뜻이다.
- 일급 시민이라는 말에는 변수에 값을 대입하거나 변수에서 값을 읽을 수 있고 함수에 값을 전달하거나 함수가 값을 반환할 수 있다는 뜻이 들어있다.
- 함수 타입
  - 함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이다. 문법적으로 이런 타입은 함수 시그니처(signature)와 비슷하며, 다음과 같이 두 가지 부분으로 구성된다.
    - **괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달될 데이터의 종류와 수를 정의한다.**
    - **반환 타입은 함수 타입의 함숫값을 호출하면 돌려받게 되는 값의 타입을 정의한다.**
  - **반환값이 없는 함수라도 함수 타입에서는 반환 타입을 반드시 명시해야 한다. 따라서 이런 경우 Unit 을 반환 타입으로 사용한다.**
  - 함수 정의에서와 달리 함수 타입 표기에서는 인자 타입 목록과 반환 타입 사이를 : 이 아닌 -> 로 구분한다.
  - invoke() 메서드를 이용해서 일반 함수처럼 호출할 수 있다.
  - **코틀린 1.4 부터는 코틀린 인터페이스 앞에 fun 을 붙이면 코틀린 인터페이스를 SAM 인터페이스로 취급한다.**
    - 이 기능을 사용하면 자바의 SAM 인터페이스와 마찬가지로 코틀린 인터페이스를 람다로 인스턴스화 할 수 있다.
  - 파라미터를 타입을 둘러싼 괄호는 필수이므로 함수 타입이 파라미터를 하나만 받거나 전혀 받지 않는 경우에도 괄호를 꼭 쳐야 한다.
  - 함수 타입의 파라미터 목록에 파라미터 이름을 포함시킬 수도 있지만, 파라미터 이름은 단순히 문서화를 위한 것이며, 타입이 표현하는 함숫값에는 전혀 영향을 미치지 못한다.
- 람다와 익명 함수
  - 람다에 인자가 없으면 화살표 기호(->)를 생략할 수 있다.
  - 람다 인자가 하나인 경우에는 파라미터 목록과 화살표 기호를 생략하고, 유일한 파라미터는 미리 정해진 it 이라는 이름을 사용해 가리킬 수 있다.
  - 익명 함수와 일반 함수의 차이점
    - 익명 함수에는 이름을 지정하지 않는다. 따라서 fun 키워드 다음에 바로 파라미터 목록이 온다.
    - 람다와 마찬가지로 문맥에서 파라미터 타입을 추론할 수 있으면 파라미터 타입을 지정하지 않아도 된다.
    - 함수 정의와 달리, 익명 함수는 식이기 때문에 인자로 함수에 넘기거나 변수에 대입하는 등 일반 값처럼 쓸 수 있다.
  - **지역 함수와 마찬가지로 람다나 익명 함수도 클로저, 또는 자신을 포함하는 외부 선언에 정의된 변수에 접근할 수 있다. 특히 람다나 익명 함수도 외부 영역의 가변 변수 값을 변경할 수 있다.**
- 인라인 함수와 프로퍼티
  - 고차 함수나 함숫값을 사용하면 함수가 객체로 표현되기 때문에 성능 차원에서 부가 비용이 발생한다.
  - 익명 함수나 람다가 외부 영역의 변수를 참조하면 고차 함수에 함숫값을 넘길 때 마다 이런 외부 영역의 변수를 포획할 수 있는 구조도 만들어서 넘겨야 한다.
  - 함숫값을 호출할 때는 컴파일러가 함숫값의 정적인 타입을 알 수 없기 때문에 동적으로 가상 호출을 사용해 어떤 함수 구현을 사용할지 디스패치해야 한다. 
  - 코틀린은 함숫값을 사용할 때 발생하는 런타임 비용을 줄일 수 있는 해법으로 **인라인**(inline) 기법을 제공한다.
  - 코틀린은 비공개 코드가 외부로 노출되는 일을 방지하기 위해 인라인 함수에 비공개 멤버를 전달하는 것을 금지한다.
  - 코틀린 버전 1.1 부터는 프로퍼티 접근자를 인라인하도록 허용한다. 이 기능을 사용하면 함수 호출을 없애기 때문에 프로퍼티를 읽고 쓰는 성능을 향상시킬 수 있다.
    - 개별 getter, setter 접근자를 인라인하는 것 외에 프로퍼티 자체에 inline 변경자를 붙일 수도 있다.
    - 프로퍼티에 대한 인라인은 뒷받침하는 필드가 없는 프로퍼티에 대해서만 가능하다.
    - 프로퍼티가 공개 프로퍼티인 경우, 프로퍼티의 게터나 세터 안에서 비공개 선언을 참조하면 인라인이 불가능하다.

### 5.2 확장

- 확장 함수
  - **확장 함수 자체는 수신 객체가 속한 타입의 캡슐화를 깰 수 없다. 확장 함수는 클래스 밖에 정의된 함수이므로 수신 객체가 속한 클래스의 비공개 멤버에 접근 할 수 없다.**
  - 클래스 멤버와 확장의 시그니처가 같은 경우에는 멤버를 우선 선택함으로써 기본 클래스의 동작이 사고로 변경되는 것을 방지해준다.
  - 확장 함수는 수신 객체를 가리키는파라미터가 추가된 정적 메서드로 컴파일된다.

### 5.5 수신 객체가 있는 호출 가능 참조 

- 영역 함수
  - (식을 계산한 결과를 담을) 지역 변수를 명시적으로 선언하지 않고, 식의 값이 들어있는 암시적인 영역을 정의하는 함수를 보통 영역 함수(scope function)라고 부른다.
  - 모든 영역 함수는 인라인 함수이기 때문에 런타입 부가 비용이 없다.
  - 일반적으로 여러 영역 함수를 내포시키면 this 나 it 이 어떤 대상을 가리키는지 구분하기 어려워지므로 영역 함수를 여러 겹으로 내포시켜 사용하지 않는 편을 권장한다.
  - run 과 with 함수
    - run() 함수는 확장 람다를 받는 확장 함수이며 람다의 결과를 돌려준다. 
    - **기본적인 사용 패턴은 객체 상태를 설정한 다음, 이 객체를 대상으로 어떤 결과를 만들어내는 람다를 호출하는 것이다.**
    - with() 함수는 run() 과 상당히 비슷하다. 유일한 차이는 with()가 확장 함수 타입이 아니므로 문맥 식을 with 의 첫 번째 인자로 전달해야 한다는 점뿐이다.
      - **이 함수를 일반적으로 사용하는 경우는 문맥 식의 멤버 함수와 프로퍼티에 대한 호출을 묶어 동일한 영역 내에서 실행하는 경우다.**
  - 문맥이 없는 run
    - 이 함수는 문맥 식이 없고 람다의 값을 반환하기만 한다. 람다 자체에는 수신 객체도 없고 파라미터도 없다.
    - **주로 이 함수를 사용하는 경우는 어떤 식이 필요한 부분에서 블록을 사용하는 것이다.**
      - 어떠한 인스턴스만을 처리하기 위한 영역을 따로 만들 때 사용 할 수 있다.
    - run 은 인라인 함수이므로 람다 내부에서 바깥쪽 함수의 제어를 반환시키기 위해 return 을 사용해도 된다.
      - 그냥 블록을 사용하면 블록을 람다로 취급하기 때문에 제대로 작동하지 않는다.
  - let 함수
    - let 함수는 run 과 비슷하지만 확장 함수 타입의 람다를 받지 않고 인자가 하나뿐인 함수 타입의 람다를 받는다는 점이 다르다.
    - 따라서 문맥 식의 값은 람다의 인자로 전달된다.
    - 외부 영역에 새로운 변수를 도입하는 일을 피하고 싶을 때 주로 이 함수를 사용한다.
    - **널이 될 수 있는 값을 안전성 검사를 거쳐서 널이 될 수 없는 함수에 전달할 때 사용한다.**
    - **연산을 아규먼트 처리 후로 이동시킬 때 사용한다.**
  - apply/also 함수
    - apply() 함수는 확장 람다를 받는 확장 함수이며 자신의 수신 객체를 반환한다.
    - **이 함수는 일반적으로 run() 과 달리 반환값을 만들어내지 않고 객체의 상태를 설정하는 경우에 사용한다.**
    - **also()함수는 apply() 와 달리 인자가 하나 있는 람다를 파라미터로 받는다.**
- 클래스 멤버인 확장
  - 클래스 안에서 확장 함수나 프로퍼티를 선언하면 일반적인 멤버나 최상위 확장과 달리 이런 함수나 프로퍼티에는 **수신 객체가 두 개 있다.**
  - 이때 확장 정의의 수신 객체 타입의 인스턴스를 확장 수신 객체(extension receiver)라 부르고, 확장이 포함된 클래스 타입의 인스턴스를 디스패치 수신 객체(dispatch receiver)라 부른다.
  - 두 수신 객체를 가리킬 때는 this 앞에 클래스 이름이나 확장 이름을 붙여서 한정시킨다.
  - **수신 객체의 영역을 자신이 포함된 선언 내부로 제한하는 쪽을 더 권장한다.**

## 6장 특별한 클래스 사용하기

### 6.1 이넘(enum) 클래스

- 이넘 클래스는 미리 정의된 상수들로 이뤄진 제한된 집합을 표현하는 특별한 클래스다.
- 이넘 클래스도 일반 클래스에 허용되는 정의를 포함할 수 있다. 
  - 함수, 프로퍼티, 주생성자와 부생성자, 초기화 블록, 내부 클래스/내포된 클래스, 객체(동반 내포 객체와 일반 내포 객체)등이 포함된다.
- 이넘 클래스에 정의된 이런 요소들은 반드시 이넘 상수 목록 뒤에 와야 한다. 이런 경우에는 상수 목록과 다른 부분을 구분하기 위해 상수 목록을 세미콜론으로 끝내야 한다.
- 모든 이넘 클래스 상수에서 이넘 클래스의 본문에 정의된 멤버를 사용할 수 있다.
- 코틀린의 모든 이넘 클래스는 암시적으로 kotlin.Enum 클래스의 하위 타입이다.
  - 모든 이넘 값에는 ordinal 과 name 이라는 한 쌍의 프로퍼티가 들어있다.
  - ordinal 은 이넘 클래스 안에 정의된 이넘 값의 순서에 따른 인덱스이고, name 은 이넘 값의 이름이다.
  - 특정 이넘 클래스의 값을 이넘 본문에 있는 정의의 위치에 따라 서로 비교할 수 있다.
  - 자바와 코틀린의 이넘이 모두 Comparable 인터페이스를 암시적으로 구현하기는 하지만, 자바에서는 이넘 값에 대해 < 나 > 등의 연산을 적용할 수 없다.
  - valueOf(): 이넘 값의 이름을 문자열로 넘기면 그에 해당하는 이넘 값을 돌려주거나 이름이 잘못된 경우 예외를 던진다.
  - values(): 정의된 순서대로 모든 이넘 값이 들어있는 배열을 돌려준다. 
    - **이 메서드를 호출할 때마다 배열이 새로 생긴다는 점에 유의하라.**
    - 따라서 이 메서드에서 얻은 배열의 내용을 바꾸더라도 나머지 배열에는 영향이 없다.
  - 코틀린 1.1 부터는 values() 나 valueOf() 대신에 제네릭 최상위 메서드인 enumValues() 와 enumValueOf() 를 사용할 수도 있다.

### 6.2 데이터 클래스

- 구조 분해 선언에서 사용하지 않는 부분을 _ 로 대신할 수 있다.
- val/var 지정은 구조 분해 선언의 모든 부분에 적용된다. 따라서 모든 변수를 가변 변수로 정의하거나 모든 변수를 불변 변수로 정의해야만 하며, 둘을 섞어서 정의할 수는 없다.
- for 루프에서도 구조 분해를 사용할 수 있다.
- 코틀린 1.1 부터는 람다 파라미터에 대해 구조 분해를 사용할 수 있다.
- 현재는 지역 변수에서만 구조 분해 선언을 사용할 수 있다. 클래스 본문이나 파일의 최상위에 구조 분해를 사용할 수는 없다.

### 6.3 인라인 클래스(값 클래스)

- 코틀린 1.3 에서는 inline 이라는 키워드를 사용했지만, 자바에 값 클래스가 생겼으므로 이에 맞춰 코틀린 1.5에서는 value 로 키워드로 변경됐다.
  - 또한, JVM 백엔드를 사용하는 경우에는 @JvmInline 을 value class 앞에 반드시 붙여줘야 한다.
- 인라인 클래스의 주생성자에는 불변 프로퍼티를 하나만 선언해야 한다.
- 런타임에 클래스 인스턴스는 별도의 래퍼 객체를 생성하지 않고 이 프로퍼티의 값으로 표현된다.
- 런타임에는 호출 지점을 함수 본문으로 인라인하는 인라인 함수처럼 인라인 클래스 객체를 사용하는 위치 대신 인라인 클래스에 들어있는 값이 들어간다.
- 인라인 클래스의 프로퍼티는 상태를 포함할 수 없다. 현재 코틀린 컴파일러는 오직 한 프로퍼티만 인라인하도록 지원하기 때문이다.
  - 이 말은 뒷받침하는 필드나 lateinit 이나 (lazy 를 포함하는)위임 객체 프로퍼티를 사용할 수 없다는 뜻이다.
  - 인라인 클래스 프로퍼티는 명시적인 접근자만 허용된다.
  - 인라인 클래스의 본문에서 var 프로퍼티를 정의할 수 있지만, 인라인 클래스 내부에는 가변 상태가 없기 때문에 보통 이런 var 프로퍼티는 거의 의미가 없다.
- 초기화 블록을 쓸 수 없다. 인라인 클래스는 런타임에 어떠한 커스텀 코드도 실행할 수 없다.
- 프로그램 안에서 널이 될 수 있는 타입의 변수에 원시 값을 대입하는 등의 경우에는 암시적으로 원시 값을 박싱한다.
  - 인라인 클래스도 마찬가지다. 최적화를 위해 컴파일러는 가능하면 박싱하지 않은 값을 사용하려고 한다. 
  - 하지만 박싱하지 않은 값을 사용할 수 없는 경우, 컴파일러는 인라인되지 않는 형태로 클래스를 사용하는 편을 택한다.
- 부호 없는 정수
  - 부호 없는 정수 타입의 이름은 상응하는 부호 있는 정수 타입의 이름 앞에 U 를 덧붙인 것이다.
  - 코틀린 1.5 부터 표준 라이브러리 기능으로 정식 도입. 
  - 변수에 타입을 지정하지 않은 경우에는 크기에 따라 UInt 나 ULong 중 하나로 결정된다.
  - 부호가 있는 타입과 부호가 없는 타입은 서로 호환되지 않는다.
  - 부호가 있는 타입과 부호가 없는 타입의 값을 toXXX() 를 통해 반대쪽 타입으로 변환할 수 있다.
  
## 7장 컬렉션과 I/O 자세히 알아보기

### 7.1 컬렉션

- 컬렉션은 엘리먼트들로 이뤄진 그룹을 저장하기 위해 설계된 객체다.
- 컬렉션을 조작하는 모든 연산은 인라인 함수이기 때문에 함수 호출이나 람다 호출에 따른 부가 비용이 들지 않는다.
- 컬렉션 타입
  - 코틀린 컬렉션 타입은 기본적으로 배열, 이터러블(iterable), 시퀀스(sequence), 맵(map) 이렇게 네 가지로 분류할 수 있다.
  - 이터러블
    - **이터러블은 Iterable<T> 타입으로 표현되며, 일반적으로 즉시 계산(eager)되는 상태가 있는 컬렉션을 표현한다.**
    - 상태가 있다는 말은 컬렉션이 원소를 필요할 때 생성하는 제너레이터 함수를 유지하지 않고 원소를 저장한다는 뜻이다.
    - 즉시 계산이라는 말은 나중에 어느 필요한 시점에 원소가 초기화 되지 않고 컬렉션을 최초로 생성할 때 초기화 된다는 뜻이다.
    - **Collections 는 기본적으로 Eager evaluation 으로 동작하며, Sequences 는 Lazy evaluation 으로 동작한다..**
    - 자바와의 차이점
      - 코틀린은 불변 컬렉션과 가변 컬렉션을 구분한다.
      - **컬렉션의 변경 가능성은 컬렉션 인스턴스에 대한 참조를 저장하는 변수의 변경 가능성과 아무런 관계가 없다는 점에 유의하자.**
    - 불변 컬렉션 타입에서 유용한 특징으로는 공변성(covariance)이 있다.
      - 공변성이라는 말은 T 가 U 의 하위 타입인 경우 Iterable\<T> 도 Iterable\<U> 의 하위타입이라는 뜻이다.
      - Iterator, Collection, List, Set, Map 등과 같은 컬렉션 관련 타입의 경우에도 이런 공변성이 성립한다.
      - **가변 컬렉션의 경우에는 공변성이 성립하지 않는다. 만약 가변 컬렉션에 대해 공변성이 성립한다면, 정수를 문자열 리스트에 추가하는 것과 같은 일이 벌어질 수 있다.**
  - 컬렉션, 리스트, 집합
    - 리스트(List, MutableList)
    - HashSet: 원소 타입의 순서는 hashCode() 메서드 구현에 따라 달라진다.
    - LinkedHashSet: 해시 테이블 기반이지만 삽입 순서를 유지한다. 
    - TreeSet: 이진 검색 트리 기반이며, 어떤 비교 규칙에 따라 일관성 있는 원소 순서를 제공한다. Comparable 인터페이스를 상속해서 비교 규칙을 정의할 수 있다. 
    - 코틀린 코드에서는 java.util 패키지의 클래스를 사용할 필요가 없다. kotlin.collections 패키지에 있는 별멸을 통해 ArrayList 등과 같은 대부분의 표준 컬렉션을 쓸 수 있다.
  - 시퀀스
    - 시퀀스는 지연 계산을 가정하기 때문에 iterator() 의 의도가 이터러블과 다르다.
    - 대부분의 시퀀스 구현은 객체 초기화 시 원소를 초기화하지 않고 요청에 따라 원소를 계산한다.
    - 대부분의 시퀀스 구현은 상태가 없다. 이 말은 지연 계산한 컬렉션 원소 중에 정해진 개수의 원소만 저장한다는 뜻이다.
      - 반면 이터러블은 원소 개수에 비례해 메모리를 사용한다.
    - 코틀린 1.2 부터 표준 라이브러리는 asSequence() 를 확장 함수로 제공하며, 이 함수는 자바 스트림을 감싸서 코틀린 시퀀스로 사용하게 해준다. 
  - 맵
    - 맵 자체는 Collection 의 하위 타입이 아니지만 맵에 들어있는 원소들을 컬렉션처럼 사용할 수 있다.
    - 키-값 쌍은 Map.Entry 와 MutableMap.MutableEntry 인터페이스로 표현된다.
- Comparable 과 Comparator: 어떠한 클래스가 Comparable 을 상속하면 자동으로 <, > 등의 연산을 쓸 수 있다.
- 컬렉션 생성하기
  - listOfNotNull(): 널인 값을 걸러내고 남은 원소들로 이뤄진 새 불변 리스트를 만든다.
  - 맵 생성 함수들은 Pair 객체들로 이뤄진 가변 인자를 받기 때문에 to 중위 연산자를 사용하면 Pair 객체를 쉽게 만들 수 있다.
  - 제너레이터 함수를 바탕으로 시퀀스를 만드는 방법
    - generateSequence()
      - 시퀀스의 다음 원소를 생성해주는 파라미터가 없는 함수를 인자로 받는다.
      - 이 함수가 널을 반환할 때까지 시퀀스 원소 생성이 계속된다.
    - generateSequence()
      - 초깃값과 파라미터가 하나인 함수를 인자로 받는다.
      - 이 함수는 이전 값으로부터 다음 값을 만들어낸다.
      - 첫 번째 generateSequence() 와 마찬가지로 이 경우에도 제너레이터 함수가 다음 값으로 널을 반환하면 시퀀스가 끝난다.
    - 코틀린 1.3 부터는 특별한 빌더를 사용해 시퀀스를 만드는 방법이 추가 됐다.
      - SequenceScope 가 수신 객체 타입인 확장 람다를 받는 sequence() 함ㅅ를 통해 빌더를 구현할 수 있다.
      - yield(): 원소를 하나 시퀀스에 추가한다.
      - yieldAll(): 지정한 이터레이터, 이터러블, 시퀀스에 들어있는 모든 원소를 시퀀스에 추가한다.
- 기본 컬렉션 연산
  - 원소 인덱스를 참조해야 한다면 forEachIndexed() 함수를 쓰면 된다.
  - contains() 함수 호출을 in 연산자로 대신할 수 있다.
- 컬렉션 원소에 접근하기
  - single() 함수는 컬렉션이 비어있거나 원소가 두 개 이상이면 예외를 던진다.
  - 안전한 버전인 singleOrNull() 동일한 경우 예외 대신 널을 반환한다.
  - elementAt() 함수를 사용하면 인덱스를 사용해 컬렉션 원소를 읽을 수 있는데, 이 함수는 리스트의 get() 함수를 일반화한 함수로 배열, 이터러블, 시퀀스 등에 모두 적용할 수 있다.
    - 잘못된 인덱스에 접근 하면 예외를 던지기 때문에 elementAtOrNull() 이나 elementAtOrElse() 를 사용하자.
  - 배열이나 리스트에 대한 구조 분해를 통해 앞에서부터 최대 다섯 개의 원소를 추출할 수 있다.
    - 하지만 컬렉션에 있는 원소의 수보다 더 많은 원소를 구조 분해로 가져오려고 하면 예외가 발생한다.
- 컬렉션에 대한 조건 검사
  - all() 함수는 컬렉션의 모든 원소가 주어진 술어를 만족하면 true 를 반환한다.
  - none() 함수는 all() 과 반대다. 컬렉션에 주어진 조건을 만족하는 원소가 하나도 없을 때 true 를 반환한다.
  - any() 함수는 컬렉션 원소 중 적어도 하나가 주어진 술어를 만족할 때 true 를 반환한다.
  - 빈 컬렉션의 경우 all() 과 none() 함수는 true 를, any() 함수는 false 를 반환한다.
  - any() 와 none() 함수에는 파라미터를 전혀 받지 않은 오버로딩된 버전이 있다. 이런 함수들은 단순히 컬렉션 객체가 비어있는지만 검사한다.
- 집계
  - sumOf 를 이용해서 각 원소에 대한 연산을 합할 수 있다.
  - minByOrNull(), maxByOrNull() 함수로 비교할 수 없는 원소들로 이뤄진 컬렉션의 최대값/최솟값을 구할 수도 있다.
  - minWithOrNull() 과 maxWithOrNull() 함수는 변환 함수 대신 비교기를 받는다.
  - joinToString()
    - 컬렉션 워소를 문자열로 엮는 일을 담당한다.
    - separator: 인접한 두 원소 사이에 들어갈 구문 문자열(디폴트는 ", ")
    - prefix 와 postfix: 결과 문자열의 맨 앞과 맨 뒤에 들어갈 문자열(디폴트는 빈 문자열인 """)
    - limit: 최대로 보여줄 수 있는 원소의 개수(디폴트는 -1 로 개수 제한이 없다는 뜻임)
    - truncated: limit 가 양수인 경우, limit 범위를 넘어서는 원소를 대체해서 보여준다.
  - reduce()
    - 파라미터가 두 개인 함수를 받는다.
    - 첫 번째 인자는 누적된 값이고, 두 번째 인자는 컬렉션의 현재 값이다.
    - 집계 과정
      - 누적값은 최초에 컬렉션의 첫 번째 원소로 초기화된다.
      - 컬렉션의 매 원소에(두 번째 원소부터) 현재 누적값과 현재 원소를 파라미터로 받은 함수에 적용하고 이 함수 적용의 결과를 누적값에 대입한다. 
      - 누적의 결과를 반환한다.
    - 컬렉션이 비어 있으면 누적값을 초기화 할 수 없으므로 reduce() 함수는 예외를 던진다.
    - 집계 규칙이 원소의 인덱스에 따라 달라진다면 reduceIndexed() 를 사용할 수 있다.
      - 이 함수는 현재 인덱스를 집계 연산의 첫 번째 파라미터로 전달해준다.
  - fold()
    - 누적의 초깃값을 원하는 대로 지정하고 싶을 때 사용
    - 프로그래머가 항상 누적값의 초깃값을 지정하기 때문에 리스트가 비어있어도 fold() 는 reduce() 와 달리 예외를 발생시키지 않는다.
  - reduce()/reduceIndexed()/fold()/foldIndexed() 함수에 대해 컬렉션의 마지막 원소부터 반대 방향으로 계산을 수행해주는 함수도 있다.
    - 배열이나 리스트의 맨 뒤(오른쪽)부터 처리한다는 사실을 알려주기 위해 이런 함수의 이름 뒤에는 Right 가 붙는다.
- 걸러내기
  - 맵에서 키나 값으로만 걸러내고 싶다면 filterKeys, filterValues 를 사용하자.
  - filterNot() 함수는 조건을 부정해 걸러낼 수 있게 해준다.
  - filterIsInstance() 는 원소 중 특정 타입만 남기는 경우 사용
  - 위의 걸러내기 함수들은 호출될 때마다 새로운 불변 컬렉션을 만든다.
  - 걸러낸 결과를 이미 존재하는 가변 컬렉션에 집어 넣고 싶다면 To 로 끝나는 함수를 사용하자.
    - filterTo(), filterNotNullTo(), filterNotTo() ...
  - 주어진 술어를 만족하는 부분 컬렉션과 만족하지 않는 부분 컬렉션의 쌍으로 만들어주는 partition() 함수가 있다.
    - 맵은 partition() 을 제공하지 않는다.
- 변환
  - map() 함수를 맵에 적용 할 수도 있다.
    - 추가로 키와 값만 변환한 새 맵을 돌려주는 mapKeys() 와 mapValues() 함수도 있다.
  - flatMap(): 원래 컬렉션의 각 원소를 컬렉션으로 변환한 다음, 각 컬렉션을 차례로 이어 붙여서 한 컬렉션으로 합쳐준다.
  - flatten(): 원소가 컬렉션인 모든 컬렉션에 적용할 수 있고 각각의 컬렉션을 이어 붙인 한 컬렉션을 내놓는다.
  - 주어진 변환 함수를 바탕으로 원본 컬렉션 원소를 맵의 키나 맵의 값으로 만들 수 있는 변환
    - associateWith(): 원래 컬렉션을 키의 근원으로 사용해 새로운 맵을 만들어 준다.(배열에는 적용할 수 없다.)
    - associateBy(): 컬렉션 원소를 값으로 취급하고 변환 함수를 통해 키를 얻는다. 어떤 키에 대해 같은 값이 여럿 존재하는 경우, 오직 한 값만 반환되는 맵에 남는다.
    - associate(): 컬렉션의 원소를 사용해서 키와 값을 만들어낸다.
- 하위 컬렉션 추출
  - 배열 원소를 다른 배열로 추출하고 싶다면 sliceArray() 를 써야 한다.
  - take() 와 takeLast() 함수는 이터러블이나 배열에서 원소를 주어진 개수만큼 추출한다. 
    - take() 는 맨 앞에서부터, takeLast() 맨 뒤에서부터 개수를 센다.
  - drop() / dropLast() 함수는 take() / takeLast() 를 반전시킨 연산이라고 볼 수 있다. 이들은 주어진 개수만큼 원소를 제거한 나머지 원소들을 돌려준다.
  - 코틀린 1.2 에 추가된 chunked() 함수를 사용하면 이터러블이나 시퀀스를 주어진 개수를 넘지 않는 작은 리스트들로 나눠준다.
  - 코틀린 1.2 에 도입된 windowed() 함수를 사용하면 일정한 간격으로 청크를 연속적으로 얻어낸 슬라이딩 윈도우를 얻을 수 있다.
    - 슬라이딩 윈도우를 생성하는 규칙을 정하는 선택적인 파라미터를 지정할 수도 있다.
    - step: 서로 인접한 윈도우의 첫 번째 워소 사이의 거리(디폴트 1)
    - partialWindows: 컬렉션의 마지막 부분에서 지정한 윈도우 크기보다 작은 크기의 윈도우를 포함시킬지 여부(디폴트는 false)
  - zipWithNext(): 윈소가 두 개뿐인 윈도우를 만든다. windowed() 와 달리 리스트가 아니라 쌍(Pair)의 시퀀스나 리스트를 만들어 낸다.
- 순서: sortedDescending() 는 오름차순이 아니라 역순인 내림차순으로 원소를 정렬

### 7.2 파일과 I/O 스트림

- 스트림 유틸리티
  - Reader.readText(), Reader.readLines()
    - BufferedReader 클래스에 있는 readLine() 은 스트림에서 한 줄을 가져오지만, 두 함수는 스트림 끝까지 콘텐츠를 읽어서 전체를 한 문자열이나 각 줄을 나타내는 문자열의 리스트로 반환한다.
  - readText() 와 달리 readLines() 함수는 값을 반환하면서 스트림을 닫아준다.
  - forEachLine() 과 userLines() 함수는 줄 단위 이터레이션을 허용하고, 스트림을 자동으로 닫기 때문에 스트림을 닫는 일을 신경 쓰지 않아도 된다.
  - copyTo(): 한 스트림에서 다른 스트림으로 데이터를 전달할 수 있다. 이 함수는 이진 데이터와 텍스트 데이터를 처리하는 오버로딩된 버전이 존재한다.
- URL 유틸리티
  - URL.readText(): URL 인스턴스에 해당하는 입력 스트림의 콘텐츠를 전부 읽어온다.
  - URL.readBytes(): 입력 이진 스트림의 콘텐츠를 바이트 배열로 읽어온다.
  - **두 함수 모두 전체 스트림 콘텐츠를 읽어오는 작업이 완료될 때까지 스레드를 블럭시키므로, 큰 파일을 다운로드할 때는 이 함수를 사용하면 안 된다.**
- 파일 콘텐츠 접근하기
  - 코틀린 표준 라이브러리는 명시적으로 I/O 스트림을 쓰지 않고도 파일 콘텐츠를 읽을 수 있는 특별한 함수를 제공한다.
  - 이런 함수는 전체 파일을 읽고 쓰거나, 데이터를 기존 파일 뒤에 추가하거나, 한 줄씩 파일을 처리해야 할 때 유용하다.
  - readText(): 파일 콘텐츠 전부를 한 문자열로 읽어온다.
  - readLines(): 파일 콘텐츠 전부를 줄 구분 문자를 사용해 줄 단위로 나눠 읽어서 문자열의 리스트를 반환한다.
  - writeText(): 파일 콘텐츠를 주어진 문자열로 설정한다. 필요하면 파일을 덮어 쓴다.
  - appendText(): 주어진 문자열을 파일의 콘텐츠 뒤에 추가한다.
  - forEachLine(): 파일 전체를 읽지 않고 텍스트 콘텐츠를 한 줄씩 처리할 수 있다.
  - useLines(): 주어진 람다에 줄의 시퀀스를 전달해준다. 람다는 이렇게 받은 시퀀스를 사용해 어떤 결과를 계산하고, 이 결과는 다시 useLines() 의 결과로 반환된다.
  - 이진 파일을 처리할 때는 forEachBlock() 함수를 사용한다.
    - 디폴트 버퍼 크기는 구현에 따라 다르지만, 선택적으로 blockSize 파라미터를 지정할 수 있다.
    - 코틀린 1.3 에서 디폴트 크기는 4096 바이트 최소 크기는 512 바이트다.
- 파일 시스템 유틸리티
  - deleteRecursively()
    - 파일이나 디렉터리를 자신에게 포함된 자손들까지 포함해 쉽게 지울 수 있다.
    - 삭제가 성공하면 true, 그렇지 않으면 false 를 반환
    - 자바의 mkdirs() 메서드와 비슷하다.
  - copyTo()
    - 자신의 수신 객체를 다른 파일에 복사하고 복사본을 가리키는 파일 객체를 돌려준다.
    - 디폴트로 대상 파일을 덮어 쓰지는 않는다. 따라서 대상 파일이 이미 존재하는 경우 FileAlreadyExistsException 을 발생시킨다.
    - overwirte 파라미터를 지정할 수도 있다.
    - 디렉터리에 적용할 수도 있다. 하지만 디렉터리의 경우 하위 디렉터리나 디렉터리에 들어있는 파일을 복사하지는 않고 대상 경로에 맞춰 빈 디렉터리만 만들어 준다.
      - 디렉터리와 내용물을 모두 복사하고 싶다면 copyRecursively() 함수를 사용해야 한다.
  - copyRecursively()
    - copyTo() 와 마찬가지로 overwrite 파라미터를 통해 덮어 쓸지 여부를 정해줄 수 있다.
    - 어떤 파일을 복사하다가 IOException 이 발생하면 호출할 액션을 설정할 수도 있다.
      - 선택적인 OnError 파라미터를 통해 (File, IOException) -> OnErrorAction 타입의 람다를 넘기면 된다.
      - 람다의 결과값은 문제가 되는 파일을 어떻게 처리할지를 결정한다.
        - SKIP: 파일을 무시하고 복사를 계속 진행
        - TERMINATE: 복사를 중단.
  - walk()
    - 깊이 우선 디렉터리 구조 순회를 구현한다.
    - TOP_DOWN: 자식보다 부모를 먼저 방문(디폴트 값)
    - BOTTOM_UP: 자식을 부모보다 먼저 방문
    - walk() 대신 walkTopDown() 또는 walkBottomUp() 을 명시적으로 쓸 수도 있다.
  - onEnter() 와 onLeave() 함수는 순회가 디렉터리에 들어가거나 디렉터리에서 나올 때 호출할 동작을 지정한다.
  - createTempFile() / createTempDir() 함수를 사용해 임시 파일이나 디렉터리를 만들 수 있다.
    - createTempFile() 과 createTempDir() 은 사용 금지 예고 처리됐으며, 각각 kotlin.io.path 패키지에 있는 createTempFile() 과 crateTempDirectory() 로 대치될 예정이다. 

## 8장 클래스 계층 이해하기

- 인라인 클래스는 다른 클래스를 상속할 수도 없고, 다른 클래스의 상위 클래스 역할을 할 수도 없다.
- 확장은 항상 정적으로 호출할 대상이 결정된다. 즉, 컴파일러는 항상 정적으로 알려진 수신 객체 타입을 기반으로 호출할 확장을 선택한다.
- **상위 클래스로부터 하위 클래스 순서로 초기화가 진행된다.**
- 자바와 달리 생성자 간의 호출이 생성자 본문에 들어가는 일은 결코 없다. 
- is 연산자는 왼쪽 피연산자가 오른쪽에 주어진 타입인 경우 true 를 반환한다.
- 자바의 instanceof 연산자는 null 에 대해 항상 false 를 반환하지만, is 의 결과는 연산자 오른쪽에 있는 타입이 널이 될 수 있는지 여부에 따라 결과가 달라진다.
- 프로퍼티나 커스텀 접근자가 정의된 변수에 대해서는 스마트 캐스트를 쓸 수 없다.
  - 컴파일러가 해당 변수를 검사한 다음에 값이 바뀌지 않는다고 보장할 수 없기 때문이다.
- as 연산자는 자바의 캐스팅 식과 같지만 null 처리가 다르다. 
  - 자바에서는 캐스팅을해도 항상 널은 널로 남지만, 코틀린에서는 대상 타입의 널 가능성에 따라 예외가 발생할 수도 있고 널이 될 수도 있다.
- sealed 변경자를 인터페이스 적용할 수 없다.
- **클래스 위임을 사용하면 번거로운 준비 코드를 사용하지 않고도 객체 합성과 상속의 이점을 살릴 수 있다.**

## 9장 제네릭스

### 9.1 타입 파라미터 

- 코틀린에서는 로타입(raw type)을 허용하지 않는다.
- 타입 파라미터를 상속하지 않는다.
  - 생성자 파라미터를 상위 타입 생성자의 인자로 전달하는 것과 비슷하게, 타입 파라미터를 상위 타입의 타입 인자로 전달해야 한다.
- 클래스 멤버 프로퍼티는 타입 파라미터를 가질 수 없고, 오직 확장 프로퍼티만 타입 파라미터를 가질 수 있다.
- 타입 파라미터에 상위 바운드가 있으면, 컴파일러는 이 타입 파라미터에 공급된 타입 인자의 타입이 상위 바운드의 하위 타입인지 검사한다.
- final 클래스를 상위 바운드로 사용하면 한 가지 타입만 지정할 수 있기 때문에 이런 바운드는 쓸모가 없다.
- 바운드가 자신보다 앞에 있는 타입 파라미터를 가리킬 수도 있다.
- \* 는 기본적으로 알지 못하는 타입을 뜻하며, 타입 인자 하나를 대신한다. 이 구문은 실제로는 프로젝션이라는 특별한 경우에 속한다.

### 9.2 변성

- 변성은 타입 파라미터가 달라질 때 제네릭 타입의 하위 타입 관계가 어떻게 달라지는지를 설명하는 제네릭 타입의 한 측면이다.
- 공변: 타입 파라미터의 상하위 타입 관계에 따라 제네릭 타입의 상하위 타입 관계가 함께 변한다는 뜻이다.
- 무공변: 타입 파라미터에서 하위 타입 관계가 성립해도 제네릭 타입 사이에는 하위 타입 관계가 생기지 않는다는 뜻이다.
- 제네릭 타입 세 가지
  - T 타입의 값을 반환하는 연산만 제공하고 T 타입의 값을 입력으로 받는 연산은 제공하지 않는 제네릭 타입인 생산자
  - T 타입의 값을 입력으로 받기만 하고 결고 T 타입의 값을 반환하지 않는 제네릭 타입인 소비자
  - 위 두 가지 경우에 해당하지 않는 나머지 타입들
- 공변적: 타입 안전성을 해치지 않고 대신 쓰일 수 있도록 허용할 수 있다는 의미 
  - 코틀린에서 생산자 역할을 하는 타입은 모두 공변적이다.
  - Pair, Triple, Iterable, Iterator 등과 같은 대부분의 내장 불변 타입은 공변적이다.
  - 함수 타입은 반환 타입에 대해 공변적이다.
- **공변성이 불변성과 같지는 않다. 공변성(타입 파라미터 T 에 대한)은 단지 T 를 입력으로 사용하지 못하게 방지할 뿐이다.**
  - 따라서 가변 타입을 공변적으로 만들 수도 있다.
- 어떤 타입 파라미터가 항상 out 위치에서 쓰이는 경우에만 이 타입 파라미터를 공변적으로 선언할 수 있다.
- in 위치는 값을 함수 인자나 제네릭 타입의 반공변 타입 인자로 소비하는 경우를 뜻한다.
- \* 로 표시되는 스타 프로젝션은 타입 인자가 타입 파라미터의 바운드 안에서 아무 타입이나 될 수 있다는 사실을 표현한다.
  - 코틀린 타입 파라미터는 상위 바운드만 허용하기 때문에 타입 인자에 스타 프로젝션을 사용하면 타입 인자가 해당 타입 파라미터를 제한하는 타입의 하위 타입 중 어떤 것이든 관계없다는 뜻이다.
  - 코틀린의 스타 프로젝션은 자바의 ? 와일드카드에 대응한다.
  - 스타 프로젝션을 사용하면 타입 인자가 중요하지 않거나 알려져 있지 않은 제네릭 타입을 간결하게 표현할 수 있다.

## 10장 애너테이션과 리플렉션

### 10.1 애너테이션

- 애너테이션은 커스텀 메타데이터를 정의하고 이 메타데이터를 소스코드상의 선언, 식, 전체 파일등의 요소에 엮는 방법을 제공한다.
- 자바 애너테이션과 마찬가지로 코틀린 애너테이션도 런타임에 접근할 수 있다.
- 자바와 달리 코틀린 애너테이션을 식에 적용할 수도 있다.
- 같은 구성 요소에 애너테이션을 여럿 붙이고 싶다면 각괄호([ ])로 애너테이션들을 감쌀 수 있다.
- 자바 애너테이션은 인터페이스로 구성되지만, 코틀린 애너테이션은 특별한 종류의 클래스로 구성된다.
- 애너테이션에 커스텀 애트리뷰트를 추가하고 싶다면 생성자 파라미터를 통해야만 한다.
  - 이와 같은 애너테이션을 사용할 때는 클래스 생성자를 호출할 때처럼 이런 파라미터에 실제 인자를 제공해야 한다.
  - 애너테이션 파라미터는 항상 val 로 선언해야 한다.
- 애너테이션 인자는 컴파일 시에만 평가되므로 애너테이션 인자에 임의의 식을 넣을 수는 없다.
- 애너테이션 파라미터로 사용할 수 있는 타입의 종류
  - Int, Boolean, Double 등 원시 타입
  - String
  - Enum
  - 다른 애너테이션
    - 다른 애너테이션을 인자로 사용하는 경우에는 @ 접두사를 안 붙여도 된다.
    - 대신 일반 생성자 호출처럼 애너테이션을 써야한다.
  - 클래스 리터럴
    - KClass 타입은 자바 언어의 Class 타입에 해당하는 코틀린 클래스다. 클래스 이름 뒤에 ::class 붙여서 클래스 리터럴을 만든다.
  - 위에 나열한 타입들로 이뤄진 배열
- 애너테이션 파라미터로 vararg 대신 명시적인 배열 타입을 사용할 수도 있다.
- 사용 지점 대상 애너테이션
  - property: 프로퍼티 자체를 대상으로 한다.
  - field: 뒷받침하는 필드를 대상으로 한다.
  - get: 프로퍼티 게터를 대상으로 한다.
  - set: 프로퍼티 세터를 대상으로 한다.
  - param: 생성자 파라미터를 대상으로 한다(val/var 가 붙은 파라미터만 대상으로 삼을 수 있다).
  - setparam: 프로퍼티 세터의 파라미터를 대상으로 한다(가변 프로퍼티에만 사용할 수 있다).
  - delegate: 위임 객체를 저장하는 필드를 대상으로 한다(위임 프로퍼티에만 사용할 수 있다).
- 내장 애너테이션
  - @Retention: 애너테이션이 저장되고 유지되는 방식을 제어한다.
    - SOURCE: 컴파일 시점에만 존재하며 컴파일러의 바이너리 출력(JVM 의 경우 바이트코드가 저장된 클래스 파일)에는 저장되지 않는다.
    - BINARY: 컴파일러의 바이너리 출력에 저장되지만, 런타임에 리플렉션 API 로 관찰할 수는 없다.
    - RUNTIME: 컴파일러의 바이너리 출력에 저장되며 런타임에 리플렉션 API 를 통해 관찰할 수도 있다.
    - 디폴트로 RUNTIME 으로 유지 시점이 정의된다.
    - 하지만 현재는 식에 대해 붙은 애너테이션의 경우 런타임까지 유지되지 못한다.
  - 자바와 코틀린의 디폴트 유지 시점 차이
    - 자바에서는 디폴트가 RetentionPolicy.CLASS(코틀린의 AnnotationRetention.BINARY)이며, 이 말은 명시적으로 RUNTIME 으로 지정하지 않으면 자바 애너테이션을 리플렉션에서 관찰할 수 없다는 뜻이다.
  - @Target: 애너테이션을 어떤 언어 요소에 붙일 수 있는지 지정한다.
    - CLASS: 클래스, 인터페이스, 객체에 붙일 수 있다(애너테이션 클래스도 포함).
    - ANNOTATION_CLASS: 애너테이션 클래스에 붙일 수 있다.
    - TYPEALIAS: 타입 별명 정의에 붙일 수 있다.
    - PROPERTY: 주생성자에 정의된 val/var 프로퍼티를 포함해, 프로퍼티에 붙일 수 있다(지역 변수에는 붙일 수 없다).
    - FIELD: 프로퍼티를 뒷받침하는 필드에 붙일 수 있다.
    - LOCAL_VARIABLE: 지역 변수에 붙일 수 있다(파라미터는 제외).
    - VALUE_PARAMETER: 생성자, 함수, 프로퍼티 세터의 파라미터에 붙일 수 있다.
    - CONSTRUCTOR: 주생성자나 부생성자에 붙일 수 있다.
    - FUNCTION: 람다나 익명 함수를 포함해, 함수에 붙일 수 있다(하지만 생성자나 프로퍼티 접근자에는 붙일 수 없다).
    - PROPERTY_GETTER/PROPERTY_SETTER: 프로퍼티 게터/프로퍼티 세터에 붙일 수 있다.
    - FILE: 파일에 붙일 수 있다.
    - TYPE: 타입 지정에 붙일 수 있다. 변수의 타입이나 함수 파라미터 타입, 반환 타입 등을 포함한다.
    - EXPRESSION: 식에 붙일 수 있다.
    - @Target 을 지정하지 않으면 타입 별명, 타입 파라미터, 타입 지정, 식, 파일을 제외한 언어 요소에 애너테이션을 적용할 수 있다.
    - 자바와 코틀린의 차이점
      - 코틀린의 AnnotationTarget.TYPE 은 타입 지정(자바의 ElementType.TYPE_USAGE 에 해당)을 뜻하지만, 자바의 ElementType.TYPE 은 실제 클래스나 인터페이스 선언(코틀린의 AnnotationTarget.CLASS 에 해당)을 뜻한다.

### 10.2 리플렉션

- 리플렉션 API 는 클래스, 함수, 프로퍼티의 런타임 표현에 접근할 수 있게 해주는 타입, 함수, 프로퍼티 모음이다.
- 모든 리플렉션 타입은 KAnnotatedElement 의 자손이다.
- KClass API
  - 대상 클래스에 어떤 변경자가 붙어 있는지를 알아내는 API
    - isAbstract, isCompanion, isData, isFinal, isOpen, isSealed
  - visibility 프로퍼티
    - 가시성 수준을 돌려준다(PUBLIC, PROTECTED, INTERNAL, PRIVATE)
    - 코틀린 소스코드에서 가시성을 표현할 수 없다면 visibility 값이 null 이다.
  - simpleName 프로퍼티: 소스코드에서 사용되는 간단한 이름을 반환한다. 클래스 이름이 없다면 결과는 null 이다.
  - qualifiedName 프로퍼티: 클래스의 전체 이름 조회. 전체 이름에는 클래스가 포함된 패키지의 전체 경로가 들어간다.
  - isInstance() 함수: 주어진 객체가 이 함수의 수신 객체가 표현하는 클래스의 인스턴스인지 알려준다.
  - 멤버 선언에 접근하는 API
    - constructors: 주생성자와 부생성자들을 KFunction 타입의 인스턴스로 돌려준다.
    - members: KCallable 인스턴스로 표현되는 멤버 함수와 프로퍼티 표현의 컬렉션을 돌려준다. 이 컬렉션 안에는 상위 타입에서 상속한 모든 멤버도 함께 포함된다.
    - nestedClasses: 내포된 클래스와 객체들로 이뤄진 컬렉션이다. 동반 객체도 포함된다.
    - typeParameters: KTypeParameter 에 의해 표현되는 타입 파라미터로 이뤄진 리스트다(대상 클래스가 제네릭 타입이 아닌 경우 이 리스트는 빈 리스트다)
  - KClass 가 객체 선언을 표현하는 경우 constructors 프로퍼티는 항상 빈 컬렉션을 반환한다. 
    - 실제 인스턴스를 얻고 싶으면 objectInstance 프로퍼티를 사용해야 한다.
    - KClass 인스턴스가 객체를 표현하지 않으면 objectInstance 프로퍼티도 null 이다.
  - supertype 프로퍼티는 클래스가 직접 상속한 상위 타입만 돌려준다.
- 호출 가능(callable)
  - 호출 가능요소라는 개념은 어떤 결과를 얻기 위해 호출할 수 있는 함수나 프로퍼티를 함께 묶어준다.
  - KCallable 이 제공하는 멤버
    - KClass 와 마찬가지로 어떤 변경자가 붙어있는지 알아 낼 수 있는 프로퍼티들이 존재한다.
      - isAbstract, isFinal, isOpen, isSuspend, visibility
    - 프로퍼티나 함수의 시그니처를 표현하는 프로퍼티가 속한 그룹
      - val name: String
      - val typeParameters: List\<KTypeParameter>
      - val parameters: List\<KParameter>
      - val returnType: KType
    - KParameter 인터페이스는 멤버 및 확장 선언의 수신 객체나 함수/생성자의 파라미터에 대한 정보를 포함한다.
      - index, isOptional, isVararg, name, type, kind
      - isOptional 프로퍼티는 파라미터에 디폴트 값이 있는지 여부를 돌려준다. 하지만 디폴트 값 자체를 알 수는 없다.
      - kind 프로퍼티는 KParameter 인스턴스가 일반적인 값에 해당하는지, 아니면 디스패치나 확장의 수신 객체인지를 알려준다.
        - INSTANCE: 멤버 선언의 디스패치 수신 객체
        - EXTENSION_RECEIVER: 확장 선언의 확장 수신 객체
        - VALUE: 일반적인 값
  - KCallable 에는 이 호출 가능 요소가 표현하는 호출 가능한 선언을 동적으로 호출할 수 있게 해주는 call() 멤버 함수가 들어있다.
    - 함수로부터 만들어진 호출 가능 요소인 경우 call() 은 함수를 호출한다.
    - 호출 가능 요소가 프로퍼티게터라면 게터가 호출된다.
  - KFunction: 함수나 생성자를 표현한다. 함수에 적용 가능한 변경자 검사를 위한 프로퍼티들을 가지고 있다.
    - isInfix, isInline, isOperator, isSuspend

## 11장 도메인 특화 언어

- 일반적으로 사용하는 함수와 DSL 의 차이는 무엇인가? DSL 은 무엇인가?
  - 도메인 전문가도 사용할 수 있는 유비쿼터스 랭귀지가 DSL 이다.
  - DSL 을 만들 때 핵심은 개발자를 제외한 참여 대상(도메인 전문가)도 이해 할 수 있어야 한다?
  - 그렇지만 굳이 DSL 을 만들 필요가 있을까?...

### 11.1 연산자 오버로딩

- 연산자 오버로딩은 +, -, *, / 등 코틀린 내장 연산자에 대해 새로운 의미를 부여할 수 있게 해주는 언어 기능이다.
- 코틀린에서는 && 와 || 를 오버라이딩 할 수 없다.
- 커스텀하게 정의한 모든 중위 연산의 우선순위는 같다.
- **불변 객체인 경우 xxxAssign 사용 금지**

### 11.2 위임 프로퍼티

- lazy() 함수는 다중 스레드 환경에서 지연 계산 프로퍼티의 동작을 미세하게 제어하기 위해 세 가지 다른 버전을 갖고 있다.
  - LazyThreadSafetyMode 이넘 상수를 통해 세 가지 기본 구현중 하나를 선택할 수 있다.
  - SYNCHRONIZED: 프로퍼티 접근을 동기화한다. 따라서 한번에 한 스레드만 프로퍼티 값을 초기화 할 수 있다(이 구현이 디폴트다).
  - PUBLICATION: 초기화 함수가 여러 번 호출될 수 있지만 가장 처음 도착하는 결과가 프로퍼티 값이 되도록 프로퍼티 접근을 동기화한다.
  - NONE: 프로퍼티 접근을 동기화하지 않는다. 이 방식을 선택한다면 다중 스레드 환경에서 프로퍼티의 올바른 동작을 보장할 수 없다.
- 초기화 함수가 예외를 던지면 프로퍼티가 초기화 되지 않는다. 이런 경우 프로퍼티에 다시 접근하려 시도하면 또 다시 초기화 함수가 호출된다.
- kotlin.properties.Delegates 의 표준 위임들
  - notNull()
    - 프로퍼티 초기화를 미루면서 널이 아닌 프로퍼티를 정의할 수 있게 해준다.
    - 의미는 기본적으로 lateinit 프로퍼티와 같다.
    - 보통은 lateinit 쪽이 더 간결하고 성능도 좋다. 하지만 lateinit 은 원시 타입에 적용할 수 없기 때문에 그런 경우에 쓸 수 있다.
  - observable()
    - 프로퍼티 값이 변경될 때 통지를 받을 수 있다.
    - 새 값이 이전 값과 같더라도 통지가 온다. 필요하다면 두 값이 같은지 람다가 직접 검사해야 한다.
  - vetoable()
    - 이 함수는 초깃값과 Boolean 을 반환하는 람다를 인자로 받는다.
    - 프로퍼티 값을 변경하려고 시도할 때마다 값을 변경하기 직전에 이 람다가 호출되고, 람다가 true 를 반환하면 실제 값 변경이 일어난다.
    - 람다가 false 를 반환하면 값이 바뀌지 않고 그대로 남는다.
  - observable() 과 vetoable() 이 제공하는 변경 전과 변경 후 통지를 함께 조합하고 싶다면 ObservableProperty 를 상속해서 beforeChange() 와 afterChange() 함수를 오버라이드하면 된다.
- 커스텀 위임 만들기
  - 읽기 함수의 이름은 getValue 여야 하고, 다음 두가지 파라미터를 받는다.
    - receiver: 수신 객체 값이 들어있고, 위임된 프로퍼티의 수신 객체와 같은 타입(또는 상위 타입)이어야 한다.
    - property: 프로퍼티 선언을 표현하는 리플렉션이 들어있다. KProperty<*> 이거나 상위 타입이어야 한다.
    - 두 파라미터의 이름은 실제로는 중요하지 않고 타입만 중요하다. getValue() 함수의 반환 타입은 반드시 위임 프로퍼티의 타입과 같아야(또는 하위 타입이어야) 한다.
  - var 프로퍼티에 해당하는 읽고 쓸 수 있는 프로퍼티의 경우, getValue() 외에도 프로퍼티에 값을 저장할 때 호출될 setValue() 함수를 정의해야 한다.
  - 이 함수의 반환 타입은 Unit 이어야 하며, 세가지 파라미터를 받는다.
    - receiver: getValue() 와 동일
    - property: getValue() 와 동일
    - newValue: 프로퍼티에 저장할 새 값이다. 프로퍼티 자체와 같은 타입(또는 상위 타입)이어야 한다.
  - 읽기 전용 커스텀 위임을 정의하고 싶다면 kotlin.properties 패키지의 ReadOnlyProperty 인터페이스를 사용하라.
  - 읽기 쓰기 커스텀 위임을 정의하고 싶다면 kotlin.properties 패키지의 ReadWriteProperty 인터페이스를 사용하라.
  - **getValue() / setValue() 함수를 멤버 함수로 정의할 수도 있지만 확장 함수로 정의해도 된다.**

## 12장 자바 상호 운용성

- 자바 void 함수는 코틀린에서 Unit 을 반환하는 함수로 보인다.
- 자바 게터 세터가 코틀린의 합성 프로퍼티로 사용되기 위한 규칙
  - 게터는 파라미터가 없는 메서드여야 하며, 메서드 이름이 get 으로 시작해야 한다.
  - 세터는 파라미터가 하나만 있는 메서드여야 하며, 메서드 이름이 set 으로 시작해야 한다.
  - 게터 이름은 is 로 시작할수도 있다.
- 코틀린으로 매핑된 자바 클래스의 정적 멤버를(예: Long.valueOf())를 코틀린 쪽 동반 객체에서 직접 접근할 수 없다.
  - 정적 멤버를 사용하려면 해당 자바 클래스의 전체 이름을 언급해야 한다.
- 제네릭 타입의 매핑
  - 자바의 extends 와일드카드는 코틀린 공변 프로젝트로 변환된다. 예를 들어 TreeNode\<? extends Person> 은 TreeNode\<out Person>으로 바뀐다. 
  - 자바의 super 와일드카드는 코틀린 반공변 프로젝션으로 변환된다. 예를 들어 TreeNode\<? super Person> 은 TreeNode\<in Person>으로 바뀐다.
  - 자바의 로우 타입은 코틀린 스타 프로젝션으로 바뀐다. 예를 들어 TreeNode 는 TreeNode\<*>가 된다.
- 원시 타입으로 이뤄진 자바 배열은 박싱/언박싱을 피하기 위해 상응하는 특화된 코틀린 배열 클래스로 매핑된다.
- **박싱 & 언박싱**
  - 코틀린에서는 박스형으로 표현하면 컴파일러가 박싱 상황이 없는 변수는 프리미티브로 
  - 박싱 상황이 있는 변수는 박스형으로 처리 
  - 제네릭은 무조건 객체 타입만 가능
- IntArray -> int[] 
- Array\<Int> -> Array\<Integer> 

## 13장 동시성

### 13.1 코루틴

- Thread.sleep(), Thread.join(), Object.wait() 는 실행이 끝날 때까지 블럭된다.
- 스레드를 블럭하고 나중에 실행을 재개하려면 시스템 수준에서 계산 비용이 많이 드는 문맥 전환(context switch)을 해야 하므로 프로그램 성능에 부정적인 영향을 미칠 수 있다.
- 전체 코루틴 라이브러리를 뒷받침하는 기본 요소는 일시 중단 함수다.
- delay(): 코루틴 라이브러리에 정의된 일시 중단 함수
- 코틀린은 일반 함수가 일시 중단 함수를 호출하는 것을 금지한다.
- **코루틴은 스레드보다 훨씬 가볍다. 특히 코루틴은 유지해야 하는 상태가 더 간단하며 일시 중단 되고 재개될 때 완전한 무맥 전환을 사용하지 않아도 되므로 엄청난 수의 코루틴을 충분히 동시에 실행할 수 있다.**
- 코루틴 빌더
  - 동시성 코드의 동작을 제어하고 싶기 때문에 공통적인 생명 주기와 문맥이 정해진 몇몇 작업이 정의된 구체적인 영역 안에서만 동시성 함수를 호출한다.
  - 이런 구체적 영역을 제공하기 위해 코루틴을 실행할 때 사용하는 여러 가지 함수를 `코루틴 빌더`라고 부른다.
    - 코루틴 빌더는 CoroutineScope 인스턴스의 확장 함수로 쓰인다.
  - launch(): 코루틴을 시작하고, 코루틴을 실행 중인 작업의 상태를 추적하고 변경할 수 있는 Job 객체를 돌려준다.
    - 이 함수는 CoroutineScope.() -> Unit 타입의 일시 중단 람다를 받는다.
    - **동시성 작업이 결과를 만들어내지 않는 경우 적합하다.**
  - 결과가 필요한 경우에는 async() 라는 다른 빌더 함수를 사용해야 한다.
    - 이 함수는 Deferred 의 인스턴스를 돌려주고, 이 인스턴스는 Job 의 하위 타입으로 await() 메서드를 통해 계산 결과를 접근할 수 있게 해준다.
    - await() 메서드를 호출하면 계산이 완료되거나(따라서 결과가 만들어지거나) 계산 작업이 취소될 때까지 현재 코루틴을 일시 중단시킨다.
    - 작업이 취소되는 경우 await() 는 예외를 발생시키면서 실패한다.
    - async() 를 자바의 퓨처(future)에 해당하는 코루틴 빌더라고 생각할 수 있다.
  - **launch() 와 async() 빌더의 경우 (일시 중단 함수 내부에서) 스레드 호출을 블럭시키지는 않지만, 백그라운드 스레드를 공유하는 풀(pool)을 통해 작업을 실행한다.**
  - runBlocking() 빌더는 디폴트로 현재 스레드에서 실행되는 코루틴을 만들고 코루틴이 완료될 때까지 현재 스레드의 실행을 블럭시킨다.
    - 코루틴이 성공적으로 끝나면 일시 중단 람다의 결과가 runBlocking() 호출의 결괏값이 된다.
    - 코루틴이 취소되면 runBlocking() 은 예외를 던진다.
    - 블럭된 스레드가 인터럽트되면 runBlocking() 에 의해 시작된 코루틴도 취소된다.
    - **runBlocking() 을 다른 코루틴 안에서 사용하면 안 된다.**
      - runBlocking() 은 블러킹 호출과 넌블러킹 호출 사이의 다리 역할을 하기 위해 고안된 코루틴 빌더이므로,
      테스트나 메인 함수에서 최상위 빌더로 사용되는 경우에만 runBlocking() 을 써야 한다.
- 코루틴 영역과 구조적 동시성
  - 전역 영역이란 코루틴의 생명 주기가 전체 애플리케이션의 생명 주기에 의해서만 제약되는 영역이다.
  - 구조적 동시성
    - 코루틴이 어떤 연산을 수행하는 도중에만 실행될 필요가 있는 경우, 동시성 작업 사이의 부모 자식 관계로 인해 이런 실행 시간 제한이 가능하다.
    - **어떤 코루틴을 다른 코루틴의 문맥에서 실행하면 후자가 전자의 부모가 된다.**
    - 이 경우 자식의 실행이 모두 끝나야 부모가 끝날 수 있도록 부모와 자식의 생명 주기가 연관된다.
    - coroutineScope() 호출로 코드 블럭을 감싸면 커스텀 영역을 도입할 수도 있다.
      - coroutineScope() 와 runBlocking() 의 가장 큰 차이는 coroutineScope() 가 일시 중단 함수라 현재 스레드를 블럭시키지 않는다는 점이다.
- 코루틴 문맥
  - 코루틴마다 CoroutineContext 인터페이스로 표현되는 문맥이 연관돼 있으며, 코루틴을 감싸는 변수 영역의 coroutineContext 프로퍼티를 통해 이 문맥에 접근할 수 있다.
    - 문맥은 키-값 쌍으로 이뤄진 불변 컬렉션이며, 코루틴에서 사용할 수 있는 여러 가지 데이터가 들어 있다.
      - 코루틴이 실행 중인 취소 가능한 작업을 표현하는 잡(job)
      - 코루틴과 스레드의 연관을 제어하는 디스패처(dispatcher)

### 13.2 코루틴 흐름 제어와 잡 생명 주기

- 잡은 동시성 작업의 생명 주기를 표현하는 객체다. 잡을 사용하면 작업 상태를 추적하고 필요할 때 작업을 취소할 수 있다.
- CoroutineStart.DEFAULT: 디플트 동작이며, 잡을 즉시 시작한다.
- CoroutineStart.LAZY: 잡을 자동으로 시작하지 말라는 뜻이다. 이 경우에는 잡이 신규 상태가 되고 시작을 기다리게 된다.
- children 프로퍼티를 통해 완료되지 않은 자식 잡들을 얻을 수 있다.
- **잡의 join() 메서드를 사용하면 조인 대상 잡이 완료될 때까지 현재 코루틴을 일시 중단시킬 수 있다.**
- 잡의 cancel() 메서드를 호출하면 잡을 취소할 수 있다.
  - 이 메서드는 더 이상 필요 없는 계산을 중단시킬 수 있는 표준적인 방법을 제공한다.
  - isActive 확장 프로퍼티는 현재 잡이 활성화된 상태인지 검사한다.
  - 부모 코루틴이 취소되면 자동으로 모든 자식의 실행을 취소한다. 이 과정은 부모에게 속한 모든 잡 계층이 취소될 때까지 계속된다.
- withTimeout(): 타임아웃 설정
  - withTimeoutOrNull() 함수는 타임아웃이 발생하면 예외를 던지는 대신 널 값을 돌려준다.
- 코루틴 디스패치하기
  - 코루틴은 스레드와 무관하게 일시 중단 가능한 계산을 구현할 수 있게 해주지만, 코루틴을 실행 하려면 여전히 스레드와 연관시켜야 한다.
  - 코루틴 라이브러리에는 특정 코루틴을 실행할 때 사용할 스레드를 제어하는 작업을 담당하는 특별한 컴포넌트가 있는데 이를 `코루틴 디스패처(dispatcher)`라고 부른다.
  - 디스패처는 코루틴 문맥의 일부다. 따라서 launch() 나 runBlocking() 등의 코루틴 빌더 함수에서 이를 지정할 수 있다.
  - 디스패처는 그 자체로 원소가 하나뿐인 문맥이기도 하므로, 코루틴 빌더에 디스패처를 넘길 수 있다.
  - 코루틴 라이브러리에서 제공하는 디스패처 구현
    - Dispatchers.Default
      - 공유 스레드 풀로, 풀 크기는 디폴트로 사용 가능한 CPU 코어 수이거나 2다(둘 중 큰 값).
      - 이 구현은 일반적으로 작업 성능이 주로 CPU 속도에 의해 결정되는 CPU 위주의 작업에 적합하다.
    - Dispatchers.IO
      - 파일을 읽고 쓰는 것처럼 잠재적으로 블러킹될 수 있는 I/O 를 많이 사용하는 작업에 최적화돼 있다.
      - 이 디스패처는 스레드 풀을 디폴트 구현과 함께 공유하지만, 필요에 따라 스레드를 추가하거나 종료시켜 준다.
    - Dispatchers.Main
      - 사용자 입력이 처리되는 UI 스레드에서만 베타적으로 작동하는 디스패처
- 예외 처리
  - 코루틴 빌더들은 두 가지 기본 전략 중 하나를 따른다.
  - 첫번째
    - launch() 같은 빌더가 선택한 전략으로, 예외를 부모 코루틴에게 전달한다. 이 경우 예외는 다음과 같이 전파된다.
      - 부모 코루틴이(자식에게서 발생한 오류) 똑같은 오류로 취소된다. 이로 인해 부모의 나머지 자식도 모두 취소된다.
      - 자식들이 모두 취소되고 나면 부모는 예외를 코루틴 트리의 윗부분으로 전달한다.
      - 전역 영역에 있는 코루틴에 도달할 때까지 이 과정이 반복된다.
      - 그 후 예외가 CoroutineExceptionHandler.Consider 에 의해 저리된다.
        - CoroutineExceptionHandler 는 전역 영역에서 실행된 코루틴에 대해서만 정의할 수 있고, CoroutineExceptionHandler 가 정의된 코루틴의 자식에 대해서만 적용된다.
  - 두번째
    - async() 빌더에서 사용하는 방법으로, 던져진 예외를 저장했다가 예외가 발생한 계산에 대한 await() 호출을 받았을 때 다시 던지는 것이다.
  - 내포된 코루틴에서 발생한 예외를 전역 핸들러를 통하지 않고 부모 수준에서 처리하고 싶을 때는 `슈퍼바이저(supervisor) 잡`을 사용해야 한다.
    - 슈퍼바이저 잡이 있으면 취소가 아래 방향으로만 전달된다.
    - 슈퍼바이저를 취소하면 슈퍼바이저 잡은 자동ㅇ으로 자신의 모든 자식을 취소한다.
    - 하지만 슈퍼바이저가 아니라 자식이 취소된 경우, 슈퍼바이저나 슈퍼바이저의 다른 자식들은 아무 영향을 받지 않는다.

### 13.3 동시성 통신

- 채널
  - 채널은 임의의 데이터 스트림을 코루틴 사이에 공유할 수 있는 방법이다.
  - Channel 인터페이스가 제공하는 채널에 대한 기본 연산은 데이터를 보내는 send() 메서드와 데이터를 받는 receive() 메서드다.
  - 이런 메서드들이 자신의 작업을 완료할 수 없을 때, 예를 들어 채널 내부 버퍼가 꽉 찼는데 데이터를 보내려고 하면,
  채널은 현재 코루틴을 일시 중단시키고 나중에 처리가 가능할 때 재개한다.
    - **이 부분이 자바의 동시성 API 에서 채널과 비슷한 역할을 하는 블러킹 큐와 채널의 가장 큰 차이다. 블러킹 큐는 스레드를 블럭시킨다.**
  - 제네릭 Channel() 함수를 사용해 채널을 만들 수 있다.
    - 채널 기본 구현은 크기가 정해진 내부 버퍼를 사용한다.
    - 버퍼가 꽉 차면 최소 하나 이상의 채널 원소가 상대방에 의해 수신될 때까지 send() 호출이 일시 중단된다.
    - 버퍼가 비어있으면 누군가 최소 하나 이상의 원소를 채널로 송신할 때까지 receive() 호출이 일시 중단된다.
  - **출력이 실제 지연 시간 값이나 다른 환경에 의해 달라질 수 있지만, 채널은 모든 값이 송신된 순서 그대루 수신되도록 보장한다.**
  - 채널의 동작을 바꿀 수 있는 여러 특별한 값들
    - Channel.UNLIMITED(= Int.MAX_VALUE)
      - 채널의 용량은 제한이 없고, 내부 버퍼는 필요에 따라 증가한다.
      - 이런 채널은 send() 시에 결코 중단되는 일이 없다. 다만 receive() 를 하는 버퍼가 비어있으면 일시 중단될 수 있다.
    - Channel.RENDEZVOUS(= 0)
      - 이 경우 채널은 아무 내부 버퍼가 없는 랑데부 채널이 된다.
      - send() 호출은 다른 어떤 코루틴이 receive() 를 호출할 때까지 항상 일시 중단된다.
      - 마찬가지로 receive() 호출은 다른 어떤 코루틴이 send() 를 호출할 때까지 일시 중단된다.
      - **채널 생성시 용량을 지정하지 않으면 이 방식의 채널이 생성된다.**
    - Channel.CONFLATED(= -1)
      - 이 경우에는 송신된 값이 합쳐지는 채널이다.
      - 이 말은 send() 로 보낸 원소를 최대 하나만 버퍼에 저장하고 이 값이 누군가에 의해 수신되기 전에 다른 send() 요청이 오면 기존 값을 덮어 쓴다는 뜻이다.
      - 따라서 수신되지 못한 원소 값은 소실된다.
      - 이 채널의 경우 send() 메서드는 결코 일시 중단되지 않는다.
    - Channel.UNLIMITED 보다 작은 임의의 양수를 지정하면 버퍼 크기가 일정하게 제한된 채널이 생긴다.
    - 랑데부 채널은 생산자와 소비자 코루틴이 교대로 활성화되도록 보장한다.
  - 소비자 쪽에서는 명시적인 이터레이션을 사용하지 않고 consumeEach() 함수를 통해 모든 채널 콘텐츠를 얻어서 사용할 수 있다.
  - 채널 통신에 참여하는 생산자와 소비자가 꼭 하나씩일 필요는 없다. 예를 들어 한 채널을 여러 코루틴이 동시에 읽을 수도 있다.
  이런 경우를 팬 아웃(fan out)이라고 한다.
  - 여러 생산자 코루틴이 한 채널에 써넣은 데이터를 한 소비자 코루틴이 읽는 팬 인(fan in)도 있다.
- 생산자
  - `produce()` 라는 코루틴 빌더를 사용하면 컬렉션의 sequence() 함수와 비슷하게 동시성 데이터 스트림을 생성할 수 있다.
    - 이 빌더는 채널과 비슷한 send() 메서드를 제공하는 `ProducerScope` 영역을 도입해준다.
    - 이 경우 채널을 명시적으로 닫을 필요가 없다. 코루틴이 종료되면 produce() 빌더가 채널을 자동으로 닫아준다.
  - 예외 처리 관점에서 볼 때 produce() 는 async()/await() 정책을 따른다.
    - produce() 안에서 예외가 발생하면 예외를 저장했다가 해당 채널에 대해 receive() 를 가장 처음 호출한 코루틴 쪽에 예외가 다시 던져진다.
- 티커
  - 이 채널은 Unit 값을 계속 발생시키되 한 원소와 다음 원소의 발생 시점이 주어진 지연 시간만큼 떨어져 있는 스트림을 만든다.
  이 채널을 만들려면 ticker() 함수를 사용해야 한다.
  - 이 함수를 호출할 때 지정할 수 있는 옵션들 
    - delayMillis: 티커 원소의 발생 시간 간격을 밀리초 단위로 지정
    - initialDelayMillis: 티커 생성 시점과 원소가 최초로 발생하는 시점 사이의 시간 간격이다. 디폴트 값은 delayMillis 와 같다.
    - context: 티커를 실행할 코루틴 문맥이다(디폴트는 빈 문맥이다).
    - mode: 티커의 행동을 결정하는 TickerMode 이넘이다.
      - TickerMode.FIXED_PERIOD: 생성되는 원소 사이의 시간 간격을 지정된 지연 시간에 최대한 맞추기 위해 실제지연 시간을 조정한다.
      - TickerMode.FIXED_DELAY: 실제 흘러간 시간과 관계없이 delayMillis 로 지정한 지연 시간만큼 시간을 지연시킨 후 다음 원소를 송신한다.
  - 티커 관련 API 는 현재 실험 단계에 있으며 미래의 코루틴 라이브러리 버전에서는 언제든 다른 내용으로 바뀔 수 있다.
- 액터
  - 가변 상태를 스레드 안전하게 공유하는 방법을 구현하는 일반적인 방법으로 액터(actor)모델이 있다.
  - 액터는 내부 상태와 다른 액터에게 메시지를 보내서 동시성 통신을 진행할 수 있는 수단을 제공하는 객체다.
  - 액터는 자신에게 들어오는 메시지를 리슨하고, 자신의 상태를 바꾸면서 메시지에 응답할 수 있으며, 다른 메시지를(자기 자신이나 다른 액터에게)
  보낼 수 있고, 새로운 액터를 시작할 수 있다.
  - **액터의 상태는 액터 내부에 감춰져 있으므로 다른 액터가 직접 이 상태에 접근할 수 없다. 다른 액터는 단지 메시지를 보내고 응답을 받아서 상태를 알 수 있을 뿐이다.**
  - 액터는 특별한 영역(ActorScope)을 만들며, 이 영역은 기본 코루틴 영역에 자신에게 들어오는 메시지에 접근할 수 있는 수신자 채널이 추가된 것이다.
  - 액터 빌더도 현재 실험적인 API 이므로 향후 변경될 여지가 있다.

### 13.4 자바 동시성 사용하기

- 스레드 시작하기
  - thread() 함수
    - start: 스레드를 생성하자마자 시작할지 여부(디폴트는 true)
    - isDaemon: 스레드를 데몬 모드로 시작할지 여부(디폴트는 false). 데몬 스레드는 JVM 의 종료를 방해하지 않고 메인 스레드가 종료될 때 자동으로 함께 종료된다.
    - contextClassLoader: 스레드 코드가 클래스와 자원을 적재할 때 사용할 클래스 로더(디폴트는 널)
    - name: 커스텀 스레드 이름. 디폴트는 널인데, 이는 JVM 이 이름을 자동으로 지정한다는 뜻이다
    - priority: Thread.MIN_PRIORITY(=1) 부터 Thread.MAX_PRIORITY(=10) 사이의 값으로 정해지는 우선순위로, 어떤 스레드가 다른 스레드에 비해 얼마나 많은
    CPU 시간을 배정받는지 결정한다. 디폴트 값은 -1 이며, 이 값은 자동으로 우선순위를 정하라는 뜻이다.
    - block: () -> Unit 타입의 함숫값으로 새 스레드가 생성되면 실행할 코드다.