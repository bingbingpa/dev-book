# 코틀린 완벽 가이드 *입문부터 활용까지, 필요한 지식 총망라!*
- *알렉세이 세두노프 저/오현석 역 | 길벗*

<br>

## 1장. 강력하고 실용적인 코틀린 

- [awesome kotlin 웹사이트(https://kotlin.link/)](https://kotlin.link/)

## 3장. 함수 정의하기

### 3.1 함수

- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
- 파라미터 앞에 val 이나 var 를 표시할 수 없다.
- **코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다.**
  - 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다.
  - 하지만 파라미터가 참조(예) 배열)라면 호출한 쪽의 데이터는 그대로 남아 있고 이 데이터에 대한 참조만 복사된다.
  - 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.
    - 예를 들어 정수 배열을 가리키는 (불변)참조를 받아서 첫 번째 원소를 변경하면, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
- 위치 기반 인자와 이름 붙은 인자
  - 코틀린 1.4 이전에는 이름 붙은 인자를 쓰기 시작하면 그 이후의 모든 인자에 이름을 붙여야 했다.
  - **1.4 부터는 이름 붙은 인자를 중간에 섞어 쓸 수 있다.**
  - 다만 이 경우에는 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리 된다.
    - 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.
- 오버로딩과 디폴트 값
  - 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다.
- vararg
  - 스프레드(spread) 연산자인 * 를 사용하면 배열을 가변 인자 대신 넘길수 있다.
  - **스프레드는 배열을 복사한다는 점의 유의하자. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.**
  - 하지만 이때 얕은(shallow)복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
  - 둘 이상을 vararg 파라미터로 선언하는 것은 금지 된다.
  - vararg 파라미터가 맨 마지막에 있는 파라미터가 아니라면, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.
    - **디폴트 값과 비슷하게 vararg 파라미터도 목록의 맨 뒤에 위치시키는 것이 좋은 코딩 스타일이다.**
  - vararg 파라미터를 이름 붙은 인자로 전달할 수는 없다. 
    - ~~~kotlin
      printSorted(items = 1, 2, 3) // error
      printSorted(items = *intArrayOf(1, 2, 3)) // ok
      ~~~
- 함수의 영역과 가시성
  - internal 변경자를 적용하면 함수가 적용된 모듈 내부에서만 함수를 사용할 수 있게 제한한다.
  - 코틀린에서 모듈은 기본적으로 함께 컴파일되는 파일 전부를 뜻한다.

### 3.3 조건문

- if 문을 식으로 사용할때는 양 가지가 모두 있어야 한다.(if/else 모두)
- Nothing 타입은 모든 코틀린 타입의 하위 타입으로 간주되기 때문에 식이 필요한 위치에 return 을 사용해도 타입 오류가 발생하지 않는다.
- 범위, 진행, 연산
  - 수 타입, Char, Boolean, String 등 모든 비교 가능한(comparable) 타입에 대해 .. 연산을 쓸 수 있다.
  - 기본적으로 <= 와 >= 를 쓸 수 있는 타입이라면 이 타입에 대해 .. 를 사용해 범위를 만들 수 있다.
  - **.. 연산에 의해 만들어지는 범위는 닫혀 있다. 즉, 시작 값과 끝 값이 범위에 포함된다.**
  - until 은 끝값은 범위에 포함되지 않는다.
  - 내장 범위 연산에서 끝 값이 시작 값보다 확실히 더 작으면 빈 범위가 된다. 
    - ~~~kotlin
      println(5 in 10..1) // false
      ~~~
  - 진행: 정해진 간격(step)만큼 떨어져 있는 정수나 Char 값들로 이뤄진 시퀀스
    - 정수나 Char 에 대해 정의된 범위는 실제로는 간격이 1인 진행이라 할 수 있다.
    - downTo: 아래로 내려가는(descending)진행을 만들 수 있다.
    - step: 진행의 간격을 지정(진행의 간격은 양수여야 한다.) 
      - ~~~kotlin
        1..10 step 3 // 1, 4, 7, 10
        15 downTo 9 step 2 // 15, 13, 11, 9
        ~~~
  - 범위를 사용하면 문자열이나 배열의 일부분을 뽑아 낼 수 있다.
    - ~~~kotlin
      "Hello, World".substring(1..4) // ello
      IntArray(10) { it*it }.sliceArray(2..5) // 4, 9, ,16, 25
      ~~~
  - 우선순위로 보면 범위 연산인 .. 는 덧셈과 중위 연산 사이에 속하며, in 과 !in 연산은 중위와 비교 연산 사이에 속한다.
- when
  - 코틀린 1.3 부터는 다음과 같이 식의 대상을 변수에 연결 할 수 있다. 이때 정의한 변수는 when 블록 내부에서만 사용할 수 있고 var 로 선언할 수는 없다.
    - ~~~kotlin
      fun readHexDigit() = when(val n = readLine()!!.toInt()) {
          in 0..9 -> '0' + n
          in 10..15 -> 'A' + n - 10
          else -> '?'
      }
      ~~~

### 3.4 루프

- 문자열과 배열에는 원소나 문자의 인덱스 범위를 제공하는 indices 라는 프로퍼티가 들어있다.
- break: 즉시 루프를 종료시키고, 실행 흐름이 루프 바로 다음 문으로 이동하게 만든다.
- continue: 현재 루프 이터레이션(iteration)을 마치고 조건 검사로 바로 진행하게 만든다.
- **코틀린에서는 함수에 tailrec 을 붙이면 컴파일러가 재귀 함수를 비재귀적인 코드로 자동으로 변환해준다.**

## 4장 클래스와 객체 다루기

### 4.1 클래스 정의하기 

- 클래스에 주생성자를 선언하지 않은 경우, 모든 부생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 init 블록을 실행한다. 
  - 이렇게 하면 어떤 부생성자를 호출하든지 공통적인 초기화 코드가 정확히 한 번만 실행되게 보장할 수 있다.
- 생성자 파라미터 목록 뒤에 콜론(:)을 넣고 그 뒤에 일반 함수를 호출하는 것처럼 코드를 작성하되, 함수 이름 대신 this 를 사용하면 생성자 위임 호출이 된다.
- 부생성자의 파라미터 목록에는 val/var 키워드를 쓸 수 없다.
- 코틀린에는 자바의 패키지 전용에 해당하는 가시성이 없다.
- 주생성자의 가시성을 지정하려면 constructor 키워드를 꼭 명시해야 한다.
  - ~~~kotlin
    class Person private constructor(val test: String)
    ~~~
- 내포된 클래스(nested class)
  - 내포된 클래스는 내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.
  - **자바와 달리, 바깥쪽 클래스는 자신에게 내포된 클래스의 비공개 멤버에 접근할 수 없다.**
    - 내포된 클래스에 inner 를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.
  - 일반적으로 this 는 항상 가장 내부의 클래스 인스턴스를 카리킨다. 내부 클래스 본문에서 외부 클래스 인스턴스를 가리켜야 한다면
  한정시킨 this 식을 사용해야 한다. 한정시킨 this 식에서 @ 기호 다음에 오는 식별자는 외부 클래스의 이름이다. (예) this@Person)
- 지역 클래스
  - 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획할 수 있고, 심지어는 변경할 수도 있다.
  - 하지만 코틀린이 제공하는 포획 변수를 변경하는 기능은 그에 따른 비용을 수반한다. 컴파일러는 공유되는 값을 특별한 래퍼 객체로 둘러싼다.
  - 불변 변수는 값이 바뀌지 않기 때문에 래퍼가 필요 없으므로 이런 부가 비용이 없다.
  - 내포된 클래스와 달리 지역 클래스에는 가시성 변경자를 붙일 수 없다. 지역 클래스의 영역은 항상 자신을 둘러싼 블록으로 제한된다.
  - 지역 클래스에 내포된 클래스는 반드시 inner 클래스여야만 한다.

### 4.2 널 가능성

- 스마트 캐스트는 when 이나 루프 같은 조건 검사가 들어가는 다른 문이나 식 안에서도 작동한다.
- **널 검사와 사용 지점 사이에서 값이 변경되는 경우에는 스마트 캐스트가 작동하지 않는다.**
  - (객체의) 가변 프로퍼티에 대해서는 절대 스마트 캐스트를 적용할 수 없다. 언제든 코드의 다른 부분에서 프로퍼티 값을 바꿀 수 있기 때문이다.

### 4.3 단순한 변수 이상인 프로퍼티

- 커스텀 접근자
  - 프로퍼티 값을 읽거나 쓸 때 호출되는 특별한 함수
  - get() 함수에는 파라미터가 없다.
  - get() 함수의 반환 타입은 프로퍼티의 타입과 같아야 한다.
  - 커스텀 접근자는 뒷받침하는 필드가 없기 때문에 클래스 인스턴스에서 전혀 메모리를 차지하지 않는다. 대신 프로퍼티를 읽을 때마다 매번 다시 계산하여 결과를 리턴한다.
  - 필드 참조는 field 라는 키워드를 사용하며 접근자의 본문 안에서만 유용하다.
  - **공식 코틀린 코딩 관습은 값을 계산하는 과정에서 예외가 발생할 여지가 없거나, 값을 계산하는 비용이 충분히 싸거나, 값을 캐시해 두거나, 클래스 인스턴스의
  상태가 바뀌기 전에는 여러번 프로퍼티를 읽거나, 함수를 호출해도 항상 똑같은 결과를 내는 경우에는 함수보다 프로퍼티를 사용하는 쪽을 권장한다.**
  - 프로퍼티 세터의 파라미터는 단 하나이며, 타입은 프로퍼티 자체의 타입과 같아야 한다.
    - 보통은 파라미터 타입을 항상 미리 알 수 있기 때문에 세터에서는 파라미터 타입을 생략한다.
    - 관습적으로 파라미터 이름을 value 로 정하는 경우가 많지만 원하는 다른 이름을 붙여도 좋다.
  - lateinit 프로퍼티의 경우 항상 자동으로 접근자가 생성되기 때문에 프로그래머가 직접 커스텀 접근자를 정의할 수 없다.
  - 주생성자 파라미터로 선언된 프로퍼티에 대한 접근자도 지원하지 않는다. 
- 지연 계싼 프로퍼티와 위임
  - lazy 프로퍼티는 일단 초기화된 다음에는 변경되지 않는다.
  - 디폴트로 lazy 프로퍼티는 thread-safe 하다.
  - 코틀린 1.1 부터는 지역 변수에도 위임을 쓸 수 있다.
  - 위임 프로퍼티에 대해서는 스마트 캐스트를 사용할 수 없다.

### 4.4 객체

- 동반 객체의 멤버에 접근할 때는 동반 객체의 이름을 사용하지 않고 동반 객체가 들어있는 외부 클래스의 이름을 사용할 수 있다.
- 자바 static class vs 코틀린 companion object
  - 코틀린 동반 객체의 문맥은 객체 인스턴스라는 차이점이 있다.
  - 이로 인해 자바의 정적 클래스 보다 코틀린 동박 객체가 더 유연하다. 코틀린 동반 객체는 다른 상위 타입을 상속할 수도 있고, 일반 객체처럼 여기저기에 전달될 수 있기 때문이다.
  - 자바의 static 초기화 블록처럼 동반 객체 안에서도 init 블록을 사용할 수 있다.
- 객체 식
  - 명시적인 선언 없이 객체를 바로 생성할 수 있는 특별한 식. 자바 익명 클래스와 아주 비슷하다.
  - 클래스나 객체 식과 달리 객체를 함수 안에 정의할 수 없다.
  - **익명 객체 타입은 지역 선언이나 비공개 선언에만 전달될 수 있다.** 
  - 지역 함수나 클래스와 마찬가지로 객체 식도 자신을 둘러싼 코드 영역의 변수를 포획할 수 있다.
  - 지연 초기화되는 객체 선언과 달리 객체 식이 만들어내는 객체는 객체 인스턴스가 생성된 직후 바로 초기화 된다.

## 5장 고급 함수와 함수형 프로그래밍 활용하기

### 5.1 코틀린을 활용한 함수형 프로그래밍

- 함수형 언어는 함수를 일급 시민(first class)값으로 취급한다. 이 말은 함수를 다른 일반적인 타입의 값과 똑같이 취급한다는 뜻이다.
- 일급 시민이라는 말에는 변수에 값을 대입하거나 변수에서 값을 읽을 수 있고 함수에 값을 전달하거나 함수가 값을 반환할 수 있다는 뜻이 들어있다.
- 함수 타입
  - 함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이다. 문법적으로 이런 타입은 함수 시그니처(signature)와 비슷하며, 다음과 같이 두 가지 부분으로 구성된다.
    - **괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달될 데이터의 종류와 수를 정의한다.**
    - **반환 타입은 함수 타입의 함숫값을 호출하면 돌려받게 되는 값의 타입을 정의한다.**
  - **반환값이 없는 함수라도 함수 타입에서는 반환 타입을 반드시 명시해야 한다. 따라서 이런 경우 Unit 을 반환 타입으로 사용한다.**
  - 함수 정의에서와 달리 함수 타입 표기에서는 인자 타입 목록과 반환 타입 사이를 : 이 아닌 -> 로 구분한다.
  - invoke() 메서드를 이용해서 일반 함수처럼 호출할 수 있다.
  - **코틀린 1.4 부터는 코틀린 인터페이스 앞에 fun 을 붙이면 코틀린 인터페이스를 SAM 인터페이스로 취급한다.**
    - 이 기능을 사용하면 자바의 SAM 인터페이스와 마찬가지로 코틀린 인터페이스를 람다로 인스턴스화 할 수 있다.
  - 파라미터를 타입을 둘러싼 괄호는 필수이므로 함수 타입이 파라미터를 하나만 받거나 전혀 받지 않는 경우에도 괄호를 꼭 쳐야 한다.
  - 함수 타입의 파라미터 목록에 파라미터 이름을 포함시킬 수도 있지만, 파라미터 이름은 단순히 문서화를 위한 것이며, 타입이 표현하는 함숫값에는 전혀 영향을 미치지 못한다.
- 람다와 익명 함수
  - 람다에 인자가 없으면 화살표 기호(->)를 생략할 수 있다.
  - 람다 인자가 하나인 경우에는 파라미터 목록과 화살표 기호를 생략하고, 유일한 파라미터는 미리 정해진 it 이라는 이름을 사용해 가리킬 수 있다.
  - 익명 함수와 일반 함수의 차이점
    - 익명 함수에는 이름을 지정하지 않는다. 따라서 fun 키워드 다음에 바로 파라미터 목록이 온다.
    - 람다와 마찬가지로 문맥에서 파라미터 타입을 추론할 수 있으면 파라미터 타입을 지정하지 않아도 된다.
    - 함수 정의와 달리, 익명 함수는 식이기 때문에 인자로 함수에 넘기거나 변수에 대입하는 등 일반 값처럼 쓸 수 있다.
  - **지역 함수와 마찬가지로 람다나 익명 함수도 클로저, 또는 자신을 포함하는 외부 선언에 정의된 변수에 접근할 수 있다. 특히 람다나 익명 함수도 외부 영역의 가변 변수 값을 변경할 수 있다.**
- 인라인 함수와 프로퍼티
  - 고차 함수나 함숫값을 사용하면 함수가 객체로 표현되기 때문에 성능 차원에서 부가 비용이 발생한다.
  - 익명 함수나 람다가 외부 영역의 변수를 참조하면 고차 함수에 함숫값을 넘길 때 마다 이런 외부 영역의 변수를 포획할 수 있는 구조도 만들어서 넘겨야 한다.
  - 함숫값을 호출할 때는 컴파일러가 함숫값의 정적인 타입을 알 수 없기 때문에 동적으로 가상 호출을 사용해 어떤 함수 구현을 사용할지 디스패치해야 한다. 
  - 코틀린은 함숫값을 사용할 때 발생하는 런타임 비용을 줄일 수 있는 해법으로 **인라인**(inline) 기법을 제공한다.
  - 코틀린은 비공개 코드가 외부로 노출되는 일을 방지하기 위해 인라인 함수에 비공개 멤버를 전달하는 것을 금지한다.
  - 코틀린 버전 1.1 부터는 프로퍼티 접근자를 인라인하도록 허용한다. 이 기능을 사용하면 함수 호출을 없애기 때문에 프로퍼티를 읽고 쓰는 성능을 향상시킬 수 있다.
    - 개별 getter, setter 접근자를 인라인하는 것 외에 프로퍼티 자체에 inline 변경자를 붙일 수도 있다.
    - 프로퍼티에 대한 인라인은 뒷받침하는 필드가 없는 프로퍼티에 대해서만 가능하다.
    - 프로퍼티가 공개 프로퍼티인 경우, 프로퍼티의 게터나 세터 안에서 비공개 선언을 참조하면 인라인이 불가능하다.

### 5.2 확장

- 확장 함수
  - **확장 함수 자체는 수신 객체가 속한 타입의 캡슐화를 깰 수 없다. 확장 함수는 클래스 밖에 정의된 함수이므로 수신 객체가 속한 클래스의 비공개 멤버에 접근 할 수 없다.**
  - 클래스 멤버와 확장의 시그니처가 같은 경우에는 멤버를 우선 선택함으로써 기본 클래스의 동작이 사고로 변경되는 것을 방지해준다.
  - 확장 함수는 수신 객체를 가리키는파라미터가 추가된 정적 메서드로 컴파일된다.

### 5.5 수신 객체가 있는 호출 가능 참조 

- 영역 함수
  - (식을 계산한 결과를 담을) 지역 변수를 명시적으로 선언하지 않고, 식의 값이 들어있는 암시적인 영역을 정의하는 함수를 보통 영역 함수(scope function)라고 부른다.
  - 모든 영역 함수는 인라인 함수이기 때문에 런타입 부가 비용이 없다.
  - 일반적으로 여러 영역 함수를 내포시키면 this 나 it 이 어떤 대상을 가리키는지 구분하기 어려워지므로 영역 함수를 여러 겹으로 내포시켜 사용하지 않는 편을 권장한다.
  - run 과 with 함수
    - run() 함수는 확장 람다를 받는 확장 함수이며 람다의 결과를 돌려준다. 
    - **기본적인 사용 패턴은 객체 상태를 설정한 다음, 이 객체를 대상으로 어떤 결과를 만들어내는 람다를 호출하는 것이다.**
    - with() 함수는 run() 과 상당히 비슷하다. 유일한 차이는 with()가 확장 함수 타입이 아니므로 문맥 식을 with 의 첫 번째 인자로 전달해야 한다는 점뿐이다.
      - **이 함수를 일반적으로 사용하는 경우는 문맥 식의 멤버 함수와 프로퍼티에 대한 호출을 묶어 동일한 영역 내에서 실행하는 경우다.**
  - 문맥이 없는 run
    - 이 함수는 문맥 식이 없고 람다의 값을 반환하기만 한다. 람다 자체에는 수신 객체도 없고 파라미터도 없다.
    - **주로 이 함수를 사용하는 경우는 어떤 식이 필요한 부분에서 블록을 사용하는 것이다.**
      - 어떠한 인스턴스만을 처리하기 위한 영역을 따로 만들 때 사용 할 수 있다.
    - run 은 인라인 함수이므로 람다 내부에서 바깥쪽 함수의 제어를 반환시키기 위해 return 을 사용해도 된다.
      - 그냥 블록을 사용하면 블록을 람다로 취급하기 때문에 제대로 작동하지 않는다.
  - let 함수
    - let 함수는 run 과 비슷하지만 확장 함수 타입의 람다를 받지 않고 인자가 하나뿐인 함수 타입의 람다를 받는다는 점이 다르다.
    - 따라서 문맥 식의 값은 람다의 인자로 전달된다.
    - 외부 영역에 새로운 변수를 도입하는 일을 피하고 싶을 때 주로 이 함수를 사용한다.
    - **널이 될 수 있는 값을 안전성 검사를 거쳐서 널이 될 수 없는 함수에 전달할 때 사용한다.**
    - **연산을 아규먼트 처리 후로 이동시킬 때 사용한다.**
  - apply/also 함수
    - apply() 함수는 확장 람다를 받는 확장 함수이며 자신의 수신 객체를 반환한다.
    - **이 함수는 일반적으로 run() 과 달리 반환값을 만들어내지 않고 객체의 상태를 설정하는 경우에 사용한다.**
    - **also()함수는 apply() 와 달리 인자가 하나 있는 람다를 파라미터로 받는다.**
- 클래스 멤버인 확장
  - 클래스 안에서 확장 함수나 프로퍼티를 선언하면 일반적인 멤버나 최상위 확장과 달리 이런 함수나 프로퍼티에는 **수신 객체가 두 개 있다.**
  - 이때 확장 정의의 수신 객체 타입의 인스턴스를 확장 수신 객체(extension receiver)라 부르고, 확장이 포함된 클래스 타입의 인스턴스를 디스패치 수신 객체(dispatch receiver)라 부른다.
  - 두 수신 객체를 가리킬 때는 this 앞에 클래스 이름이나 확장 이름을 붙여서 한정시킨다.
  - **수신 객체의 영역을 자신이 포함된 선언 내부로 제한하는 쪽을 더 권장한다.**