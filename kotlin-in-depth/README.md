# 코틀린 완벽 가이드 *입문부터 활용까지, 필요한 지식 총망라!*
- *알렉세이 세두노프 저/오현석 역 | 길벗*

<br>

## 1장. 강력하고 실용적인 코틀린 

- [awesome kotlin 웹사이트(https://kotlin.link/)](https://kotlin.link/)

## 3장. 함수 정의하기

### 3.1 함수

- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
- 파라미터 앞에 val 이나 var 를 표시할 수 없다.
- **코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다.**
  - 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다.
  - 하지만 파라미터가 참조(예) 배열)라면 호출한 쪽의 데이터는 그대로 남아 있고 이 데이터에 대한 참조만 복사된다.
  - 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.
    - 예를 들어 정수 배열을 가리키는 (불변)참조를 받아서 첫 번째 원소를 변경하면, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
- 위치 기반 인자와 이름 붙은 인자
  - 코틀린 1.4 이전에는 이름 붙은 인자를 쓰기 시작하면 그 이후의 모든 인자에 이름을 붙여야 했다.
  - **1.4 부터는 이름 붙은 인자를 중간에 섞어 쓸 수 있다.**
  - 다만 이 경우에는 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리 된다.
    - 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.
- 오버로딩과 디폴트 값
  - 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다.
- vararg
  - 스프레드(spread) 연산자인 * 를 사용하면 배열을 가변 인자 대신 넘길수 있다.
  - **스프레드는 배열을 복사한다는 점의 유의하자. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.**
  - 하지만 이때 얕은(shallow)복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
  - 둘 이상을 vararg 파라미터로 선언하는 것은 금지 된다.
  - vararg 파라미터가 맨 마지막에 있는 파라미터가 아니라면, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.
    - **디폴트 값과 비슷하게 vararg 파라미터도 목록의 맨 뒤에 위치시키는 것이 좋은 코딩 스타일이다.**
  - vararg 파라미터를 이름 붙은 인자로 전달할 수는 없다. 
    - ~~~kotlin
      printSorted(items = 1, 2, 3) // error
      printSorted(items = *intArrayOf(1, 2, 3)) // ok
      ~~~
- 함수의 영역과 가시성
  - internal 변경자를 적용하면 함수가 적용된 모듈 내부에서만 함수를 사용할 수 있게 제한한다.
  - 코틀린에서 모듈은 기본적으로 함께 컴파일되는 파일 전부를 뜻한다.

### 3.3 조건문

- if 문을 식으로 사용할때는 양 가지가 모두 있어야 한다.(if/else 모두)
- Nothing 타입은 모든 코틀린 타입의 하위 타입으로 간주되기 때문에 식이 필요한 위치에 return 을 사용해도 타입 오류가 발생하지 않는다.
- 범위, 진행, 연산
  - 수 타입, Char, Boolean, String 등 모든 비교 가능한(comparable) 타입에 대해 .. 연산을 쓸 수 있다.
  - 기본적으로 <= 와 >= 를 쓸 수 있는 타입이라면 이 타입에 대해 .. 를 사용해 범위를 만들 수 있다.
  - **.. 연산에 의해 만들어지는 범위는 닫혀 있다. 즉, 시작 값과 끝 값이 범위에 포함된다.**
  - until 은 끝값은 범위에 포함되지 않는다.
  - 내장 범위 연산에서 끝 값이 시작 값보다 확실히 더 작으면 빈 범위가 된다. 
    - ~~~kotlin
      println(5 in 10..1) // false
      ~~~
  - 진행: 정해진 간격(step)만큼 떨어져 있는 정수나 Char 값들로 이뤄진 시퀀스
    - 정수나 Char 에 대해 정의된 범위는 실제로는 간격이 1인 진행이라 할 수 있다.
    - downTo: 아래로 내려가는(descending)진행을 만들 수 있다.
    - step: 진행의 간격을 지정(진행의 간격은 양수여야 한다.) 
      - ~~~kotlin
        1..10 step 3 // 1, 4, 7, 10
        15 downTo 9 step 2 // 15, 13, 11, 9
        ~~~
  - 범위를 사용하면 문자열이나 배열의 일부분을 뽑아 낼 수 있다.
    - ~~~kotlin
      "Hello, World".substring(1..4) // ello
      IntArray(10) { it*it }.sliceArray(2..5) // 4, 9, ,16, 25
      ~~~
  - 우선순위로 보면 범위 연산인 .. 는 덧셈과 중위 연산 사이에 속하며, in 과 !in 연산은 중위와 비교 연산 사이에 속한다.
- when
  - 코틀린 1.3 부터는 다음과 같이 식의 대상을 변수에 연결 할 수 있다. 이때 정의한 변수는 when 블록 내부에서만 사용할 수 있고 var 로 선언할 수는 없다.
    - ~~~kotlin
      fun readHexDigit() = when(val n = readLine()!!.toInt()) {
          in 0..9 -> '0' + n
          in 10..15 -> 'A' + n - 10
          else -> '?'
      }
      ~~~

### 3.4 루프

- 문자열과 배열에는 원소나 문자의 인덱스 범위를 제공하는 indices 라는 프로퍼티가 들어있다.
- break: 즉시 루프를 종료시키고, 실행 흐름이 루프 바로 다음 문으로 이동하게 만든다.
- continue: 현재 루프 이터레이션(iteration)을 마치고 조건 검사로 바로 진행하게 만든다.
- **코틀린에서는 함수에 tailrec 을 붙이면 컴파일러가 재귀 함수를 비재귀적인 코드로 자동으로 변환해준다.**

## 4장 클래스와 객체 다루기

### 4.1 클래스 정의하기 

- 클래스에 주생성자를 선언하지 않은 경우, 모든 부생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 init 블록을 실행한다. 
  - 이렇게 하면 어떤 부생성자를 호출하든지 공통적인 초기화 코드가 정확히 한 번만 실행되게 보장할 수 있다.
- 생성자 파라미터 목록 뒤에 콜론(:)을 넣고 그 뒤에 일반 함수를 호출하는 것처럼 코드를 작성하되, 함수 이름 대신 this 를 사용하면 생성자 위임 호출이 된다.
- 부생성자의 파라미터 목록에는 val/var 키워드를 쓸 수 없다.
- 코틀린에는 자바의 패키지 전용에 해당하는 가시성이 없다.
- 주생성자의 가시성을 지정하려면 constructor 키워드를 꼭 명시해야 한다.
  - ~~~kotlin
    class Person private constructor(val test: String)
    ~~~
- 내포된 클래스(nested class)
  - 내포된 클래스는 내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.
  - **자바와 달리, 바깥쪽 클래스는 자신에게 내포된 클래스의 비공개 멤버에 접근할 수 없다.**
    - 내포된 클래스에 inner 를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.
  - 일반적으로 this 는 항상 가장 내부의 클래스 인스턴스를 카리킨다. 내부 클래스 본문에서 외부 클래스 인스턴스를 가리켜야 한다면
  한정시킨 this 식을 사용해야 한다. 한정시킨 this 식에서 @ 기호 다음에 오는 식별자는 외부 클래스의 이름이다. (예) this@Person)
- 지역 클래스
  - 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획할 수 있고, 심지어는 변경할 수도 있다.
  - 하지만 코틀린이 제공하는 포획 변수를 변경하는 기능은 그에 따른 비용을 수반한다. 컴파일러는 공유되는 값을 특별한 래퍼 객체로 둘러싼다.
  - 불변 변수는 값이 바뀌지 않기 때문에 래퍼가 필요 없으므로 이런 부가 비용이 없다.
  - 내포된 클래스와 달리 지역 클래스에는 가시성 변경자를 붙일 수 없다. 지역 클래스의 영역은 항상 자신을 둘러싼 블록으로 제한된다.
  - 지역 클래스에 내포된 클래스는 반드시 inner 클래스여야만 한다.

### 4.2 널 가능성

- 스마트 캐스트는 when 이나 루프 같은 조건 검사가 들어가는 다른 문이나 식 안에서도 작동한다.
- **널 검사와 사용 지점 사이에서 값이 변경되는 경우에는 스마트 캐스트가 작동하지 않는다.**
  - (객체의) 가변 프로퍼티에 대해서는 절대 스마트 캐스트를 적용할 수 없다. 언제든 코드의 다른 부분에서 프로퍼티 값을 바꿀 수 있기 때문이다.

### 4.3 단순한 변수 이상인 프로퍼티

- 커스텀 접근자
  - 프로퍼티 값을 읽거나 쓸 때 호출되는 특별한 함수
  - get() 함수에는 파라미터가 없다.
  - get() 함수의 반환 타입은 프로퍼티의 타입과 같아야 한다.
  - 커스텀 접근자는 뒷받침하는 필드가 없기 때문에 클래스 인스턴스에서 전혀 메모리를 차지하지 않는다. 대신 프로퍼티를 읽을 때마다 매번 다시 계산하여 결과를 리턴한다.
  - 필드 참조는 field 라는 키워드를 사용하며 접근자의 본문 안에서만 유용하다.
  - **공식 코틀린 코딩 관습은 값을 계산하는 과정에서 예외가 발생할 여지가 없거나, 값을 계산하는 비용이 충분히 싸거나, 값을 캐시해 두거나, 클래스 인스턴스의
  상태가 바뀌기 전에는 여러번 프로퍼티를 읽거나, 함수를 호출해도 항상 똑같은 결과를 내는 경우에는 함수보다 프로퍼티를 사용하는 쪽을 권장한다.**
  - 프로퍼티 세터의 파라미터는 단 하나이며, 타입은 프로퍼티 자체의 타입과 같아야 한다.
    - 보통은 파라미터 타입을 항상 미리 알 수 있기 때문에 세터에서는 파라미터 타입을 생략한다.
    - 관습적으로 파라미터 이름을 value 로 정하는 경우가 많지만 원하는 다른 이름을 붙여도 좋다.
  - lateinit 프로퍼티의 경우 항상 자동으로 접근자가 생성되기 때문에 프로그래머가 직접 커스텀 접근자를 정의할 수 없다.
  - 주생성자 파라미터로 선언된 프로퍼티에 대한 접근자도 지원하지 않는다. 
- 지연 계싼 프로퍼티와 위임
  - lazy 프로퍼티는 일단 초기화된 다음에는 변경되지 않는다.
  - 디폴트로 lazy 프로퍼티는 thread-safe 하다.
  - 코틀린 1.1 부터는 지역 변수에도 위임을 쓸 수 있다.
  - 위임 프로퍼티에 대해서는 스마트 캐스트를 사용할 수 없다.

### 4.4 객체

- 동반 객체의 멤버에 접근할 때는 동반 객체의 이름을 사용하지 않고 동반 객체가 들어있는 외부 클래스의 이름을 사용할 수 있다.
- 자바 static class vs 코틀린 companion object
  - 코틀린 동반 객체의 문맥은 객체 인스턴스라는 차이점이 있다.
  - 이로 인해 자바의 정적 클래스 보다 코틀린 동박 객체가 더 유연하다. 코틀린 동반 객체는 다른 상위 타입을 상속할 수도 있고, 일반 객체처럼 여기저기에 전달될 수 있기 때문이다.
  - 자바의 static 초기화 블록처럼 동반 객체 안에서도 init 블록을 사용할 수 있다.
- 객체 식
  - 명시적인 선언 없이 객체를 바로 생성할 수 있는 특별한 식. 자바 익명 클래스와 아주 비슷하다.
  - 클래스나 객체 식과 달리 객체를 함수 안에 정의할 수 없다.
  - **익명 객체 타입은 지역 선언이나 비공개 선언에만 전달될 수 있다.** 
  - 지역 함수나 클래스와 마찬가지로 객체 식도 자신을 둘러싼 코드 영역의 변수를 포획할 수 있다.
  - 지연 초기화되는 객체 선언과 달리 객체 식이 만들어내는 객체는 객체 인스턴스가 생성된 직후 바로 초기화 된다.

## 5장 고급 함수와 함수형 프로그래밍 활용하기

### 5.1 코틀린을 활용한 함수형 프로그래밍

- 함수형 언어는 함수를 일급 시민(first class)값으로 취급한다. 이 말은 함수를 다른 일반적인 타입의 값과 똑같이 취급한다는 뜻이다.
- 일급 시민이라는 말에는 변수에 값을 대입하거나 변수에서 값을 읽을 수 있고 함수에 값을 전달하거나 함수가 값을 반환할 수 있다는 뜻이 들어있다.
- 함수 타입
  - 함수 타입은 함수처럼 쓰일 수 있는 값들을 표시하는 타입이다. 문법적으로 이런 타입은 함수 시그니처(signature)와 비슷하며, 다음과 같이 두 가지 부분으로 구성된다.
    - **괄호로 둘러싸인 파라미터 타입 목록은 함숫값에 전달될 데이터의 종류와 수를 정의한다.**
    - **반환 타입은 함수 타입의 함숫값을 호출하면 돌려받게 되는 값의 타입을 정의한다.**
  - **반환값이 없는 함수라도 함수 타입에서는 반환 타입을 반드시 명시해야 한다. 따라서 이런 경우 Unit 을 반환 타입으로 사용한다.**
  - 함수 정의에서와 달리 함수 타입 표기에서는 인자 타입 목록과 반환 타입 사이를 : 이 아닌 -> 로 구분한다.
  - invoke() 메서드를 이용해서 일반 함수처럼 호출할 수 있다.
  - **코틀린 1.4 부터는 코틀린 인터페이스 앞에 fun 을 붙이면 코틀린 인터페이스를 SAM 인터페이스로 취급한다.**
    - 이 기능을 사용하면 자바의 SAM 인터페이스와 마찬가지로 코틀린 인터페이스를 람다로 인스턴스화 할 수 있다.
  - 파라미터를 타입을 둘러싼 괄호는 필수이므로 함수 타입이 파라미터를 하나만 받거나 전혀 받지 않는 경우에도 괄호를 꼭 쳐야 한다.
  - 함수 타입의 파라미터 목록에 파라미터 이름을 포함시킬 수도 있지만, 파라미터 이름은 단순히 문서화를 위한 것이며, 타입이 표현하는 함숫값에는 전혀 영향을 미치지 못한다.
- 람다와 익명 함수
  - 람다에 인자가 없으면 화살표 기호(->)를 생략할 수 있다.
  - 람다 인자가 하나인 경우에는 파라미터 목록과 화살표 기호를 생략하고, 유일한 파라미터는 미리 정해진 it 이라는 이름을 사용해 가리킬 수 있다.
  - 익명 함수와 일반 함수의 차이점
    - 익명 함수에는 이름을 지정하지 않는다. 따라서 fun 키워드 다음에 바로 파라미터 목록이 온다.
    - 람다와 마찬가지로 문맥에서 파라미터 타입을 추론할 수 있으면 파라미터 타입을 지정하지 않아도 된다.
    - 함수 정의와 달리, 익명 함수는 식이기 때문에 인자로 함수에 넘기거나 변수에 대입하는 등 일반 값처럼 쓸 수 있다.
  - **지역 함수와 마찬가지로 람다나 익명 함수도 클로저, 또는 자신을 포함하는 외부 선언에 정의된 변수에 접근할 수 있다. 특히 람다나 익명 함수도 외부 영역의 가변 변수 값을 변경할 수 있다.**
- 인라인 함수와 프로퍼티
  - 고차 함수나 함숫값을 사용하면 함수가 객체로 표현되기 때문에 성능 차원에서 부가 비용이 발생한다.
  - 익명 함수나 람다가 외부 영역의 변수를 참조하면 고차 함수에 함숫값을 넘길 때 마다 이런 외부 영역의 변수를 포획할 수 있는 구조도 만들어서 넘겨야 한다.
  - 함숫값을 호출할 때는 컴파일러가 함숫값의 정적인 타입을 알 수 없기 때문에 동적으로 가상 호출을 사용해 어떤 함수 구현을 사용할지 디스패치해야 한다. 
  - 코틀린은 함숫값을 사용할 때 발생하는 런타임 비용을 줄일 수 있는 해법으로 **인라인**(inline) 기법을 제공한다.
  - 코틀린은 비공개 코드가 외부로 노출되는 일을 방지하기 위해 인라인 함수에 비공개 멤버를 전달하는 것을 금지한다.
  - 코틀린 버전 1.1 부터는 프로퍼티 접근자를 인라인하도록 허용한다. 이 기능을 사용하면 함수 호출을 없애기 때문에 프로퍼티를 읽고 쓰는 성능을 향상시킬 수 있다.
    - 개별 getter, setter 접근자를 인라인하는 것 외에 프로퍼티 자체에 inline 변경자를 붙일 수도 있다.
    - 프로퍼티에 대한 인라인은 뒷받침하는 필드가 없는 프로퍼티에 대해서만 가능하다.
    - 프로퍼티가 공개 프로퍼티인 경우, 프로퍼티의 게터나 세터 안에서 비공개 선언을 참조하면 인라인이 불가능하다.

### 5.2 확장

- 확장 함수
  - **확장 함수 자체는 수신 객체가 속한 타입의 캡슐화를 깰 수 없다. 확장 함수는 클래스 밖에 정의된 함수이므로 수신 객체가 속한 클래스의 비공개 멤버에 접근 할 수 없다.**
  - 클래스 멤버와 확장의 시그니처가 같은 경우에는 멤버를 우선 선택함으로써 기본 클래스의 동작이 사고로 변경되는 것을 방지해준다.
  - 확장 함수는 수신 객체를 가리키는파라미터가 추가된 정적 메서드로 컴파일된다.

### 5.5 수신 객체가 있는 호출 가능 참조 

- 영역 함수
  - (식을 계산한 결과를 담을) 지역 변수를 명시적으로 선언하지 않고, 식의 값이 들어있는 암시적인 영역을 정의하는 함수를 보통 영역 함수(scope function)라고 부른다.
  - 모든 영역 함수는 인라인 함수이기 때문에 런타입 부가 비용이 없다.
  - 일반적으로 여러 영역 함수를 내포시키면 this 나 it 이 어떤 대상을 가리키는지 구분하기 어려워지므로 영역 함수를 여러 겹으로 내포시켜 사용하지 않는 편을 권장한다.
  - run 과 with 함수
    - run() 함수는 확장 람다를 받는 확장 함수이며 람다의 결과를 돌려준다. 
    - **기본적인 사용 패턴은 객체 상태를 설정한 다음, 이 객체를 대상으로 어떤 결과를 만들어내는 람다를 호출하는 것이다.**
    - with() 함수는 run() 과 상당히 비슷하다. 유일한 차이는 with()가 확장 함수 타입이 아니므로 문맥 식을 with 의 첫 번째 인자로 전달해야 한다는 점뿐이다.
      - **이 함수를 일반적으로 사용하는 경우는 문맥 식의 멤버 함수와 프로퍼티에 대한 호출을 묶어 동일한 영역 내에서 실행하는 경우다.**
  - 문맥이 없는 run
    - 이 함수는 문맥 식이 없고 람다의 값을 반환하기만 한다. 람다 자체에는 수신 객체도 없고 파라미터도 없다.
    - **주로 이 함수를 사용하는 경우는 어떤 식이 필요한 부분에서 블록을 사용하는 것이다.**
      - 어떠한 인스턴스만을 처리하기 위한 영역을 따로 만들 때 사용 할 수 있다.
    - run 은 인라인 함수이므로 람다 내부에서 바깥쪽 함수의 제어를 반환시키기 위해 return 을 사용해도 된다.
      - 그냥 블록을 사용하면 블록을 람다로 취급하기 때문에 제대로 작동하지 않는다.
  - let 함수
    - let 함수는 run 과 비슷하지만 확장 함수 타입의 람다를 받지 않고 인자가 하나뿐인 함수 타입의 람다를 받는다는 점이 다르다.
    - 따라서 문맥 식의 값은 람다의 인자로 전달된다.
    - 외부 영역에 새로운 변수를 도입하는 일을 피하고 싶을 때 주로 이 함수를 사용한다.
    - **널이 될 수 있는 값을 안전성 검사를 거쳐서 널이 될 수 없는 함수에 전달할 때 사용한다.**
    - **연산을 아규먼트 처리 후로 이동시킬 때 사용한다.**
  - apply/also 함수
    - apply() 함수는 확장 람다를 받는 확장 함수이며 자신의 수신 객체를 반환한다.
    - **이 함수는 일반적으로 run() 과 달리 반환값을 만들어내지 않고 객체의 상태를 설정하는 경우에 사용한다.**
    - **also()함수는 apply() 와 달리 인자가 하나 있는 람다를 파라미터로 받는다.**
- 클래스 멤버인 확장
  - 클래스 안에서 확장 함수나 프로퍼티를 선언하면 일반적인 멤버나 최상위 확장과 달리 이런 함수나 프로퍼티에는 **수신 객체가 두 개 있다.**
  - 이때 확장 정의의 수신 객체 타입의 인스턴스를 확장 수신 객체(extension receiver)라 부르고, 확장이 포함된 클래스 타입의 인스턴스를 디스패치 수신 객체(dispatch receiver)라 부른다.
  - 두 수신 객체를 가리킬 때는 this 앞에 클래스 이름이나 확장 이름을 붙여서 한정시킨다.
  - **수신 객체의 영역을 자신이 포함된 선언 내부로 제한하는 쪽을 더 권장한다.**

## 6장 특별한 클래스 사용하기

### 6.1 이넘(enum) 클래스

- 이넘 클래스는 미리 정의된 상수들로 이뤄진 제한된 집합을 표현하는 특별한 클래스다.
- 이넘 클래스도 일반 클래스에 허용되는 정의를 포함할 수 있다. 
  - 함수, 프로퍼티, 주생성자와 부생성자, 초기화 블록, 내부 클래스/내포된 클래스, 객체(동반 내포 객체와 일반 내포 객체)등이 포함된다.
- 이넘 클래스에 정의된 이런 요소들은 반드시 이넘 상수 목록 뒤에 와야 한다. 이런 경우에는 상수 목록과 다른 부분을 구분하기 위해 상수 목록을 세미콜론으로 끝내야 한다.
- 모든 이넘 클래스 상수에서 이넘 클래스의 본문에 정의된 멤버를 사용할 수 있다.
- 코틀린의 모든 이넘 클래스는 암시적으로 kotlin.Enum 클래스의 하위 타입이다.
  - 모든 이넘 값에는 ordinal 과 name 이라는 한 쌍의 프로퍼티가 들어있다.
  - ordinal 은 이넘 클래스 안에 정의된 이넘 값의 순서에 따른 인덱스이고, name 은 이넘 값의 이름이다.
  - 특정 이넘 클래스의 값을 이넘 본문에 있는 정의의 위치에 따라 서로 비교할 수 있다.
  - 자바와 코틀린의 이넘이 모두 Comparable 인터페이스를 암시적으로 구현하기는 하지만, 자바에서는 이넘 값에 대해 < 나 > 등의 연산을 적용할 수 없다.
  - valueOf(): 이넘 값의 이름을 문자열로 넘기면 그에 해당하는 이넘 값을 돌려주거나 이름이 잘못된 경우 예외를 던진다.
  - values(): 정의된 순서대로 모든 이넘 값이 들어있는 배열을 돌려준다. 
    - **이 메서드를 호출할 때마다 배열이 새로 생긴다는 점에 유의하라.**
    - 따라서 이 메서드에서 얻은 배열의 내용을 바꾸더라도 나머지 배열에는 영향이 없다.
  - 코틀린 1.1 부터는 values() 나 valueOf() 대신에 제네릭 최상위 메서드인 enumValues() 와 enumValueOf() 를 사용할 수도 있다.

### 6.2 데이터 클래스

- 구조 분해 선언에서 사용하지 않는 부분을 _ 로 대신할 수 있다.
- val/var 지정은 구조 분해 선언의 모든 부분에 적용된다. 따라서 모든 변수를 가변 변수로 정의하거나 모든 변수를 불변 변수로 정의해야만 하며, 둘을 섞어서 정의할 수는 없다.
- for 루프에서도 구조 분해를 사용할 수 있다.
- 코틀린 1.1 부터는 람다 파라미터에 대해 구조 분해를 사용할 수 있다.
- 현재는 지역 변수에서만 구조 분해 선언을 사용할 수 있다. 클래스 본문이나 파일의 최상위에 구조 분해를 사용할 수는 없다.

### 6.3 인라인 클래스(값 클래스)

- 코틀린 1.3 에서는 inline 이라는 키워드를 사용했지만, 자바에 값 클래스가 생겼으므로 이에 맞춰 코틀린 1.5에서는 value 로 키워다그 변경됐다.
  - 또한, JVM 백엔드를 사용하는 경우에는 @JvmInline 을 value class 앞에 반드시 붙여줘야 한다.
- 인라인 클래스의 주생성자에는 불변 프로퍼티를 하나만 선언해야 한다.
- 런타임에 클래스 인스턴스는 별도의 래퍼 객체를 생성하지 않고 이 프로퍼티의 값으로 표현된다.
- 런타임에는 호출 지점을 함수 본문으로 인라인하는 인라인 함수처럼 인라인 클래스 객체를 사용하는 위치 대신 인라인 클래스에 들어있는 값이 들어간다.
- 인라인 클래스의 프로퍼티는 상태를 포함할 수 없다. 현재 코틀린 컴파일러는 오직 한 프로퍼티만 인라인하도록 지원하기 때문이다.
  - 이 말은 뒷받침하는 필드나 lateinit 이나 (lazy 를 포함하는)위임 객체 프로퍼티를 사용할 수 없다는 뜻이다.
  - 인라인 클래스 프로퍼티는 명시적인 접근자만 허용된다.
  - 인라인 클래스의 본문에서 var 프로퍼티를 정의할 수 있지만, 인라인 클래스 내부에는 가변 상태가 없기 때문에 보통 이런 var 프로퍼티는 거의 의미가 없다.
- 초기화 블록을 쓸 수 없다. 인라인 클래스는 런타임에 어떠한 커스텀 코드도 실행할 수 없다.
- 프로그램 안에서 널이 될 수 있는 타입의 변수에 원시 값을 대입하는 등의 경우에는 암시적으로 원시 값을 박싱한다.
  - 인라인 클래스도 마찬가지다. 최적화를 위해 컴파일러는 가능하면 박싱하지 않은 값을 사용하려고 한다. 
  - 하지만 박싱하지 않은 값을 사용할 수 없는 경우, 컴파일러는 인라인되지 않는 형태로 클래스를 사용하는 편을 택한다.
- 부호 없는 정수
  - 부호 없는 정수 타입의 이름은 상응하는 부호 있는 정수 타입의 이름 앞에 U 를 덧붙인 것이다.
  - 코틀린 1.5 부터 표준 라이브러리 기능으로 정식 도입. 
  - 변수에 타입을 지정하지 않은 경우에는 크기에 따라 UInt 나 ULong 중 하나로 결정된다.
  - 부호가 있는 타입과 부호가 없는 타입은 서로 호환되지 않는다.
  - 부호가 있는 타입과 부호가 없는 타입의 값을 toXXX() 를 통해 반대쪽 타입으로 변환할 수 있다.
  
## 7장 컬렉션과 I/O 자세히 알아보기

### 7.1 컬렉션

- 컬렉션은 엘리먼트들로 이뤄진 그룹을 저장하기 위해 설계된 객체다.
- 컬렉션을 조작하는 모든 연산은 인라인 함수이기 때문에 함수 호출이나 람다 호출에 따른 부가 비용이 들지 않는다.
- 컬렉션 타입
  - 코틀린 컬렉션 타입은 기본적으로 배열, 이터러블(iterable), 시퀀스(sequence), 맵(map) 이렇게 네 가지로 분류할 수 있다.
  - 이터러블
    - **이터러블은 Iterable<T> 타입으로 표현되며, 일반적으로 즉시 계산(eager)되는 상태가 있는 컬렉션을 표현한다.**
    - 상태가 있다는 말은 컬렉션이 원소를 필요할 때 생성하는 제너레이터 함수를 유지하지 않고 원소를 저장한다는 뜻이다.
    - 즉시 계산이라는 말은 나중에 어느 필요한 시점에 원소가 초기화 되지 않고 컬렉션을 최초로 생성할 때 초기화 된다는 뜻이다.
    - **Collections 는 기본적으로 Eager evaluation 으로 동작하며, Sequences 는 Lazy evaluation 으로 동작한다..**
    - 자바와의 차이점
      - 코틀린은 불변 컬렉션과 가변 컬렉션을 구분한다.
      - **컬렉션의 변경 가능성은 컬렉션 인스턴스에 대한 참조를 저장하는 변수의 변경 가능성과 아무런 관계가 없다는 점에 유의하자.**
    - 불변 컬렉션 타입에서 유용한 특징으로는 공변성(covariance)이 있다.
      - 공변성이라는 말은 T 가 U 의 하위 타입인 경우 Iterable\<T> 도 Iterable\<U> 의 하위타입이라는 뜻이다.
      - Iterator, Collection, List, Set, Map 등과 같은 컬렉션 관련 타입의 경우에도 이런 공변성이 성립한다.
      - **가변 컬렉션의 경우에는 공변성이 성립하지 않는다. 만약 가변 컬렉션에 대해 공변성이 성립한다면, 정수를 문자열 리스트에 추가하는 것과 같은 일이 벌어질 수 있다.**
  - 컬렉션, 리스트, 집합
    - 리스트(List, MutableList)
    - HashSet: 원소 타입의 순서는 hashCode() 메서드 구현에 따라 달라진다.
    - LinkedHashSet: 해시 테이블 기반이지만 삽입 순서를 유지한다. 
    - TreeSet: 이진 검색 트리 기반이며, 어떤 비교 규칙에 따라 일관성 있는 원소 순서를 제공한다. Comparable 인터페이스를 상속해서 비교 규칙을 정의할 수 있다. 
    - 코틀린 코드에서는 java.util 패키지의 클래스를 사용할 필요가 없다. kotlin.collections 패키지에 있는 별멸을 통해 ArrayList 등과 같은 대부분의 표준 컬렉션을 쓸 수 있다.
  - 시퀀스
    - 시퀀스는 지연 계산을 가정하기 때문에 iterator() 의 의도가 이터러블과 다르다.
    - 대부분의 시퀀스 구현은 객체 초기화 시 원소를 초기화하지 않고 요청에 따라 원소를 계산한다.
    - 대부분의 시퀀스 구현은 상태가 없다. 이 말은 지연 계산한 컬렉션 원소 중에 정해진 개수의 원소만 저장한다는 뜻이다.
      - 반면 이터러블은 원소 개수에 비례해 메모리를 사용한다.
    - 코틀린 1.2 부터 표준 라이브러리는 asSequence() 를 확장 함수로 제공하며, 이 함수는 자바 스트림을 감싸서 코틀린 시퀀스로 사용하게 해준다. 
  - 맵
    - 맵 자체는 Collection 의 하위 타입이 아니지만 맵에 들어있는 원소들을 컬렉션처럼 사용할 수 있다.
    - 키-값 쌍은 Map.Entry 와 MutableMap.MutableEntry 인터페이스로 표현된다.
- Comparable 과 Comparator: 어떠한 클래스가 Comparable 을 상속하면 자동으로 <, > 등의 연산을 쓸 수 있다.
- 컬렉션 생성하기
  - listOfNotNull(): 널인 값을 걸러내고 남은 원소들로 이뤄진 새 불변 리스트를 만든다.
  - 맵 생성 함수들은 Pair 객체들로 이뤄진 가변 인자를 받기 때문에 to 중위 연산자를 사용하면 Pair 객체를 쉽게 만들 수 있다.
  - 제너레이터 함수를 바탕으로 시퀀스를 만드는 방법
    - generateSequence()
      - 시퀀스의 다음 원소를 생성해주는 파라미터가 없는 함수를 인자로 받는다.
      - 이 함수가 널을 반환할 때까지 시퀀스 원소 생성이 계속된다.
    - generateSequence()
      - 초깃값과 파라미터가 하나인 함수를 인자로 받는다.
      - 이 함수는 이전 값으로부터 다음 값을 만들어낸다.
      - 첫 번째 generateSequence() 와 마찬가지로 이 경우에도 제너레이터 함수가 다음 값으로 널을 반환하면 시퀀스가 끝난다.
    - 코틀린 1.3 부터는 특별한 빌더를 사용해 시퀀스를 만드는 방법이 추가 됐다.
      - SequenceScope 가 수신 객체 타입인 확장 람다를 받는 sequence() 함ㅅ를 통해 빌더를 구현할 수 있다.
      - yield(): 원소를 하나 시퀀스에 추가한다.
      - yieldAll(): 지정한 이터레이터, 이터러블, 시퀀스에 들어있는 모든 원소를 시퀀스에 추가한다.
- 기본 컬렉션 연산
  - 원소 인덱스를 참조해야 한다면 forEachIndexed() 함수를 쓰면 된다.
  - contains() 함수 호출을 in 연산자로 대신할 수 있다.
- 컬렉션 원소에 접근하기
  - single() 함수는 컬렉션이 비어있거나 원소가 두 개 이상이면 예외를 던진다.
  - 안전한 버전인 singleOrNull() 동일한 경우 예외 대신 널을 반환한다.
  - elementAt() 함수를 사용하면 인덱스를 사용해 컬렉션 원소를 읽을 수 있는데, 이 함수는 리스트의 get() 함수를 일반화한 함수로 배열, 이터러블, 시퀀스 등에 모두 적용할 수 있다.
    - 잘못된 인덱스에 접근 하면 예외를 던지기 때문에 elementAtOrNull() 이나 elementAtOrElse() 를 사용하자.
  - 배열이나 리스트에 대한 구조 분해를 통해 앞에서부터 최대 다섯 개의 원소를 추출할 수 있다.
    - 하지만 컬렉션에 있는 원소의 수보다 더 많은 원소를 구조 분해로 가져오려고 하면 예외가 발생한다.
- 컬렉션에 대한 조건 검사
  - all() 함수는 컬렉션의 모든 원소가 주어진 술어를 만족하면 true 를 반환한다.
  - none() 함수는 all() 과 반대다. 컬렉션에 주어진 조건을 만족하는 원소가 하나도 없을 때 true 를 반환한다.
  - any() 함수는 컬렉션 원소 중 적어도 하나가 주어진 술어를 만족할 때 true 를 반환한다.
  - 빈 컬렉션의 경우 all() 과 none() 함수는 true 를, any() 함수는 false 를 반환한다.
  - any() 와 none() 함수에는 파라미터를 전혀 받지 않은 오버로딩된 버전이 있다. 이런 함수들은 단순히 컬렉션 객체가 비어있는지만 검사한다.
- 집계
  - sumOf 를 이용해서 각 원소에 대한 연산을 합할 수 있다.
  - minByOrNull(), maxByOrNull() 함수로 비교할 수 없는 원소들로 이뤄진 컬렉션의 최대값/최솟값을 구할 수도 있다.
  - minWithOrNull() 과 maxWithOrNull() 함수는 변환 함수 대신 비교기를 받는다.
  - joinToString()
    - 컬렉션 워소를 문자열로 엮는 일을 담당한다.
    - separator: 인접한 두 원소 사이에 들어갈 구문 문자열(디폴트는 ", ")
    - prefix 와 postfix: 결과 문자열의 맨 앞과 맨 뒤에 들어갈 문자열(디폴트는 빈 문자열인 """)
    - limit: 최대로 보여줄 수 있는 원소의 개수(디폴트는 -1 로 개수 제한이 없다는 뜻임)
    - truncated: limit 가 양수인 경우, limit 범위를 넘어서는 원소를 대체해서 보여준다.
  - reduce()
    - 파라미터가 두 개인 함수를 받는다.
    - 첫 번째 인자는 누적된 값이고, 두 번째 인자는 컬렉션의 현재 값이다.
    - 집계 과정
      - 누적값은 최초에 컬렉션의 첫 번째 원소로 초기화된다.
      - 컬렉션의 매 원소에(두 번째 원소부터) 현재 누적값과 현재 원소를 파라미터로 받은 함수에 적용하고 이 함수 적용의 결과를 누적값에 대입한다. 
      - 누적의 결과를 반환한다.
    - 컬렉션이 비어 있으면 누적값을 초기화 할 수 없으므로 reduce() 함수는 예외를 던진다.
    - 집계 규칙이 원소의 인덱스에 따라 달라진다면 reduceIndexed() 를 사용할 수 있다.
      - 이 함수는 현재 인덱스를 집계 연산의 첫 번째 파라미터로 전달해준다.
  - fold()
    - 누적의 초깃값을 원하는 대로 지정하고 싶을 때 사용
    - 프로그래머가 항상 누적값의 초깃값을 지정하기 때문에 리스트가 비어있어도 fold() 는 reduce() 와 달리 예외를 발생시키지 않는다.
  - reduce()/reduceIndexed()/fold()/foldIndexed() 함수에 대해 컬렉션의 마지막 원소부터 반대 방향으로 계산을 수행해주는 함수도 있다.
    - 배열이나 리스트의 맨 뒤(오른쪽)부터 처리한다는 사실을 알려주기 위해 이런 함수의 이름 뒤에는 Right 가 붙는다.
- 걸러내기
  - 맵에서 키나 값으로만 걸러내고 싶다면 filterKeys, filterValues 를 사용하자.
  - filterNot() 함수는 조건을 부정해 걸러낼 수 있게 해준다.
  - filterIsInstance() 는 원소 중 특정 타입만 남기는 경우 사용
  - 위의 걸러내기 함수들은 호출될 때마다 새로운 불변 컬렉션을 만든다.
  - 걸러낸 결과를 이미 존재하는 가변 컬렉션에 집어 넣고 싶다면 To 로 끝나는 함수를 사용하자.
    - filterTo(), filterNotNullTo(), filterNotTo() ...
  - 주어진 술어를 만족하는 부분 컬렉션과 만족하지 않는 부분 컬렉션의 쌍으로 만들어주는 partition() 함수가 있다.
    - 맵은 partition() 을 제공하지 않는다.
- 변환
  - map() 함수를 맵에 적용 할 수도 있다.
    - 추가로 키와 값만 변환한 새 맵을 돌려주는 mapKeys() 와 mapValues() 함수도 있다.
  - flatMap(): 원래 컬렉션의 각 원소를 컬렉션으로 변환한 다음, 각 컬렉션을 차례로 이어 붙여서 한 컬렉션으로 합쳐준다.
  - flatten(): 원소가 컬렉션인 모든 컬렉션에 적용할 수 있고 각각의 컬렉션을 이어 붙인 한 컬렉션을 내놓는다.
  - 주어진 변환 함수를 바탕으로 원본 컬렉션 원소를 맵의 키나 맵의 값으로 만들 수 있는 변환
    - associateWith(): 원래 컬렉션을 키의 근원으로 사용해 새로운 맵을 만들어 준다.(배열에는 적용할 수 없다.)
    - associateBy(): 컬렉션 원소를 값으로 취급하고 변환 함수를 통해 키를 얻는다. 어떤 키에 대해 같은 값이 여럿 존재하는 경우, 오직 한 값만 반환되는 맵에 남는다.
    - associate(): 컬렉션의 원소를 사용해서 키와 값을 만들어낸다.
- 하위 컬렉션 추출
  - 배열 원소를 다른 배열로 추출하고 싶다면 sliceArray() 를 써야 한다.
  - take() 와 takeLast() 함수는 이터러블이나 배열에서 원소를 주어진 개수만큼 추출한다. 
    - take() 는 맨 앞에서부터, takeLast() 맨 뒤에서부터 개수를 센다.
  - drop() / dropLast() 함수는 take() / takeLast() 를 반전시킨 연산이라고 볼 수 있다. 이들은 주어진 개수만큼 원소를 제거한 나머지 원소들을 돌려준다.
  - 코틀린 1.2 에 추가된 chunked() 함수를 사용하면 이터러블이나 시퀀스를 주어진 개수를 넘지 않는 작은 리스트들로 나눠준다.
  - 코틀린 1.2 에 도입된 windowed() 함수를 사용하면 일정한 간격으로 청크를 연속적으로 얻어낸 슬라이딩 윈도우를 얻을 수 있다.
    - 슬라이딩 윈도우를 생성하는 규칙을 정하는 선택적인 파라미터를 지정할 수도 있다.
    - step: 서로 인접한 윈도우의 첫 번째 워소 사이의 거리(디폴트 1)
    - partialWindows: 컬렉션의 마지막 부분에서 지정한 윈도우 크기보다 작은 크기의 윈도우를 포함시킬지 여부(디폴트는 false)
  - zipWithNext(): 윈소가 두 개뿐인 윈도우를 만든다. windowed() 와 달리 리스트가 아니라 쌍(Pair)의 시퀀스나 리스트를 만들어 낸다.
- 순서: sortedDescending() 는 오름차순이 아니라 역순인 내림차순으로 원소를 정렬

### 7.2 파일과 I/O 스트림

- 스트림 유틸리티
  - Reader.readText(), Reader.readLines()
    - BufferedReader 클래스에 있는 readLine() 은 스트림에서 한 줄을 가져오지만, 두 함수는 스트림 끝까지 콘텐츠를 읽어서 전체를 한 문자열이나 각 줄을 나타내는 문자열의 리스트로 반환한다.
  - readText() 와 달리 readLines() 함수는 값을 반환하면서 스트림을 닫아준다.
  - forEachLine() 과 userLines() 함수는 줄 단위 이터레이션을 허용하고, 스트림을 자동으로 닫기 때문에 스트림을 닫는 일을 신경 쓰지 않아도 된다.
  - copyTo(): 한 스트림에서 다른 스트림으로 데이터를 전달할 수 있다. 이 함수는 이진 데이터와 텍스트 데이터를 처리하는 오버로딩된 버전이 존재한다.
- URL 유틸리티
  - URL.readText(): URL 인스턴스에 해당하는 입력 스트림의 콘텐츠를 전부 읽어온다.
  - URL.readBytes(): 입력 이진 스트림의 콘텐츠를 바이트 배열로 읽어온다.
  - **두 함수 모두 전체 스트림 콘텐츠를 읽어오는 작업이 완료될 때까지 스레드를 블럭시키므로, 큰 파일을 다운로드할 때는 이 함수를 사용하면 안 된다.**
- 파일 콘텐츠 접근하기
  - 코틀린 표준 라이브러리는 명시적으로 I/O 스트림을 쓰지 않고도 파일 콘텐츠를 읽을 수 있는 특별한 함수를 제공한다.
  - 이런 함수는 전체 파일을 읽고 쓰거나, 데이터를 기존 파일 뒤에 추가하거나, 한 줄씩 파일을 처리해야 할 때 유용하다.
  - readText(): 파일 콘텐츠 전부를 한 문자열로 읽어온다.
  - readLines(): 파일 콘텐츠 전부를 줄 구분 문자를 사용해 줄 단위로 나눠 읽어서 문자열의 리스트를 반환한다.
  - writeText(): 파일 콘텐츠를 주어진 문자열로 설정한다. 필요하면 파일을 덮어 쓴다.
  - appendText(): 주어진 문자열을 파일의 콘텐츠 뒤에 추가한다.
  - forEachLine(): 파일 전체를 읽지 않고 텍스트 콘텐츠를 한 줄씩 처리할 수 있다.
  - useLines(): 주어진 람다에 줄의 시퀀스를 전달해준다. 람다는 이렇게 받은 시퀀스를 사용해 어떤 결과를 계산하고, 이 결과는 다시 useLines() 의 결과로 반환된다.
  - 이진 파일을 처리할 때는 forEachBlock() 함수를 사용한다.
    - 디폴트 버퍼 크기는 구현에 따라 다르지만, 선택적으로 blockSize 파라미터를 지정할 수 있다.
    - 코틀린 1.3 에서 디폴트 크기는 4096 바이트 최소 크기는 512 바이트다.
- 파일 시스템 유틸리티
  - deleteRecursively()
    - 파일이나 디렉터리를 자신에게 포함된 자손들까지 포함해 쉽게 지울 수 있다.
    - 삭제가 성공하면 true, 그렇지 않으면 false 를 반환
    - 자바의 mkdirs() 메서드와 비슷하다.
  - copyTo()
    - 자신의 수신 객체를 다른 파일에 복사하고 복사본을 가리키는 파일 객체를 돌려준다.
    - 디폴트로 대상 파일을 덮어 쓰지는 않는다. 따라서 대상 파일이 이미 존재하는 경우 FileAlreadyExistsException 을 발생시킨다.
    - overwirte 파라미터를 지정할 수도 있다.
    - 디렉터리에 적용할 수도 있다. 하지만 디렉터리의 경우 하위 디렉터리나 디렉터리에 들어있는 파일을 복사하지는 않고 대상 경로에 맞춰 빈 디렉터리만 만들어 준다.
      - 디렉터리와 내용물을 모두 복사하고 싶다면 copyRecursively() 함수를 사용해야 한다.
  - copyRecursively()
    - copyTo() 와 마찬가지로 overwrite 파라미터를 통해 덮어 쓸지 여부를 정해줄 수 있다.
    - 어떤 파일을 복사하다가 IOException 이 발생하면 호출할 액션을 설정할 수도 있다.
      - 선택적인 OnError 파라미터를 통해 (File, IOException) -> OnErrorAction 타입의 람다를 넘기면 된다.
      - 람다의 결과값은 문제가 되는 파일을 어떻게 처리할지를 결정한다.
        - SKIP: 파일을 무시하고 복사를 계속 진행
        - TERMINATE: 복사를 중단.
  - walk()
    - 깊이 우선 디렉터리 구조 순회를 구현한다.
    - TOP_DOWN: 자식보다 부모를 먼저 방문(디폴트 값)
    - BOTTOM_UP: 자식을 부모보다 먼저 방문
    - walk() 대신 walkTopDown() 또는 walkBottomUp() 을 명시적으로 쓸 수도 있다.
  - onEnter() 와 onLeave() 함수는 순회가 디렉터리에 들어가거나 디렉터리에서 나올 때 호출할 동작을 지정한다.
  - createTempFile() / createTempDir() 함수를 사용해 임시 파일이나 디렉터리를 만들 수 있다.
    - createTempFile() 과 createTempDir() 은 사용 금지 예고 처리됐으며, 각각 kotlin.io.path 패키지에 있는 createTempFile() 과 crateTempDirectory() 로 대치될 예정이다. 