# 코틀린 완벽 가이드 *입문부터 활용까지, 필요한 지식 총망라!*
- *알렉세이 세두노프 저/오현석 역 | 길벗*

<br>

## 1장. 강력하고 실용적인 코틀린 

- [awesome kotlin 웹사이트(https://kotlin.link/)](https://kotlin.link/)

## 3장. 함수 정의하기

### 3.1 함수

- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
- 파라미터 앞에 val 이나 var 를 표시할 수 없다.
- **코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다.**
  - 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다.
  - 하지만 파라미터가 참조(예) 배열)라면 호출한 쪽의 데이터는 그대로 남아 있고 이 데이터에 대한 참조만 복사된다.
  - 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.
    - 예를 들어 정수 배열을 가리키는 (불변)참조를 받아서 첫 번째 원소를 변경하면, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
- 위치 기반 인자와 이름 붙은 인자
  - 코틀린 1.4 이전에는 이름 붙은 인자를 쓰기 시작하면 그 이후의 모든 인자에 이름을 붙여야 했다.
  - **1.4 부터는 이름 붙은 인자를 중간에 섞어 쓸 수 있다.**
  - 다만 이 경우에는 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리 된다.
    - 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.
- 오버로딩과 디폴트 값
  - 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다.
- vararg
  - 스프레드(spread) 연산자인 * 를 사용하면 배열을 가변 인자 대신 넘길수 있다.
  - **스프레드는 배열을 복사한다는 점의 유의하자. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.**
  - 하지만 이때 얕은(shallow)복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
  - 둘 이상을 vararg 파라미터로 선언하는 것은 금지 된다.
  - vararg 파라미터가 맨 마지막에 있는 파라미터가 아니라면, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.
    - **디폴트 값과 비슷하게 vararg 파라미터도 목록의 맨 뒤에 위치시키는 것이 좋은 코딩 스타일이다.**
  - vararg 파라미터를 이름 붙은 인자로 전달할 수는 없다. 
    - ~~~kotlin
      printSorted(items = 1, 2, 3) // error
      printSorted(items = *intArrayOf(1, 2, 3)) // ok
      ~~~
- 함수의 영역과 가시성
  - internal 변경자를 적용하면 함수가 적용된 모듈 내부에서만 함수를 사용할 수 있게 제한한다.
  - 코틀린에서 모듈은 기본적으로 함께 컴파일되는 파일 전부를 뜻한다.

### 3.3 조건문

- if 문을 식으로 사용할때는 양 가지가 모두 있어야 한다.(if/else 모두)
- Nothing 타입은 모든 코틀린 타입의 하위 타입으로 간주되기 때문에 식이 필요한 위치에 return 을 사용해도 타입 오류가 발생하지 않는다.
- 범위, 진행, 연산
  - 수 타입, Char, Boolean, String 등 모든 비교 가능한(comparable) 타입에 대해 .. 연산을 쓸 수 있다.
  - 기본적으로 <= 와 >= 를 쓸 수 있는 타입이라면 이 타입에 대해 .. 를 사용해 범위를 만들 수 있다.
  - **.. 연산에 의해 만들어지는 범위는 닫혀 있다. 즉, 시작 값과 끝 값이 범위에 포함된다.**
  - until 은 끝값은 범위에 포함되지 않는다.
  - 내장 범위 연산에서 끝 값이 시작 값보다 확실히 더 작으면 빈 범위가 된다. 
    - ~~~kotlin
      println(5 in 10..1) // false
      ~~~
  - 진행: 정해진 간격(step)만큼 떨어져 있는 정수나 Char 값들로 이뤄진 시퀀스
    - 정수나 Char 에 대해 정의된 범위는 실제로는 간격이 1인 진행이라 할 수 있다.
    - downTo: 아래로 내려가는(descending)진행을 만들 수 있다.
    - step: 진행의 간격을 지정(진행의 간격은 양수여야 한다.) 
      - ~~~kotlin
        1..10 step 3 // 1, 4, 7, 10
        15 downTo 9 step 2 // 15, 13, 11, 9
        ~~~
  - 범위를 사용하면 문자열이나 배열의 일부분을 뽑아 낼 수 있다.
    - ~~~kotlin
      "Hello, World".substring(1..4) // ello
      IntArray(10) { it*it }.sliceArray(2..5) // 4, 9, ,16, 25
      ~~~
  - 우선순위로 보면 범위 연산인 .. 는 덧셈과 중위 연산 사이에 속하며, in 과 !in 연산은 중위와 비교 연산 사이에 속한다.
- when
  - 코틀린 1.3 부터는 다음과 같이 식의 대상을 변수에 연결 할 수 있다. 이때 정의한 변수는 when 블록 내부에서만 사용할 수 있고 var 로 선언할 수는 없다.
    - ~~~kotlin
      fun readHexDigit() = when(val n = readLine()!!.toInt()) {
          in 0..9 -> '0' + n
          in 10..15 -> 'A' + n - 10
          else -> '?'
      }
      ~~~

### 3.4 루프

- 문자열과 배열에는 원소나 문자의 인덱스 범위를 제공하는 indices 라는 프로퍼티가 들어있다.
- break: 즉시 루프를 종료시키고, 실행 흐름이 루프 바로 다음 문으로 이동하게 만든다.
- continue: 현재 루프 이터레이션(iteration)을 마치고 조건 검사로 바로 진행하게 만든다.
- **코틀린에서는 함수에 tailrec 을 붙이면 컴파일러가 재귀 함수를 비재귀적인 코드로 자동으로 변환해준다.**

## 4장 클래스와 객체 다루기

### 4.1 클래스 정의하기 

- 클래스에 주생성자를 선언하지 않은 경우, 모든 부생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 init 블록을 실행한다. 
  - 이렇게 하면 어떤 부생성자를 호출하든지 공통적인 초기화 코드가 정확히 한 번만 실행되게 보장할 수 있다.
- 생성자 파라미터 목록 뒤에 콜론(:)을 넣고 그 뒤에 일반 함수를 호출하는 것처럼 코드를 작성하되, 함수 이름 대신 this 를 사용하면 생성자 위임 호출이 된다.
- 부생성자의 파라미터 목록에는 val/var 키워드를 쓸 수 없다.
- 코틀린에는 자바의 패키지 전용에 해당하는 가시성이 없다.
- 주생성자의 가시성을 지정하려면 constructor 키워드를 꼭 명시해야 한다.
  - ~~~kotlin
    class Person private constructor(val test: String)
    ~~~
- 내포된 클래스(nested class)
  - 내포된 클래스는 내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.
  - **자바와 달리, 바깥쪽 클래스는 자신에게 내포된 클래스의 비공개 멤버에 접근할 수 없다.**
    - 내포된 클래스에 inner 를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.
  - 일반적으로 this 는 항상 가장 내부의 클래스 인스턴스를 카리킨다. 내부 클래스 본문에서 외부 클래스 인스턴스를 가리켜야 한다면
  한정시킨 this 식을 사용해야 한다. 한정시킨 this 식에서 @ 기호 다음에 오는 식별자는 외부 클래스의 이름이다. (예) this@Person)
- 지역 클래스
  - 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획할 수 있고, 심지어는 변경할 수도 있다.
  - 하지만 코틀린이 제공하는 포획 변수를 변경하는 기능은 그에 따른 비용을 수반한다. 컴파일러는 공유되는 값을 특별한 래퍼 객체로 둘러싼다.
  - 불변 변수는 값이 바뀌지 않기 때문에 래퍼가 필요 없으므로 이런 부가 비용이 없다.
  - 내포된 클래스와 달리 지역 클래스에는 가시성 변경자를 붙일 수 없다. 지역 클래스의 영역은 항상 자신을 둘러싼 블록으로 제한된다.
  - 지역 클래스에 내포된 클래스는 반드시 inner 클래스여야만 한다.

### 4.2 널 가능성

- 스마트 캐스트는 when 이나 루프 같은 조건 검사가 들어가는 다른 문이나 식 안에서도 작동한다.
- **널 검사와 사용 지점 사이에서 값이 변경되는 경우에는 스마트 캐스트가 작동하지 않는다.**
  - (객체의) 가변 프로퍼티에 대해서는 절대 스마트 캐스트를 적용할 수 없다. 언제든 코드의 다른 부분에서 프로퍼티 값을 바꿀 수 있기 때문이다.

### 4.3 단순한 변수 이상인 프로퍼티

- 커스텀 접근자
  - 프로퍼티 값을 읽거나 쓸 때 호출되는 특별한 함수
  - get() 함수에는 파라미터가 없다.
  - get() 함수의 반환 타입은 프로퍼티의 타입과 같아야 한다.
  - 커스텀 접근자는 뒷받침하는 필드가 없기 때문에 클래스 인스턴스에서 전혀 메모리를 차지하지 않는다. 대신 프로퍼티를 읽을 때마다 매번 다시 계산하여 결과를 리턴한다.
  - 필드 참조는 field 라는 키워드를 사용하며 접근자의 본문 안에서만 유용하다.
  - **공식 코틀린 코딩 관습은 값을 계산하는 과정에서 예외가 발생할 여지가 없거나, 값을 계산하는 비용이 충분히 싸거나, 값을 캐시해 두거나, 클래스 인스턴스의
  상태가 바뀌기 전에는 여러번 프로퍼티를 읽거나, 함수를 호출해도 항상 똑같은 결과를 내는 경우에는 함수보다 프로퍼티를 사용하는 쪽을 권장한다.**
  - 프로퍼티 세터의 파라미터는 단 하나이며, 타입은 프로퍼티 자체의 타입과 같아야 한다.
    - 보통은 파라미터 타입을 항상 미리 알 수 있기 때문에 세터에서는 파라미터 타입을 생략한다.
    - 관습적으로 파라미터 이름을 value 로 정하는 경우가 많지만 원하는 다른 이름을 붙여도 좋다.
  - lateinit 프로퍼티의 경우 항상 자동으로 접근자가 생성되기 때문에 프로그래머가 직접 커스텀 접근자를 정의할 수 없다.
  - 주생성자 파라미터로 선언된 프로퍼티에 대한 접근자도 지원하지 않는다. 
- 지연 계싼 프로퍼티와 위임
  - lazy 프로퍼티는 일단 초기화된 다음에는 변경되지 않는다.
  - 디폴트로 lazy 프로퍼티는 thread-safe 하다.
  - 코틀린 1.1 부터는 지역 변수에도 위임을 쓸 수 있다.
  - 위임 프로퍼티에 대해서는 스마트 캐스트를 사용할 수 없다.

### 4.4 객체

- 동반 객체의 멤버에 접근할 때는 동반 객체의 이름을 사용하지 않고 동반 객체가 들어있는 외부 클래스의 이름을 사용할 수 있다.
- 자바 static class vs 코틀린 companion object
  - 코틀린 동반 객체의 문맥은 객체 인스턴스라는 차이점이 있다.
  - 이로 인해 자바의 정적 클래스 보다 코틀린 동박 객체가 더 유연하다. 코틀린 동반 객체는 다른 상위 타입을 상속할 수도 있고, 일반 객체처럼 여기저기에 전달될 수 있기 때문이다.
  - 자바의 static 초기화 블록처럼 동반 객체 안에서도 init 블록을 사용할 수 있다.
- 객체 식
  - 명시적인 선언 없이 객체를 바로 생성할 수 있는 특별한 식. 자바 익명 클래스와 아주 비슷하다.
  - 클래스나 객체 식과 달리 객체를 함수 안에 정의할 수 없다.
  - **익명 객체 타입은 지역 선언이나 비공개 선언에만 전달될 수 있다.** 
  - 지역 함수나 클래스와 마찬가지로 객체 식도 자신을 둘러싼 코드 영역의 변수를 포획할 수 있다.
  - 지연 초기화되는 객체 선언과 달리 객체 식이 만들어내는 객체는 객체 인스턴스가 생성된 직후 바로 초기화 된다.