# 코틀린 완벽 가이드 *입문부터 활용까지, 필요한 지식 총망라!*
- *알렉세이 세두노프 저/오현석 역 | 길벗*

<br>

## 1장. 강력하고 실용적인 코틀린 

- [awesome kotlin 웹사이트(https://kotlin.link/)](https://kotlin.link/)

## 3장. 함수 정의하기

### 3.1 함수

- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
- 파라미터 앞에 val 이나 var 를 표시할 수 없다.
- **코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다.**
  - 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다.
  - 하지만 파라미터가 참조(예) 배열)라면 호출한 쪽의 데이터는 그대로 남아 있고 이 데이터에 대한 참조만 복사된다.
  - 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.
    - 예를 들어 정수 배열을 가리키는 (불변)참조를 받아서 첫 번째 원소를 변경하면, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
- 위치 기반 인자와 이름 붙은 인자
  - 코틀린 1.4 이전에는 이름 붙은 인자를 쓰기 시작하면 그 이후의 모든 인자에 이름을 붙여야 했다.
  - **1.4 부터는 이름 붙은 인자를 중간에 섞어 쓸 수 있다.**
  - 다만 이 경우에는 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리 된다.
    - 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.
- 오버로딩과 디폴트 값
  - 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다.
- vararg
  - 스프레드(spread) 연산자인 * 를 사용하면 배열을 가변 인자 대신 넘길수 있다.
  - **스프레드는 배열을 복사한다는 점의 유의하자. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.**
  - 하지만 이때 얕은(shallow)복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
  - 둘 이상을 vararg 파라미터로 선언하는 것은 금지 된다.
  - vararg 파라미터가 맨 마지막에 있는 파라미터가 아니라면, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.
    - **디폴트 값과 비슷하게 vararg 파라미터도 목록의 맨 뒤에 위치시키는 것이 좋은 코딩 스타일이다.**
  - vararg 파라미터를 이름 붙은 인자로 전달할 수는 없다. 
    - ~~~kotlin
      printSorted(items = 1, 2, 3) // error
      printSorted(items = *intArrayOf(1, 2, 3)) // ok
      ~~~
- 함수의 영역과 가시성
  - internal 변경자를 적용하면 함수가 적용된 모듈 내부에서만 함수를 사용할 수 있게 제한한다.
  - 코틀린에서 모듈은 기본적으로 함께 컴파일되는 파일 전부를 뜻한다.

### 3.3 조건문

- if 문을 식으로 사용할때는 양 가지가 모두 있어야 한다.(if/else 모두)
