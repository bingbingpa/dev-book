# 코틀린 완벽 가이드 *입문부터 활용까지, 필요한 지식 총망라!*
- *알렉세이 세두노프 저/오현석 역 | 길벗*

<br>

## 1장. 강력하고 실용적인 코틀린 

- [awesome kotlin 웹사이트(https://kotlin.link/)](https://kotlin.link/)

## 3장. 함수 정의하기

### 3.1 함수

- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.
- 파라미터 앞에 val 이나 var 를 표시할 수 없다.
- **코틀린은 값에 의한 호출(call-by-value) 의미론을 사용한다. 이 말은 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻이다.**
  - 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다.
  - 하지만 파라미터가 참조(예) 배열)라면 호출한 쪽의 데이터는 그대로 남아 있고 이 데이터에 대한 참조만 복사된다.
  - 따라서 파라미터 자체는 함수 내부에서 바뀔 수 없지만, 일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.
    - 예를 들어 정수 배열을 가리키는 (불변)참조를 받아서 첫 번째 원소를 변경하면, 그에 따라 호출하는 쪽의 데이터도 영향을 받는다.
- 위치 기반 인자와 이름 붙은 인자
  - 코틀린 1.4 이전에는 이름 붙은 인자를 쓰기 시작하면 그 이후의 모든 인자에 이름을 붙여야 했다.
  - **1.4 부터는 이름 붙은 인자를 중간에 섞어 쓸 수 있다.**
  - 다만 이 경우에는 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리 된다.
    - 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.
- 오버로딩과 디폴트 값
  - 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다.
- vararg
  - 스프레드(spread) 연산자인 * 를 사용하면 배열을 가변 인자 대신 넘길수 있다.
  - **스프레드는 배열을 복사한다는 점의 유의하자. 따라서 파라미터 배열의 내용을 바꿔도 원본 원소에는 영향을 미치지 않는다.**
  - 하지만 이때 얕은(shallow)복사가 이뤄진다. 즉, 배열 내부에 참조가 들어있는 경우에는 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유된다.
  - 둘 이상을 vararg 파라미터로 선언하는 것은 금지 된다.
  - vararg 파라미터가 맨 마지막에 있는 파라미터가 아니라면, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.
    - **디폴트 값과 비슷하게 vararg 파라미터도 목록의 맨 뒤에 위치시키는 것이 좋은 코딩 스타일이다.**
  - vararg 파라미터를 이름 붙은 인자로 전달할 수는 없다. 
    - ~~~kotlin
      printSorted(items = 1, 2, 3) // error
      printSorted(items = *intArrayOf(1, 2, 3)) // ok
      ~~~
- 함수의 영역과 가시성
  - internal 변경자를 적용하면 함수가 적용된 모듈 내부에서만 함수를 사용할 수 있게 제한한다.
  - 코틀린에서 모듈은 기본적으로 함께 컴파일되는 파일 전부를 뜻한다.

### 3.3 조건문

- if 문을 식으로 사용할때는 양 가지가 모두 있어야 한다.(if/else 모두)
- Nothing 타입은 모든 코틀린 타입의 하위 타입으로 간주되기 때문에 식이 필요한 위치에 return 을 사용해도 타입 오류가 발생하지 않는다.
- 범위, 진행, 연산
  - 수 타입, Char, Boolean, String 등 모든 비교 가능한(comparable) 타입에 대해 .. 연산을 쓸 수 있다.
  - 기본적으로 <= 와 >= 를 쓸 수 있는 타입이라면 이 타입에 대해 .. 를 사용해 범위를 만들 수 있다.
  - **.. 연산에 의해 만들어지는 범위는 닫혀 있다. 즉, 시작 값과 끝 값이 범위에 포함된다.**
  - until 은 끝값은 범위에 포함되지 않는다.
  - 내장 범위 연산에서 끝 값이 시작 값보다 확실히 더 작으면 빈 범위가 된다. 
    - ~~~kotlin
      println(5 in 10..1) // false
      ~~~
  - 진행: 정해진 간격(step)만큼 떨어져 있는 정수나 Char 값들로 이뤄진 시퀀스
    - 정수나 Char 에 대해 정의된 범위는 실제로는 간격이 1인 진행이라 할 수 있다.
    - downTo: 아래로 내려가는(descending)진행을 만들 수 있다.
    - step: 진행의 간격을 지정(진행의 간격은 양수여야 한다.) 
      - ~~~kotlin
        1..10 step 3 // 1, 4, 7, 10
        15 downTo 9 step 2 // 15, 13, 11, 9
        ~~~
  - 범위를 사용하면 문자열이나 배열의 일부분을 뽑아 낼 수 있다.
    - ~~~kotlin
      "Hello, World".substring(1..4) // ello
      IntArray(10) { it*it }.sliceArray(2..5) // 4, 9, ,16, 25
      ~~~
  - 우선순위로 보면 범위 연산인 .. 는 덧셈과 중위 연산 사이에 속하며, in 과 !in 연산은 중위와 비교 연산 사이에 속한다.
- when
  - 코틀린 1.3 부터는 다음과 같이 식의 대상을 변수에 연결 할 수 있다. 이때 정의한 변수는 when 블록 내부에서만 사용할 수 있고 var 로 선언할 수는 없다.
    - ~~~kotlin
      fun readHexDigit() = when(val n = readLine()!!.toInt()) {
          in 0..9 -> '0' + n
          in 10..15 -> 'A' + n - 10
          else -> '?'
      }
      ~~~

### 3.4 루프

- 문자열과 배열에는 원소나 문자의 인덱스 범위를 제공하는 indices 라는 프로퍼티가 들어있다.
- break: 즉시 루프를 종료시키고, 실행 흐름이 루프 바로 다음 문으로 이동하게 만든다.
- continue: 현재 루프 이터레이션(iteration)을 마치고 조건 검사로 바로 진행하게 만든다.
- **코틀린에서는 함수에 tailrec 을 붙이면 컴파일러가 재귀 함수를 비재귀적인 코드로 자동으로 변환해준다.**

