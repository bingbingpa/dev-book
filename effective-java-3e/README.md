# 이펙티브 자바 Effective Java 3/E
- *조슈아 블로크 저/개앞맵시 역 | 인사이트(insight) |*

<br>

## 아이템 목록
#### [[아이템1] 생성자 대신 정적 팩터리 메서드를 고려하라](#아이템1-생성자-대신-정적-팩터리-메서드를-고려하라-1)
#### [[아이템2] 생성자에 매개변수가 많다면 빌더를 고려하라](#아이템2-생성자에-매개변수가-많다면-빌더를-고려하라-1)
#### [[아이템3] private 생성자나 열거 타입으로 싱글턴임을 보증하라](#아이템3-private-생성자나-열거-타입으로-싱글턴임을-보증하라-1)
#### [[아이템4] 인스턴스화를 막으려거든 private 생성자를 사용하라](#아이템4-인스턴스화를-막으려거든-private-생성자를-사용하라-1)
#### [[아이템5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라](#아이템5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라-1)
#### [[아이템6] 불필요한 객체 생성을 피하라](#아이템6-불필요한-객체-생성을-피하라-1)
#### [[아이템7] 다 쓴 객체 참조를 해제하라](#아이템7-다-쓴-객체-참조를-해제하라-1)
#### [[아이템8] finalizer 와 cleaner 사용을 피하라](#아이템8-finalizer-와-cleaner-사용을-피하라-1)
#### [[아이템9] try-finally 보다는 try-with-resources 를 사용하라](#아이템9-try-finally-보다는-try-with-resources-를-사용하라-1)
#### [[아이템10] equals 는 일반 규약을 지켜 재정의하라](#아이템10-equals-는-일반-규약을-지켜-재정의하라-1)
#### [[아이템11] equals 를 재정의하려거든 hashCode 도 재정의하라](#아이템11-equals-를-재정의하려거든-hashCode-도-재정의하라-1)
#### [[아이템12] toString 을 항상 재정의하라](#아이템12-toString-을-항상-재정의하라-1)
#### [[아이템13] clone 재정의는 주의해서 진행하라](#아이템13-clone-재정의는-주의해서-진행하라-1)
#### [[아이템14] Comparable 을 구현할지 고려하라](#아이템14-Comparable-을-구현할지-고려하라-1)
#### [[아이템15] 클래스와 멤버의 접근 권한을 최소화하라](#아이템15-클래스와-멤버의-접근-권한을-최소화하라-1)
#### [[아이템16] public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#아이템16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라-1)
#### [[아이템17] 변경 가능성을 최소화하라](#아이템17-변경-가능성을-최소화하라-1)
#### [[아이템18] 상속보다는 컴포지션을 사용하라](#아이템18-상속보다는-컴포지션을-사용하라-1)
#### [[아이템19] 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라](#아이템19-상속을-고려해-설계하고-문서화하라-그러지-않았다면-상속을-금지하라-1)
#### [[아이템20] 추상 클래스보다는 인터페이스를 우선하라](#아이템20-추상-클래스보다는-인터페이스를-우선하라-1)
#### [[아이템21] 인터페이스는 구현하는 쪽을 생각해 설계하라](#아이템21-인터페이스는-구현하는-쪽을-생각해-설계하라-1)
#### [[아이템22] 인터페이스는 타입을 정의하는 용도로만 사용하라](#아이템22-인터페이스는-타입을-정의하는-용도로만-사용하라-1)
#### [[아이템23] 태그 달린 클래스보다는 클래스 계층구조를 활용하라](#아이템23-태그-달린-클래스보다는-클래스-계층구조를-활용하라-1)
#### [[아이템24] 멤버 클래스는 되도록 static 으로 만들라](#아이템24-멤버-클래스는-되도록-static-으로-만들라-1)
#### [[아이템25] 톱레벨 클래스는 한 파일에 하나만 담아라](#아이템25-톱레벨-클래스는-한-파일에-하나만-담아라-1)
#### [[아이템26] 로 타입은 사용하지 말라](#아이템26-로-타입은-사용하지-말라-1)
#### [[아이템27] 비검사 경고를 제거하라](#아이템27-비검사-경고를-제거하라-1)
#### [[아이템28] 배열보다는 리스트를 사용하라](#아이템28-배열보다는-리스트를-사용하라-1)

<br>

## 2장 객체 생성과 파괴
### [아이템1] 생성자 대신 정적 팩터리 메서드를 고려하라
- 클래스 생성자와 별도로 정적 팩터리 메서드(static factory method) 를 제공할 수 있다. 
    ~~~ java
    public static Boolean valueOf(boolean b) {
        retrun b ? Boolean.TRUE : Boolean.FALSE;
    }
    ~~~
- 정적 팩터리 메서드가 생성자 보다 좋은 장점 다섯 가지
    - 이름을 가질 수 있다. 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
    - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
        - 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다.
    - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        - 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 **엄청난 유연성**을 선물한다.
        - API 를 만들때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API 를 작게 유지할 수 있다.
    - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 정적 팩터리 메서드 단점
    - 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 패터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 정적 팩터리 메서드 명명 방식
    - from: 매개 변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
        ~~~ java
        Date d = Date.from(instant);
        ~~~
    - of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
        ~~~ java
        Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
        ~~~
    - valueOf: from 과 of 의 더 자세한 버전
        ~~~ java
        BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
        ~~~
    - instance 혹은 getInstance: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
        ~~~ java
        StackWalker luke = StackWalker.getInstance(options);
        ~~~
    - create 혹은 newInstance: instance 혹은 getInstance 와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
        ~~~ java
        Object newArray = Array.newInstance(clssObject, arrayLen);
        ~~~
    - getType: getInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type" 은 팩터리 메서드가 반환할 객체의 타입이다.
        ~~~ java
        FileStore fs = Files.getFileStore(path);
        ~~~
    - newType: newInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type" 은 팩터리 메서드가 반환할 객체의 타입이다.
        ~~~ java
        BufferedReader br = Files.newBufferedReader(path);
        ~~~
    - type: getType 과 newType 의 간결한 버전
        ~~~ java
        List<Complaint> litany = Collections.list(legacyLitany);
        ~~~
- **핵심 정리**
    - 정적 팩터리 메서드와 public 생성자는 각각의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가
    더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

### [아이템2] 생성자에 매개변수가 많다면 빌더를 고려하라
- 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 클라이언트가 실수로 매개변수의 순서를 바꿔 건네줘도 컴파일러는 알아채지 못하고, 결국 런타임에 엉뚱한 동작을 하게 된다.
- 자바빈즈패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓이게 된다.
- **자바빈즈패턴에서는 클래스를 불변(아이템17)으로 만들수 없다.**
- 빌더 패턴은 명명된 선택적 매개변수(named optional parameters) 를 흉내 낸 것이다.
- 빌대 퍼턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.
- **핵심 정리**
    - 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.
    - 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.

### [아이템3] private 생성자나 열거 타입으로 싱글턴임을 보증하라
- **클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.**
- 필드 방식의 싱글턴
    - 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.
    - 리플렉션을 이용하지 않고는 클라이언트는 손 쓸 방법이 없다.
- 정적 팩터리 방식의 싱글턴
    - API 를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
    - 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.(아이템30)
    - 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다.
- 열거 타입 방식의 싱글턴
    - **대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.**
    - 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.(얼거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있다.)

### [아이템4] 인스턴스화를 막으려거든 private 생성자를 사용하라
- **추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.** 하위 클래스를 만들어 인스턴스화하면 그만이다.
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

### [아이템5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 정적 유틸리티나 싱글턴을 잘못 사용하면 유연하지 않고 테스트하기 어렵다.
- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
- 이러한 자원들을 클래스가 직접 만들게 해서도 안 된다.
- 대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 
**의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.**
  
### [아이템6] 불필요한 객체 생성을 피하라
- 다음 코드는 하지 말아야 할 극단적인 예시이다. 이 문장은 실행될 때 마다 String 인스턴스를 새로 만든다. 이 문장이 반복문이나 빈번히 호출되는 메서드 안에 
있다면 쓸데 없는 String 인스턴스가 수백만 개 만들어 질 수도 있다.
    ~~~ java
    String s = new String("bikini");
    ~~~
- 다음과 같이 개선된 코드는 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.
또한 이 방식을 사용한다면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.
    ~~~ java
    String s = "bikini";
    ~~~
- 생성 비용이 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용할 필요가 있다.
- **String.matches 는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.**
- 성능을 개선하려면 필요한 정규표현식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고 재사용한다.
- **오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.**
- **박싱된 기본 타입보다는 기본 타입(primitive type)을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.**

### [아이템7] 다 쓴 객체 참조를 해제하라
- 가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾기가 까다롭다. 객체 참조 호나를 살려두면 가비지 컬렉트는 그 책체뿐만 아니라
그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체..)를 회수해가지 못한다.
- 해법은 해당 참조를 다 썼을 때 null 처리(참조 해제)를 하는 것이다.
- **객체 참조를 null 처리 하는 일은 예외적인 경우여야 한다.**
- 비활성 영역이 되는 순간 null 처리해서 해당 객체를 더는 쓰지 않을 것임을 가비지 컬렉터에 알려야 한다.

### [아이템8] finalizer 와 cleaner 사용을 피하라
- 자바의 두 가지 객체 소멸자 
    - finalizer: 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 자바 9에서는 deprecated API 로 지정되었다.
    - cleaner: finalizer 의 대안으로 소개 되었다. finalizer 보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- finalizer 와 cleaner 는 즉시 수행된다는 보장이 없다.
- System.gc 나 System.runFinalization 은 finalizer 와 cleaner 가 실행될 가능성을 높여줄 수는 있으나, 보장해주진 않는다.
- finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.
- **finalizer 와 cleaner 는 심각한 성능 문제도 동반한다.**
- **finalizer 를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.**
- **종료해야 할 자원을 담고 있는 객체의 클래스는 AutoCloseable 을 구현**해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.
- finalizer 와 cleaner 의 적절한 쓰임새 2가지
    - 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할
    - 네이티브 피어(native peer)와 연결된 객체.
        - 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다.
        - 네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알지 못한다.
        - 단, 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당 된다. 성능 저하를 감당할 수 없거나 네이티브 피어가 사용하는 자원을
    즉시 회수해야 한다면 AutoCloseable 을 구현하고 close 메서드를 사용해야 한다.
- 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖게 된다.

### [아이템9] try-finally 보다는 try-with-resources 를 사용하라
- 꼭 회수해야 하는 자원을 다룰 때는 try-finally 말고, try-with-resources 를 사용하자. 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다.

<br>

## 3장 모든 객체의 공통 메서드
- Object 에서 final 이 아닌 메서드(equals, hashCode, toString, clone, finalize) 는 모두 overriding 을 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있다.
- 즉, 모든 클래스는 이 메서드들을 일반 규약에 맞게 재정의해야 한다. 메서드를 잘못 구현하면 대상 클래스가 이 규약을 준수한다고 가정하는 클래스(hashMap 과 HashSet 등)를 오동작하게 만들 수 있다.
### [아이템10] equals 는 일반 규약을 지켜 재정의하라
- equals 를 재정의하지 않아도 되는 경우
    - 각 인스턴스가 본질적으로 고유한 경우. 값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. Thread 가 좋은 예이다.
    - 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없는 경우.
    - 상위 클래스에서 재정의한 equal 가 하위 클래스에도 딱 들어 맞는 경우. List 구현체들은 AbstractList 로부터, Map 구현체들은 AbstractMap 으로부터 상속받아 그대로 쓴다.
    - 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없는 경우.
    - 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스. Enum 같은 경우.
- equals 를 재정의 해야하는 경우
    - 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals 가 논리적 동치성을 비교하도록 재정의되지 않았을 경우. 주로 값 클래스들이 여기 해당한다.
    - 값 클래스란 Integer, String 처럼 값을 표현하는 클래스를 말한다.
- **equals 메서드를 재정의 할때 반드시 지켜야 하는 일반 규약** 
    - 반사성: 단순히 말하면 객체는 자기 자신과 같아야 한다.
    - 대칭성: 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.
    - 추이성: 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
    - 일관성: 두 객체가 같다면(어느 하나 혹은 두 객체 모두가 수정되지 않는 한) 앞으로도 영원히 같아야 한다.
    - null-아님: 모든 객체가 null 과 같지 않아야 한다.
- **equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알수 없다.**
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
- **equals 의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.**
- **양질의 equals 메서드 구현 방법**
    - == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
    - instanceof 연산자로 입력이 올바른 타입인지 확인한다.
    - 입력을 올바른 타입으로 형변환한다.
    - 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
- float 와 double 을 제외한 기본 타입 필드는 == 연산자로 비교하고, 참조 타입 필드는 각각의 equals 메서드로, float 와 double 필드는 가각 정적 메서드인
Float.compare(float, float), Double.compare(double, double) 로 비교한다.
- **float 와 double 을 특별 취급하는 이유는 Float.Nan, -0.0f, 특수한 부동소수 값등을 다뤄야 하기 때문이다.**
  
### [아이템11] equals 를 재정의하려거든 hashCode 도 재정의하라
- **equals 를 재정의한 클래스 모두에서 hashCode 도 재정의 해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap, HashSet 
같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.**
- 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.
- HashMap 은 해시코드가 다른 엔트리끼리는 동치성 비교를 시도조차 하지 않도록 최적화 되어 있다.
- Objects.hash() 메서드는 성능에 민감하지 않은 상황에서만 사용해야 한다.
- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다. 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어 뜨릴 수도 있다.

### [아이템12] toString 을 항상 재정의하라 
- toString 을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
- 포맷을 명시하든 아니든 구현하는 클래스의 의도를 명확히 밝혀야 한다.
- toString 이 반환한 값에 포한된 정보를 얻어올 수 있는 API 를 제공하자.
- 정적 유틸리티 클래스는 toString 을 제공할 이유가 없다. 
- 열거 타입도 자바가 이미 완벽한 toString 을 제공하니 따로 재정의하지 않아도 된다.

### [아이템13] clone 재정의는 주의해서 진행하라
- clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone 은 원 본 객체에 아무런 해를 끼치치 않는 동시에 복제된 객체의 불면식을 보장해야 한다.
- 새로운 인터페이스를 만들 때는 절대 Cloneable 을 확장해서는 안 되며, 새로운 클래스도 이를 구현해서는 안 된다. final 클래스라면 Cloneable 을 구현해도 
위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다. 
- 기본 원칙은 복제 기능은 생성자와 팩터리를 이용하는 게 최고다!
- 단, 배열만은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외라 할 수 있다.

### [아이템14] Comparable 을 구현할지 고려하라
- HashSet: 순서에 상관없이 반환
- LinkedHashSet: 입력한 순서대로 반환
- TreeSet: 자연적 순서(역순으로 바꿀수도 있다.)
- compareTo 는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다.
- **알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.**
- compareTo 규약
    - 두 객체 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다.
    - 첫번째가 두번째보다 크고 두번째가 세번째보다 크면, 첫 번째는 세번째보다 커야 한다.
    - 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다.(compareTo 메서드로 수행한 동치성 테스트의 결과가 equals 와 같아야 한다.)
- compareTo 메서드에서 필드의 값을 비교할 때 < 와 > 연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나
Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.

<br>

## 4장 클래스와 인터페이스
### [아이템15] 클래스와 멤버의 접근 권한을 최소화하라
- **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**
- 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준
    - private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
    - package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다.
      (단, 인터페이스의 멤버는 기본적으로 public 이 적용된다.)
    - protected: package-private 의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있지만 제약이 조금 따른다.
    - public: 모든 곳에서 접근할 수 있다.
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정 할 수 없다. 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로
대체해 사용할 수 있어야 한다는 규칙(리스코프 치환 원칙)을 지키기 위해 필요하다.
- public 클래스의 인스턴스 필드는 되도록 public 이 아니여야 한다.(아이템16)
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
- **public 가변 필드를 갖는 클래스는 일반적으로 thread safe 하지 않다.**
- **클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.**
이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 된다.
    - 해결책 두 가지
        - public 배열을 private 으로 만들고 public 불변 리스트를 추가한다.
            ~~~ java
            private static final Thing[] PRIVATE_VALUES = {...}
            public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
            ~~~
        - 배열을 private 으로 만들고 그 복사본을 반환하는 public 메서드를 추가한다.(방어적 복사)
            ~~~ java
            private static final Thing[] PRIVATE_VALUES = {...}
            public static final Thing[] values() {
                return PRIVATE_VALUES.clone();
            }
            ~~~

### [아이템16] public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- **패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공**함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
- public 클래스의 빌드가 불변이라면 직접 노출할 때의 단점이 조금은 줄어들지만, 여전히 결코 좋은 생각이 아니다.

### [아이템17] 변경 가능성을 최소화하라
- 불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal 이 여기 속한다.
- **클래스를 불변으로 만들기 위한 다섯 가지 규칙**
    - 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
    - 클래스를 확장할 수 없도록 한다.
    - 모든 필드를 final 로 선언한다.
    - 모든 필드를 private 으로 선언한다.
    - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 생성자, 접근다 readObject 메서드 모두에서 **방어적 복사**를 수행하라.
- **불변 객체는 단순하다.** 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
- **불변 객체는 근본적으로 thread safe 하여 따로 동기화할 필요가 없다.** 그래서 불변 객체는 안심하고 공유할 수 있다.
- 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
- 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야 하는데 가장 쉬운 방법은 final 클래스로 선언하는 것이지만, 조금 더 유연하게 하려면
모든 생성자를 private 만들고 public 정적 팩토리를 제공하는 하는 것이 좋다.
- 게터(getter)가 있다고 해서 무조건 세터(setter)를 만들지 말자.
- **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.**
- **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.** 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 
메서드도 public 으로 제공해서는 안 된다.
  
### [아이템18] 상속보다는 컴포지션을 사용하라
- **메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.** 다르게 말하면, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 상속을 사용했을 때 발생 할 수 있는 문제점
    - 상위 클래스에 있는 기능을 재정의 했을 경우 예기치 못한 오류가 발생할 수 있다.(예: HashSet 의 addAll 을 재정의한 경우)
    - 상위 클래스 스펙이 변경 되면서 하위 클래스에서 정의한 메서드와 시그니처가 같고 반환 타입은 다른 경우.
- 기존 클래스를 확장하는 상속 대신 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. 기존 클래스가 새로운 클래스의 구성요소로 
쓰인다는 뜻에서 이러한 설계를 컴포지션(composition:구성)이라 한다. 
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.하지만 하위 클래스의 패키지가 상위 클래스와 다르고,
상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.

### [아이템19] 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- **상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다. 
- Cloneable 과 Serializable 인터페이스 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.
- 상속을 금지하는 두 가지 방법
    - 클래스를 final 로 선언한다.
    - 모든 생성자를 private 나 package-private 로 선언하고 public 정적 팩터리를 만들어준다.
    
### [아이템20] 추상 클래스보다는 인터페이스를 우선하라
- **인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.**
    - 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 
- 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다. 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.
- 인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 프로그래머의 일감을 덜어줄 수 있다.
- **인터페이스는 인스턴스 필드를 가질 수 없고 public 아닌 정적 멤버도 가질 수 없다.(단, private 정적 메서드는 예외다.)**
- **인터페이스는 equals 와 hashCode 같은 Object 의 메서드를 디폴트 메서드로 제공하면 안된다**
- 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취할 수도 있다.(템플릿 메서드 패턴)
    - 관례상 인터페이스 이름이 Interface 라면 그 골격 구현 클래스의 이름은 AbstractInterface 로 짓는다.
    - 컬렉션 프레임워크의 AbstractCollection, AbstractSet, AbstractList, AbstractMap 각각이 바로 핵심 컬렉션 인터페이스의 골격 구현이다.
    
### [아이템21] 인터페이스는 구현하는 쪽을 생각해 설계하라
- 디폴트 메서드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 '삽입' 된다. 즉, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.
- **디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.** 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 
경우가 아니면 피해야 한다.
- 디폴트 메서드라는 도구가 생겼더라도 **인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.**

### [아이템22] 인터페이스는 타입을 정의하는 용도로만 사용하라
- 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다. 인터페이스는 오직 이 용도로만 사용해야 한다.
- **상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.**
- 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다.

### [아이템23] 태그 달린 클래스보다는 클래스 계층구조를 활용하라
- 태그 달린 클래스: 두 가지 이상의 의미를 표현할 수 있으며, 그중 현재 표현하는 의미를 태그 값으로 알려주는 클래스
- 태그 달린 클래스의 단점
    - 열거 타입 선언, 태그 필드, switch 문 등 쓸데없는 코드가 많다.
    - 여러 구현이 한 클래스에 혼합돼 있어서 가독성도 나쁘다.
    - 다른 의미를 위한 코드도 언제나 함께 하니 메모리도 많이 사용한다.
    - 필드들을 final 로 선언하려면 해당 의미에 쓰이지 않는 필드들까지 생성자에서 초기화해야 한다.
    - 한마디로, **태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.**
- 태그 달린 클래스를 클래스 계층구조로 바꾸는 방법
    - 가장 먼저 계층구조의 루트(root)가 될 추상 클래스를 정의하고, 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다. 
    - 그런 다음 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래스에 일반 메서드로 추가한다.
    - 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트 클래스로 올린다.
    - 다음으로, 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의한다.
  
### [아이템24] 멤버 클래스는 되도록 static 으로 만들라
- 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰어야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.
- 중첩 클래스의 종류는 정적 멤버 클래스, (비정적)멤버 클래스, 익명 클래스, 지역 클래스 이렇게 네 가지다.
- **비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.**
    - 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this 를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
    - 정규화된 this 란 *클래스명*.this 형태로 바깥 클래스의 이름을 명시하는 용법을 말한다.
    - 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없다.
    - **드물게 직접 바깥 인스턴스의 클래스.new Member Class 를 호출해 수동으로 만들어지는데 이 관계 정보는 비정적 멤버 클래스의 인스턴스 안에 만들어져 메모리 공간을 차지하며 생성 시간도 더 걸린다.**
- **멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static 을 붙여서 정적 멤버 클래스로 만들자!**
- static 을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. 더 심각한 문제는 가비지 컬렉션이 **바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있다**는 점이다.

### [아이템25] 톱레벨 클래스는 한 파일에 하나만 담아라
- 소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자.

### [아이템26] 로 타입은 사용하지 말라]
- 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
- **오류는 가능한 한 발생 즉시. 이상적으로는 컴파일할 때 발견하는 것이 좋다.**
- 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
- 로 타입은 단지 호환성을 위해 만들어진 것이다. 

### [아이템27] 비검사 경고를 제거하라]
- 경고를 제거할 수는 없지만 안전한 타입이라고 확신할 수 있다면 @SuppressWarnings("unchecked") 애너테이션을 달아 경고를 숨기자. 대신 항상 가능한 한 좁은 범위에 적용하자.
- 모든 비검사 경고는 런타임에 ClassCastException 을 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해 제거하라.

### [아이템28] 배열보다는 리스트를 사용하라]
- 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 런타임에 소거된다.
- Long 용 저장소에 String 을 넣는다고 가정했을 때, 배열에서는 그 실수를 런타임에야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다.