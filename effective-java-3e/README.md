# 이펙티브 자바 Effective Java 3/E
- *조슈아 블로크 저/개앞맵시 역 | 인사이트(insight) |*

<br>

## 아이템 목록
#### [[아이템1] 생성자 대신 정적 팩터리 메서드를 고려하라](#아이템1-생성자-대신-정적-팩터리-메서드를-고려하라-1)
#### [[아이템2] 생성자에 매개변수가 많다면 빌더를 고려하라](#아이템2-생성자에-매개변수가-많다면-빌더를-고려하라-1)
#### [[아이템3] private 생성자나 열거 타입으로 싱글턴임을 보증하라](#아이템3-private-생성자나-열거-타입으로-싱글턴임을-보증하라-1)
#### [[아이템4] 인스턴스화를 막으려거든 private 생성자를 사용하라](#아이템4-인스턴스화를-막으려거든-private-생성자를-사용하라-1)
#### [[아이템5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라](#아이템5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라-1)
#### [[아이템6] 불필요한 객체 생성을 피하라](#아이템6-불필요한-객체-생성을-피하라-1)
#### [[아이템7] 다 쓴 객체 참조를 해제하라](#아이템7-다-쓴-객체-참조를-해제하라-1)
#### [[아이템8] finalizer 와 cleaner 사용을 피하라](#아이템8-finalizer-와-cleaner-사용을-피하라-1)
#### [[아이템9] try-finally 보다는 try-with-resources 를 사용하라](#아이템9-try-finally-보다는-try-with-resources-를-사용하라-1)
#### [[아이템10] equals 는 일반 규약을 지켜 재정의하라](#아이템10-equals-는-일반-규약을-지켜-재정의하라-1)
#### [[아이템11] equals 를 재정의하려거든 hashCode 도 재정의하라](#아이템11-equals-를-재정의하려거든-hashCode-도-재정의하라-1)
#### [[아이템12] toString 을 항상 재정의하라](#아이템12-toString-을-항상-재정의하라-1)

<br>

## 2장 객체 생성과 파괴
### [아이템1] 생성자 대신 정적 팩터리 메서드를 고려하라
- 클래스 생성자와 별도로 정적 팩터리 메서드(static factory method) 를 제공할 수 있다. 
    ~~~ java
    public static Boolean valueOf(boolean b) {
        retrun b ? Boolean.TRUE : Boolean.FALSE;
    }
    ~~~
- 정적 팩터리 메서드가 생성자 보다 좋은 장점 다섯 가지
    - 이름을 가질 수 있다. 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
    - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
        - 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다.
    - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        - 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 **엄청난 유연성**을 선물한다.
        - API 를 만들때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API 를 작게 유지할 수 있다.
    - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 정적 팩터리 메서드 단점
    - 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 패터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 정적 팩터리 메서드 명명 방식
    - from: 매개 변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
        ~~~ java
        Date d = Date.from(instant);
        ~~~
    - of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
        ~~~ java
        Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
        ~~~
    - valueOf: from 과 of 의 더 자세한 버전
        ~~~ java
        BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
        ~~~
    - instance 혹은 getInstance: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
        ~~~ java
        StackWalker luke = StackWalker.getInstance(options);
        ~~~
    - create 혹은 newInstance: instance 혹은 getInstance 와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
        ~~~ java
        Object newArray = Array.newInstance(clssObject, arrayLen);
        ~~~
    - getType: getInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type" 은 팩터리 메서드가 반환할 객체의 타입이다.
        ~~~ java
        FileStore fs = Files.getFileStore(path);
        ~~~
    - newType: newInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type" 은 팩터리 메서드가 반환할 객체의 타입이다.
        ~~~ java
        BufferedReader br = Files.newBufferedReader(path);
        ~~~
    - type: getType 과 newType 의 간결한 버전
        ~~~ java
        List<Complaint> litany = Collections.list(legacyLitany);
        ~~~
- **핵심 정리**
    - 정적 팩터리 메서드와 public 생성자는 각각의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가
    더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

### [아이템2] 생성자에 매개변수가 많다면 빌더를 고려하라
- 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 클라이언트가 실수로 매개변수의 순서를 바꿔 건네줘도 컴파일러는 알아채지 못하고, 결국 런타임에 엉뚱한 동작을 하게 된다.
- 자바빈즈패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓이게 된다.
- **자바빈즈패턴에서는 클래스를 불변(아이템17)으로 만들수 없다.**
- 빌더 패턴은 명명된 선택적 매개변수(named optional parameters) 를 흉내 낸 것이다.
- 빌대 퍼턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.
- **핵심 정리**
    - 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.
    - 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.

### [아이템3] private 생성자나 열거 타입으로 싱글턴임을 보증하라
- **클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.**
- 필드 방식의 싱글턴
    - 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.
    - 리플렉션을 이용하지 않고는 클라이언트는 손 쓸 방법이 없다.
- 정적 팩터리 방식의 싱글턴
    - API 를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
    - 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.(아이템30)
    - 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다.
- 열거 타입 방식의 싱글턴
    - **대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.**
    - 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.(얼거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있다.)

### [아이템4] 인스턴스화를 막으려거든 private 생성자를 사용하라
- **추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.** 하위 클래스를 만들어 인스턴스화하면 그만이다.
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

### [아이템5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 정적 유틸리티나 싱글턴을 잘못 사용하면 유연하지 않고 테스트하기 어렵다.
- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
- 이러한 자원들을 클래스가 직접 만들게 해서도 안 된다.
- 대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 
**의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.**
  
### [아이템6] 불필요한 객체 생성을 피하라
- 다음 코드는 하지 말아야 할 극단적인 예시이다. 이 문장은 실행될 때 마다 String 인스턴스를 새로 만든다. 이 문장이 반복문이나 빈번히 호출되는 메서드 안에 
있다면 쓸데 없는 String 인스턴스가 수백만 개 만들어 질 수도 있다.
    ~~~ java
    String s = new String("bikini");
    ~~~
- 다음과 같이 개선된 코드는 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.
또한 이 방식을 사용한다면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.
    ~~~ java
    String s = "bikini";
    ~~~
- 생성 비용이 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용할 필요가 있다.
- **String.matches 는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.**
- 성능을 개선하려면 필요한 정규표현식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고 재사용한다.
- **오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.**
- **박싱된 기본 타입보다는 기본 타입(primitive type)을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.**

### [아이템7] 다 쓴 객체 참조를 해제하라
- 가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾기가 까다롭다. 객체 참조 호나를 살려두면 가비지 컬렉트는 그 책체뿐만 아니라
그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체..)를 회수해가지 못한다.
- 해법은 해당 참조를 다 썼을 때 null 처리(참조 해제)를 하는 것이다.
- **객체 참조를 null 처리 하는 일은 예외적인 경우여야 한다.**
- 비활성 영역이 되는 순간 null 처리해서 해당 객체를 더는 쓰지 않을 것임을 가비지 컬렉터에 알려야 한다.

### [아이템8] finalizer 와 cleaner 사용을 피하라
- 자바의 두 가지 객체 소멸자 
    - finalizer: 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 자바 9에서는 deprecated API 로 지정되었다.
    - cleaner: finalizer 의 대안으로 소개 되었다. finalizer 보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- finalizer 와 cleaner 는 즉시 수행된다는 보장이 없다.
- System.gc 나 System.runFinalization 은 finalizer 와 cleaner 가 실행될 가능성을 높여줄 수는 있으나, 보장해주진 않는다.
- finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.
- **finalizer 와 cleaner 는 심각한 성능 문제도 동반한다.**
- **finalizer 를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.**
- **종료해야 할 자원을 담고 있는 객체의 클래스는 AutoCloseable 을 구현**해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.
- finalizer 와 cleaner 의 적절한 쓰임새 2가지
    - 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할
    - 네이티브 피어(native peer)와 연결된 객체.
        - 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다.
        - 네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알지 못한다.
        - 단, 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당 된다. 성능 저하를 감당할 수 없거나 네이티브 피어가 사용하는 자원을
    즉시 회수해야 한다면 AutoCloseable 을 구현하고 close 메서드를 사용해야 한다.
- 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖게 된다.

### [아이템9] try-finally 보다는 try-with-resources 를 사용하라
- 꼭 회수해야 하는 자원을 다룰 때는 try-finally 말고, try-with-resources 를 사용하자. 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다.

<br>

## 3장 모든 객체의 공통 메서드
- Object 에서 final 이 아닌 메서드(equals, hashCode, toString, clone, finalize) 는 모두 overriding 을 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있다.
- 즉, 모든 클래스는 이 메서드들을 일반 규약에 맞게 재정의해야 한다. 메서드를 잘못 구현하면 대상 클래스가 이 규약을 준수한다고 가정하는 클래스(hashMap 과 HashSet 등)를 오동작하게 만들 수 있다.
### [아이템10] equals 는 일반 규약을 지켜 재정의하라
- equals 를 재정의하지 않아도 되는 경우
    - 각 인스턴스가 본질적으로 고유한 경우. 값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. Thread 가 좋은 예이다.
    - 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없는 경우.
    - 상위 클래스에서 재정의한 equal 가 하위 클래스에도 딱 들어 맞는 경우. List 구현체들은 AbstractList 로부터, Map 구현체들은 AbstractMap 으로부터 상속받아 그대로 쓴다.
    - 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없는 경우.
    - 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스. Enum 같은 경우.
- equals 를 재정의 해야하는 경우
    - 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals 가 논리적 동치성을 비교하도록 재정의되지 않았을 경우. 주로 값 클래스들이 여기 해당한다.
    - 값 클래스란 Integer, String 처럼 값을 표현하는 클래스를 말한다.
- **equals 메서드를 재정의 할때 반드시 지켜야 하는 일반 규약** 
    - 반사성: 단순히 말하면 객체는 자기 자신과 같아야 한다.
    - 대칭성: 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.
    - 추이성: 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
    - 일관성: 두 객체가 같다면(어느 하나 혹은 두 객체 모두가 수정되지 않는 한) 앞으로도 영원히 같아야 한다.
    - null-아님: 모든 객체가 null 과 같지 않아야 한다.
- **equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알수 없다.**
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
- **equals 의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.**
- **양질의 equals 메서드 구현 방법**
    - == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
    - instanceof 연산자로 입력이 올바른 타입인지 확인한다.
    - 입력을 올바른 타입으로 형변환한다.
    - 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
- float 와 double 을 제외한 기본 타입 필드는 == 연산자로 비교하고, 참조 타입 필드는 각각의 equals 메서드로, float 와 double 필드는 가각 정적 메서드인
Float.compare(float, float), Double.compare(double, double) 로 비교한다.
  
### [아이템11] equals 를 재정의하려거든 hashCode 도 재정의하라
- **equals 를 재정의한 클래스 모두에서 hashCode 도 재정의 해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap, HashSet 
같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.**
- 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.
- HashMap 은 해시코드가 다른 엔트리끼리는 동치성 비교를 시도조차 하지 않도록 최적화 되어 있다.
- Objects.hash() 메서드는 성능에 민감하지 않은 상황에서만 사용해야 한다.
- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다. 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어 뜨릴 수도 있다.

### [아이템12] toString 을 항상 재정의하라 
- toString 을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
- 포맷을 명시하든 아니든 구현하는 클래스의 의도를 명확히 밝혀야 한다.
- toString 이 반환한 값에 포한된 정보를 얻어올 수 있는 API 를 제공하자.
- 정적 유틸리티 클래스는 toString 을 제공할 이유가 없다. 
- 열거 타입도 자바가 이미 완벽한 toString 을 제공하니 따로 재정의하지 않아도 된다.