# 이펙티브 자바 Effective Java 3/E
- *조슈아 블로크 저/개앞맵시 역 | 인사이트(insight) |*

<br>

## 아이템 목록
### [[아이템1] 생성자 대신 정적 팩터리 메서드를 고려하라](#아이템-1.-생성자-대신-정적-팩터리-메서드를-고려하라)

<br>

## 2장 객체 생성과 파괴
### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라
- 클래스 생성자와 별도로 정적 팩터리 메서드(static factory method) 를 제공할 수 있다. 
    ~~~ java
    public static Boolean valueOf(boolean b) {
        retrun b ? Boolean.TRUE : Boolean.FALSE;
    }
    ~~~
- 정적 팩터리 메서드가 생성자 보다 좋은 장점 다섯 가지
    - 이름을 가질 수 있다. 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
    - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
        - 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다.
    - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        - 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 **엄청난 유연성**을 선물한다.
        - API 를 만들때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API 를 작게 유지할 수 있다.
    - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 정적 팩터리 메서드 단점
    - 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 패터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 정적 팩터리 메서드 명명 방식
    - from: 매개 변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
        ~~~ java
        Date d = Date.from(instant);
        ~~~
    - of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
        ~~~ java
        Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
        ~~~
    - valueOf: from 과 of 의 더 자세한 버전
        ~~~ java
        BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
        ~~~
    - instance 혹은 getInstance: (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
        ~~~ java
        StackWalker luke = StackWalker.getInstance(options);
        ~~~
    - create 혹은 newInstance: instance 혹은 getInstance 와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
        ~~~ java
        Object newArray = Array.newInstance(clssObject, arrayLen);
        ~~~
    - getType: getInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type" 은 팩터리 메서드가 반환할 객체의 타입이다.
        ~~~ java
        FileStore fs = Files.getFileStore(path);
        ~~~
    - newType: newInstance 와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type" 은 팩터리 메서드가 반환할 객체의 타입이다.
        ~~~ java
        BufferedReader br = Files.newBufferedReader(path);
        ~~~
    - type: getType 과 newType 의 간결한 버전
        ~~~ java
        List<Complaint> litany = Collections.list(legacyLitany);
        ~~~
- **핵심 정리**
    - 정적 팩터리 메서드와 public 생성자는 각각의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가
    더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

### [아이템2] 생성자에 매개변수가 많다면 빌더를 고려하라
- 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 클라이언트가 실수로 매개변수의 순서를 바꿔 건네줘도 컴파일러는 알아채지 못하고, 결국 런타임에 엉뚱한 동작을 하게 된다.
- 자바빈즈패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓이게 된다.
- **자바빈즈패턴에서는 클래스를 불변(아이템17)으로 만들수 없다.**
- 빌더 패턴은 명명된 선택적 매개변수(named optional parameters) 를 흉내 낸 것이다.
- 빌대 퍼턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.
- **핵심 정리**
    - 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.
    - 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.

### [아이템3] private 생성자나 열거 타입으로 싱글턴임을 보증하라
- **클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.**
- 필드 방식의 싱글턴
    - 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다.
    - 리플렉션을 이용하지 않고는 클라이언트는 손 쓸 방법이 없다.
- 정적 팩터리 방식의 싱글턴
    - API 를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
    - 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.(아이템30)
    - 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다.
- 열거 타입 방식의 싱글턴
    - **대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.**
    - 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없다.(얼거 타입이 다른 인터페이스를 구현하도록 선언할 수는 있다.)

### [아이템4] 인스턴스화를 막으려거든 private 생성자를 사용하라
- **추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.** 하위 클래스를 만들어 인스턴스화하면 그만이다.
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.
### [아이템5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
