# 도메인 주도 설계 첫걸음

- *블라드 코노노프 저/김민석, 오창윤 역 | 위키북스*
- 코드 예제
  - [https://learning-ddd.com](https://learning-ddd.com)
  - [https://github.com/wikibook/lddd](https://github.com/wikibook/lddd)

## `Part 1` 전략적 설계

### 01 비즈니스 도메인 분석하기

- 효과적인 솔루션을 설계하고 구축하기 위해서는 그것의 바탕이 되는 문제를 이해해야 한다.
  - 문제를 이해하려면 그것이 존재하는 맥락을 이해해야 한다. 즉, 얻고자 하는 가치를 이해해야 한다.
- 하위 도메인은 비즈니스 활동의 세분화된 영역이다. 각각의 하위 도메인은 회사의 비즈니스 도메인에서 목표를 달성하기 위해 서로 상호작용해야 한다.
- 도메인 주도 설계에서 하위 도메인은 `핵심`, `일반`, `지원`의 세 가지 유형으로 구분한다.
- 핵심 하위 도메인(core subdomain)
  - 회사가 경쟁업체와 다르게 수행하고 있는 것. 가령 새로운 제품이나 서비스를 발명하거나 기존 프로세스를 최적화하여 비용을 줄이는 것이 그렇다.
  - 회사의 경쟁 우위를 제공한다.
- 일반 하위 도메인(generic subdomain)
  - 모든 회사가 같은 방식으로 수행하는 비즈니스 활동
  - 회사에 경쟁력을 제공하지는 않는다.
- 지원 하위 도메인(supporting subdomain)
  - 회사의 비즈니스를 지원하는 활동
- 소프트웨어 설계 의사결정에 미치는 영향
  - 경쟁 우위
    - 핵심 하위 도메인만이 회사에 경재 우위를 제공한다. 경쟁사와 차별화 하기 위한 회사의 전략이다.
  - 복잡성
    - 소프트웨어를 설계할 때 우리는 비즈니스 요구사항의 복잡성을 수용할 수 있는 도구와 기술을 선택해야 한다.
    - 핵심 하위 도메인은 복잡하다. 회사의 수익성이 좌우되기 때문에 경쟁업체가 최대한 모방하기 어려워야 한다.
    - 소프트웨어 설계에 영향을 미치는 복잡한 핵심 하위 도메인을 식별하는 것이 중요하다.
  - 변동성
    - 핵심 하위 도메인은 자주 변경될 수 있다. 다만, 다양한 구현 방법을 시도하고 개선하고 최적화해야 가능핟.
      - 핵심 하위 도메인에 대한 개선 작업은 끝이 없다. 기업은 지속적으로 혁신하고 발전한다.
      - 경쟁사보다 앞서기 위해서 핵심 하위 도메인의 지속적인 진화는 필수적이다.
  - 솔루션 전략
    - 유지보수가 불가능한 코드는 회사의 목표를 지원할 수 없다.
    - 핵심 하위 도메인의 요구사항은 자주 그리고 지속적으로 변경될 것으로 예상되므로 솔루션은 유지보수가 가능하고 쉽게 개선될 수 있어야 한다.
- 하위 도메인의 경계를 식별 하기 위해서 회사의 부서와 기타 조직 단위는 좋은 출발점이다.
  - 예를 들어, 온라인 쇼핑몰이라면 창고, 고객 서비스, 출고, 배송, 품질관리 등이 포함될 수 있다.
- 크게 나눈 하위 도메인은 좋은 출발점이지만, 문제는 세부 사항에 있다. 비즈니스 기능의 복잡한 내용에 숨겨진 중요한 정보를 놓치지 않아야 한다.
- 더 세부적인 통찰력을 얻기 위해 무한정 파헤칠 수는 없다. 도대체 언제 멈춰야 할까?
  - 응집된 유스케이스르 하위 도메인으로 나눈다.
    - 하위 도메인은 상호 연관되고 응집된 유스케이스의 집합과 유사하다.
    - 이러한 유스케이스 집합에서는 보통 동일한 행위자(actor), 비즈니스 엔티티(business entity)를 포함하고 모두 밀접하게 관련된 데이터의 집합을 다룬다.
    - 세분화된 하위 도메인을 찾는 것을 중단하는 시점을 결정하기 위한 지침으로 '응집된 유스케이스의 집합인 하위 도메인'이라는 정의를 사용할 수 있다.
- 도메인 전문가(domain expert)
  - 우리가 모델링하고 코드로 구현할 비즈니스의 모든 복잡성을 알고 있는 주제 전문가
  - 일반적으로 도메인 전문가는 요구사항을 제시하는 사람 또는 소프트웨어의 최종 사용자다.

### 02 도메인 지식 찾아내기

운영환경에 배포되는 것은 도메인 전문가의 지식이 아니라 개발자의 이해 혹은 오해다. - *알베르토 브랜돌리니*

- 비즈니스 도메인의 컨텍스트에서 '문제'의 의미는 광범위하다. 비즈니스 문제는 워크플로와 프로세스 최적화, 수작업 최소화, 자원 관리, 의사결정 지원
  데이터 관리 등과 관련한 과제일 수 있다.
- 효과적인 소프트웨어 솔루션을 설계하려면 적어도 기본적인 비즈니스 도메인 지식이 있어야 한다.
- 문서화된 커뮤니케이션은 최신 정보를 담아내지 못한다.
- 유비쿼터스 언어
  - 유비쿼터스 언어를 사용하는 것은 도메인 주도 설계의 초석이다.
    - 참가자들이 효과적으로 소통하기 위해 변환에 의존하지 말고 같은 언어를 사용하는 것
    - 비즈니스 도메인을 설명하기 위한 단일화된 언어 체계가 바로 유비쿼터스 언어다.
    - 기술 용어는 빼고 비즈니스 도메인에 관련된 용어로만 구성해야 한다.
  - 반드시 정확하고 일관성이 있어야 한다. 모호성이 커뮤니케이션을 방해하기 때문에 유비쿼터스 언어의 용어는 오직 하나의 의미를 가져야 한다.
  - 동의어를 사용하지 않도록 주의하자. 특정 컨텍스트 안에서 각각의 용어를 사용하는 것이 바람직하다.
  - **유비쿼터스 언어는 대화, 문서화, 테스트, 다이어그램, 소스코드 등 프로젝트 전반에 걸쳐 모든 이해관계자가 공유된 언어를 사용함으로써 커뮤니케이션과 지식공유를 강화한다.**
- 비즈니스 도메인 모델
  - 모델은 실세계의 복제가 아니라 우리가 실제 시스템을 이해하는 데 도움을 주는 인간의 창조물이다.
  - 예를 들면, 길안내 지도, 지형도, 세계 지도
    - 지도 중 어느 것도 우리 행성의 세부적인 것을 모두 나타내지는 않는다. 대신, 각 지도는 특정 목적을 지원하는 데 충분한 자료만 담고 있다.
- 효과적인 모델링
  - 모든 모델에는 목적이 있고 효과적인 모델은 그 목적을 달성하는 데 필요한 세부사항만 포함한다.
  - 유용한 모델은 실세계의 복사본이 아니라 문제를 해결하려는 의도가 있으며, 그 목적에 필요한 정보만 제공해야 한다.
  - 모델은 본질적으로 추상화의 결과다.
  - 추상화의 목적은 모모함이 아니라 절대적으로 정확할 수 있는 새로운 의미론적 수준을 만드는 것이다. - *에츠허르 데이크스트라*
- 비즈니스 도메인 모델링
  - 모델은 필요한 시스템을 구현하는 데, 즉 소프트웨어가 해결하고자 하는 특정 문제를 해결하는 데 필요한 만큼의 비즈니스 도메인 관점을 포함하면 된다.
  - 비즈니스 도메인의 이해를 확인할 신뢰성 있는 유일한 방법은 도메인 전문가가 이해할 수 있는 비즈니스 언어로 대화하는 것이다.
- 유비쿼터스 언어에 대한 용어집을 관리하자.
  - 이런 용어집은 비즈니스 도메인의 용어에 대한 정보를 얻을 수 있는 거점 역할을 하므로 새로운 팀원이 쉽게 적응하게 해준다.
  - 다 함께 용어집을 유지보수 하는 것이 중요하다.
    - 유비쿼터스 언어가 변경되면 모든 팀원이 수정할 수 있게 독려해야 한다.
- 용어집은 명사(noun)에만 효과적이다.
  - 행동은 단순히 명사와 관련된 동사의 목록이 아니라 규칙, 가정, 그리고 불변성을 가진 실제 비즈니스 로직이다. 이런 개념은 용어집으로 문서화하기 훨씬 어렵다.
  - 유스케이스 또는 거킨 테스트(Gherkin test)처럼 행동을 포착하는 데 적합한 다른 도구와 함께 사용하는 것이 가장 좋다.
    - given/when/then 에 테스트 시나리오를 작성

### 03 도메인 복잡성 관리

- 컨텍스트에 따라 유비쿼터스 언어는 다른 의미를 가질 수 있다.
  - 리드(lead)라는 용어가 마케팅 담당자에게는 제품 중 하나에 관심이 있다는 알림을, 영업 부서에서는 영업 프로세스의 전체 생명 주기를 나타낸다.
- 이러한 모호성은 개인 대 개인의 의사소통에는 그다지 큰 문제가 되지 않지만, 소스코드는 모호성에 잘 대처하지 못한다.
- '마케팅 리드', '영업 리드'와 같이 문맥상 정의에 문제가 있는 용어 앞에 접두사를 추가하고 두개의 모델을 만든다?
  - 인지부하를 유발한다. - 각 모델은 언제 사용해야 할까? 충돌하는 모델을 계속해서 구현할수록 실수하기 쉽다.
  - 모델의 구현이 유비쿼터스 언어와 일치하지 않는다. - 아무도 대화에 접두사를 사용하지 않을 것이다. 대화의 맥락에만 의존해서 소통해야 한다.
- 바운디드 컨텍스트(bounded context)
  - 앞의 예에서 마케팅과 영업이라는 두 가지 바운디드 컨텍스트를 식별할 수 있다.
  - '리드'라는 용어는 두 가지 바운디드 컨텍스트에 모두 존재하고, 각 바운디드 컨텍스트에서 단일 의미를 갖는 한, 각각은 일관성을 가진다.
  - 하나의 바운디드 컨텍스트의 유비쿼터스 언어는 다른 바운디드 컨텍스트의 범위에는 완전히 관련이 없다.
- 유비쿼터스 언어의 경계가 넓을수록 일관성을 유지하기가 더 어렵다.
- 하위 도메인은 발견하고 바운디드 컨텍스트는 설계한다는 점에서 차이가 있다.
  - 하위 도메인은 비즈니스 전략에 의해 정의된다. 그러나 소프트웨어 엔지니어는 특정 프로젝트의 컨텍스트와 제약 조건을 해결하기 위해 소프트웨어 솔루션과 바운디드 컨텍스트를 설계할 수 있다.
- **모델은 특정 문제를 해결하기 위한 것이다.**
  - 우리가 해결하려는 문제는 모델 본연의 목적이다.
  - 모델은 경계 없이 존재할 수 없다. 경계가 없다면 현실 세계의 복제본처럼 확장될 것이다.
  - 따라서 모델의 경계(바운디드 컨텍스트)를 정의하는 것은 모델링 프로세스의 본질적인 부분이다.
- 바운디드 컨텍스트는 모델 경계뿐만 아니라 이를 구현하는 시스템의 물리적 경계 역할도 한다.
  - 각 바운디드 컨텍스트는 개별 서비스/프로젝트로 구현돼야 한다.
  - 즉, 구현, 진화, 버전 관리를 각각의 다른 바운디드 컨텍스트와 독립적으로 해야 한다.
  - 바운디드 컨텍스트는 여러 하위 도메인을 포함할 수 있다. 이러한 경우 바운디드 컨텍스트는 물리적 경계고 하위 도메인은 논리적 경계다.
  - 한 팀이 여러 개의 바운디드 컨텍스트를 소유할 수도 있다.
- 시멘틱 도메인
  - 시멘틱 도메인은 의미 영역과 해당 의미를 전달하기 위해 사용하는 단어 영역으로 구분한다.
  - 예를 들어 모니터, 포트, 프로세서라는 단어는 소프트웨어와 하드웨어 엔지니어링 시맨틱 도메인에서 서로 다른 의미를 갖는다.
- **모델은 당면한 작업과 관련 없는 정보는 생략해야 한다.**

### 04 바운디드 컨텍스트 연동

- 모델의 목적, 즉 경계를 명시하지 않고는 모델을 구축할 수 없다.
- 하나의 바운디드 컨텍스트 내의 언어는 특정 문제를 해결하는 비즈니스 도메인을 모델링한다.
- 다른 바운디드 컨텍스트가 동일한 비즈니스 엔티티를 대표할 수 있지만, 이는 다른 문제를 해결하는 비즈니스 도메인을 모델링한다.
- 바운디드 컨텍스트는 서로 독립적으로 발전할 수 있지만, 상호작용해야 한다. 결국, 바운디드 컨텍스트 사이에는 항상 접점이 있는데 이것을 `컨트랙트(contract)`라고 부른다.
- 공유 커널 패턴은 바운디드 컨텍스트 간에 강한 의존관계를 만들기 때문에 중복 비용이 조율 비용보다 클 경우에만 적용해야 한다.
  - 두 바운디드 컨텍스트가 공유하는 코드베이스에 대한 변경을 조율하려는 노력보다 공유하는 모델에 대한 변경을 통합할 때 드는 노력이 더 클 경우에 적용한다.
- 통합 비용과 중복 비용의 차이는 모델의 변동성에 달렸다.
  - 변경이 잦을수록 통합 비용이 높아진다. 그러므로 자연스럽게 공유 커널은 핵심 하위 도메인처럼 많이 변하는 하위 도메인에 적용된다.
- 모델에서 공유된 부분은 항상 가능한 한 작게 유지해야 한다.

## `Part 2` 전술적 설계

### 05 간단한 비즈니스 로직 구현

- 소프트웨어가 비즈니스에 쓸모가 없다면 값비싼 기술 데모에 불과하다.
- 트랜잭션 스크립트 패턴
  - 프로시저를 기반으로 시스템의 비즈니스 로직을 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현한다.
  - 각 프로시저는 간단하고 쉬운 절차지향 스크립트로 구현
  - **각 작업은 성공하거나 실패할 수 있지만, 유효하지 않은 상태를 만들면 안 된다.**
    - 일관성을 유지해야 한다.
  - 비즈니스 로직이 단순한 지원 하위 도메인에 적합하다.
  - **트랜잭션 스크립트로 복잡한 비즈니스 로직을 구현하면 머지않아 유지보수가 불가능한 커다란 진흙 덩어리가 될 것이다.**
- 액티브 레코드 패턴
  - 액티브 레코드라고 하는 전용 객체를 사용하여 복잡한 자료구조를 표현한다. 자료구조 외에도 이러한 객체는 CRUD 작업도 구현한다.
    - 즉, 액티브 레코드는 데이터 접근 로직을 구현한다.
  - 트랜잭션 스크립트 패턴과 마찬가지로 비즈니스 로직이 단순한 경우 사용하지만 액티브 레코드는 좀 더 복잡한 자료구조에서도 비즈니스 로직이 작동할 수 있다.
  - 액티브 레코드 객체는 ORM 또는 다른 데이터 접근 프레임워크와도 관련이 있다.
  - 이 패턴의 목적은 메모리 상의 객체를 데이터베이스 스키마에 매핑하는 복잡성을 숨기는 것이다.
  - 액티브 레코드는 본질적으로 데이터베이스에 대한 접근을 최적화하는 트랜잭션 스크립트이기 때문에 이 패턴은 유효성 검증, CRUD 같은 비교적 간단한 비즈니스 로직만 지원할 수 있다.
  - [코드](code/ch05/ActiveRecord.cs)
- **항상 그렇듯이 보편적인 법칙은 없다. 그것은 작업 중인 비즈니스 도메인에 달려 있다.**

### 06 복잡한 비즈니스 로직 다루기

- 도메인 모델
  - 도메인 모델 패턴은 복잡한 비즈니스 로직을 다루기 위한 것이다.
  - CRUD 인터페이스 대신 복잡한 상태 전환, 항상 보호해야 하는 규칙인 비즈니스 규칙과 불변성을 다룬다.
  - 도메인 모델은 행동과 데이터 모두를 포함하는 도메인의 객체 모델이다.
- 도메인 비즈니스 로직은 이미 본질적으로 복잡하므로 모델링에 사용되는 객체가 모델에 조금이라도 우발적 복잡성을 추가하면 안 된다.
- 모델에는 데이터베이스 또는 외부 시스템 구성요소의 호출 구현 같은 인프라 또는 기술적인 괌심사를 피해야 한다.
  - 이 같은 제약을 따르면 모델의 객체는 플레인 올드 오브젝트(plain old object, 자바의 POJO) 가 된다.
    - 플레인 올드 오브젝트는 인프라 구성요소 또는 프레임워크에 의지하지 않고 직접 협업하지 않으면서 비즈니스 로직을 구현하는 객체다.
  - 도메인 모델의 객체가 기술적 관심사가 아닌 비즈니스 로직에 집중하게 되면 바운디드 컨텍스트에서 사용하는 유비쿼터스 언어의 용어를 따르기 쉬워진다.
- 벨류 오브젝트
  - 예를 들어, 색(color)처럼 복합적인 값에 의해 식별되는 객체다.
  - 원시 데이터 타입에 전적으로 의존해서 비즈니스 도메인의 개념을 표현하는 방식에는 몇 가지 설계 위험이 있다.
    - 유효성 검사 로직이 중복되기 쉽다.
    - 값이 사용되기 전에 유효성 검사 로직을 호출하게 하기 어렵다.
    - 미래를 대비한 유지보수가 더 어렵다.
  - 밸류 오브젝트의 장점
    - 짧은 변수 이름을 사용하더라도 의도를 명확하게 전달한다.
    - 유효성 검사 로직이 밸류 오브젝트 자체에 들어 있기 때문에 값을 할당하기 전에 유효성 검사를 할 필요가 없다.
    - 값을 조작하는 비즈니스 로직을 한곳에 응집할 수 있고, 쉽게 테스트 할 수 있다.
    - **가장 중요한 점은 밸류 오브젝트를 사용하면 코드에서 유비쿼터스 언어를 사용하게 하므로 코드에서 비즈니스 도메인의 개념을 표현하게 된다는 것이다.**
  - [원시 데이터 타입을 사용하는 코드](code/ch06/PrimitivePerson.cs)
  - [밸류 오브젝트를 사용하는 코드](code/ch06/ValueObjectPerson.cs)
- 엔티티
  - 엔티티는 밸류 오브젝트와 정반대다. 엔티티는 다른 엔티티 인스턴스와 구별하기 위해 명시적인 식별 필드가 필요하다.
  - 밸류 오브젝트와는 반대로, 엔티티는 불변이 아니고 변할 것으로 예상된다.
  - **엔티티는 독립적인 패턴이 아닌 애그리게이트의 일부로서만 사용된다.**
- 애그리게이트
  - 애그리게이트는 엔티티다. 즉, 명시적인 식별 필드가 필요하고 인스턴스의 생애주기 동안 상태가 변할 것으로 예상된다.
  - 애그리게이트의 로직은 모든 들어오는 변경 요청을 검사해서 그 변경이 애그리게이트의 비즈니스 규칙에 위배되지 않게 해야 한다.
  - 애그리게이트 외부의 모든 프로세스와 객체는 애그리게이트의 상태를 읽을 수만 있고 애그리게이트의 퍼블릭 인터페이스에 포함된 관련 메서드를 실행해야만 상태를 변형할 수 있다.
  - 애그리게이트의 퍼블릭 인터페이스로 노출된 상태 변경 메서드는 '어떤 것을 지시하는 명령'을 뜻하는 의미에서 `커맨트`라고도 부른다.
  - 이와 같은 엄격한 경계는 애그리게이트와 관련된 모든 비즈니스 로직이 한 곳, 즉 애그리게이트 자체에 구현되게 한다.
  - 여러 애그리게이트에서 변경을 커밋해야 한다면 이는 잘못된 트랜잭션 경계의 신호이고 잘못된 애그리게이트의 경계다.
  - [코드](code/ch06/ExecutionResult.cs)
- 애그리게이트 내의 모든 객체는 같은 트랜잭션 경계를 공유하기 때문에 애그리게이트가 너무 커지면 성능과 확장 문제가 생길 수 있다.
- **외부 애그리게이트를 참조할 때 ID 를 이용하는 이유는 이 같은 객체가 애그리게이트 경계에 속하지 않음을 명확히 하고 각 애그리게이트가 자신의 트랜잭션 경계를 갖게 보장하기 위함이다.**
- 애그리게이트 루트
  - 애그리게이트가 엔티티의 계층 구조를 대표하기 때문에 그중 하나만 애그리게이트의 퍼블릭 인터페이스, 즉 애그리게이트 루트로 지정돼야 한다.
- 도메인 이벤트
  - 애그리게이트 루트의 퍼블릭 인터페이스 외에 외부에서 애그리게이트와 커뮤니케이션 할 수 있는 다른 메커니즘
  - 도메인 이벤트는 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지다.
  - 도메인 이벤트는 이미 발생된 것이기 때문에 과거형으로 명명한다.
  - [코드](code/ch06/DomainEvent.cs)
- 도메인 서비스
  - 애그리게이트에도 밸류 오브젝트에도 속하지 않거나 복수의 애그리게이트에 관련된 비즈니스로직을 다루게 될 때 도메인 서비스로 로직을 구현.
  - 도메인 서비스는 비즈니스 로직을 구현한 `상태가 없는 객체`다.
    - 대부분의 경우 이런 로직은 어떤 계산이나 분석을 수행하기 위한 다양한 시스템 구성요소의 호출을 조율한다.
  - 도메인 서비스는 여러 애그리게이트의 데이터를 `읽는 것`이 필요한 계산 로직을 구현하는 것을 도와준다.
  - **도메인 서비스는 비즈니스 로직에서 사용되는 상태가 없는 객체일 뿐이다.**
  - [코드](code/ch06/DomainService.cs)
- **애그리게이트와 밸류 오브젝트 패턴에서 중요한 것은 복잡한 것을 불변성으로 감싸서 복잡성을 낮추는 것이다.**

### 07 시간 차원의 모델링

- 이전장의 도메인 모델 패턴과 유사하지만 도메인 모델 패턴에서는 최종 상태만을 가지고 있기 때문에 수명주기 동안 어떻게 상태가 변경되었는지 알 수 없다.
- 이벤트 소싱 패턴
  - 데이터 모델에 시간 차원을 도입한다.
  - 애그리게이트의 현재 상태를 반영하는 스키마 대신 이벤트 소싱 기반 시스템은 애그리게이트의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지한다.
  - 이벤트 소싱 패턴이 작동하려면 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장되어야 한다.
- 복잡한 비즈니스 로직을 구현할 때 이벤트 소싱을 활용함으로써 얻을 수 있는 장점
  - 도메인 이벤트는 애그리게이트의 모든 과거 상태를 복원하는 데도 사용 할 수 있다.
  - 감사 로그로 활용 가능
- 이벤트 소싱 도메인 모델의 단점
  - 팀이 지금까지 이벤트 소싱 시스템을 구현한 경험이 없다면 학습 곡선을 고려해야 한다.
  - 이벤트의 스키마를 조정하기 어렵다.(*기존 이벤트를 마이그레이션도 해야 하기 때문인 것 같다.*)
  - 수많은 아미텍처의 유동적인 부분이 도입되어 전체 설계가 더 복잡해진다.
- 이벤트에서 애그리게이트 상태를 재구성하면 시스템 성능에 부정적인 영향을 줄 수 있는데 이것이 어떻게 작동할 수 있을까?
  - 애그리게이트의 예상 수명과 비교해서 의사결정해야 한다.
  - 애그리게이트당 10,000개 이상의 이벤트가 있다면 스냅숏 패턴을 활용해보자.
- **이 패턴은 분석과 최적화를 위해, 또는 법적으로 감사 로그를 요구하기 때문에 시스템 데이터에 대한 심오한 통찰력이 필요한 경우에 적합하다.**

### 08 아키텍처 패턴

- 비즈니스 로직과 아키텍처 패턴
  - 코드베이스가 처리해야 할 다양한 관심사로 인해 비즈니스 로직이 다양한 구성요소에 흩어지기 쉽다.
  - 올바른 아키텍처 패턴을 선택하는 것은 단기적으로는 비즈니스 로직 구현을 지원하고, 장기적으로 유지보수를 돕기 위해 매우 중요하다.
- 계층형 아키텍처
  - 코드베이스를 수평 계층으로 조직하고, 각 계층은 사용자와 상호작용, 비즈니스 로직의 구현, 그리고 데이터의 저장과 같은 기술적 관심사 중 하나를 다룬다.
  - 프레젠테이션 계층(presentation layer), 비즈니스 로직 계층(business logic layer), 데이터 접근 계층(data access layer)의 세 가지 계층으로 구성된다.
  - 프레젠테이션 계층
    - 사용자와 상호작용을 하기 위한 프로그램의 사용자 인터페이스를 구현
      - GUI, CLI, 타 시스템 연동 API, 메시지 브로커에서 이벤트에 대한 구독, 나가는 이벤트를 발행하는 메시지 토픽 등등
  - 비즈니스 로직 계층
    - 프로그램의 비즈니스 로직을 구현하고 묶는 것을 담당한다. 이곳에 비즈니스 의사결정을 구현한다.
  - 데이터 접근 계층
    - 영속성 메커니즘에 접근할 수 있게 해준다.
    - 이 계층은 프로그램의 기능을 구현하는 데 필요한 다양한 외부 정보 제공자와 연동하는 것을 포함한다.
  - 각 계층은 바로 아래 계층에만 의존해서 구현 관심사의 결합성을 낮추고 계층 간에 공유할 지식을 줄인다.
  - 프레젠테이션 계층은 비즈니스 로직 계층만 참조하고 데이터 접근 계층의 설계 의사결정을 알지 못한다.
  - 변종으로 서비스 계층을 추가하는 경우도 있다.
    - 서비스 계층은 프로그램의 프레젠테이션 계층과 비즈니스 로직 계층 사이의 중간 역할을 한다.
    - **서비스 계층은 물리적 서비스가 아니라 논리적 경계이다.**
  - 동일한 용어
    - 프레젠테이션 계층 = 사용자 인터페이스 계층
    - 서비스 계층 = 애플리케이션 계층
    - 비즈니스 로직 계층 = 도메인 계층 = 모델 계층
    - 데이터 접근 계층 = 인프라스트럭처 계층
  - 계층형 아키텍처를 사용하는 경우
    - 비즈니스 로직과 데이터 접근 계층 간에는 의존성이 있기 때문에 비즈니스 로직이 트랜잭션 스크립트 또는 액티브 레코드 패턴을 사용하여 구현된 시스템에 적합하다.
    - 도메인 모델을 구현하는 데 계층형 아키텍처 패턴을 적용하는 것은 어렵다.
      - 도메인 모델에서는 비즈니스 엔티티(애그리게이트와 벨류 오브젝트)가 하부의 인프라스트럭처에 대해 의존성이 없어야 하고 그것을 몰라야 하기 때문이다.
  - 계층과 티어는 개념적으로 다르다. 계층이 논리적 경계인 반면, 티어는 물리적 경계다.
- 포트와 어댑터
  - 포트와 어댑터 아키텍처의 핵심 목적은 인프라스트럭처 구성요소로부터 시스템의 비즈니스 로직을 분리하는 것이다.
  - 비즈니스 로직 계층은 인프라스트럭처 계층이 구현해야 할 `포트`를 정의한다.
  - 인프라스트럭처 계층은 `어댑터`를 구현한다.
  - 도메인 모델 패턴을 사용하여 구현한 비즈니스 로직에 매우 적합하다.
- CQRS(Command Query Responsibility Segregation)
  - 시스템 모델의 책임을 분리시킨다. 여기에는 커맨드 실행 모델과 읽기 모델의 두 유형이 있다.
  - 커맨드는 어떤 데이터도 반환해서 안 된다는 건 잘못된 것이다.
    - 커맨드는 실행이 성공했는지 또는 실패했는지를 항상 호출자에게 알려야 한다.
  - CQRS 패턴은 여러 모델, 궁극적으로 다양한 종류의 데이터베이스에 저장된 동일한 데이터와 작동할 필요가 있는 애플리케이션에 유용하다.
  - 이벤트 소싱 도메인 모델에도 적합하다.
- **바운디드 컨텍스트에 단일 아키텍처를 강요하면 의도치 않은 우발적 복잡성을 유발할 것이다. 우리의 목적은 실제 필요성과 비즈니스 전략에 따라 설계 의사결정을 내리는 것이다.**

### 09 커뮤니케이션 패턴

- 아웃박스 패턴
  - 업데이트된 애그리게이트의 상태와 새 도메인 이벤트는 모두 동일한 원자성 트랜잭션으로 커밋된다.
  - 메시지 릴레이는 데이터베이스에서 새로 커밋된 도메인 이벤트를 가져온다.
  - 릴레이는 도메인 이벤트를 메시지 버스에 발행한다.
  - 성공적으로 발행되면 릴레이는 이벤트를 데이터베이스에 발행한 것으로 표시하거나 완전히 삭제한다.
- 사가
  - 사가는 오래 지속되는 비즈니스 프로세스다. 즉, 여러 터랜잭션에 걸쳐 있는 비즈니스 프로세스를 말한다.
  - 트랜잭션은 애그리게이트뿐만 아니라 도메인 이벤트를 내보내고 커맨드에 응답하는 모든 컴포넌트에서 처리할 수 있다.
  - 사가는 관련 컴포넌트에서 발생하는 이벤트를 수신하고 다른 컴포넌트에 후속 커맨드를 발행한다.
  - 발행 단계 중 하나가 실패하면 사가는 시스템 상태를 일관되게 유지하도록 적절한 보상 조치를 발행하는 일을 담당한다.
  - **사가가 결국 관련 커맨드를 실행한다고 해도 두 개의 트랜잭션은 원자적으로 간주되지 않으므로 모두 성공하거나 실패할 수 없다.**
  - **부적절한 애그리게이트 경계를 보상하기 위해 사가를 남용하지 않도록 하자.**
  - [코드](code/ch09)

## `Part 3` 도메인 주도 설계 적용 실무

### 10 휴리스틱 설계

- 휴리스틱을 사용하는 것은 수많은 단서에 내재된 노이즈를 무시하면서도 가장 중요한 단서에서 느껴지는 '압도하는 힘'에 집중하여 효과적으로 문제를 해결하는 접근법이다.
- 바운디드 컨텍스트의 경계를 리팩터링하는 것은 비용이 많이 드는 작업이고 대부분의 경우 효과적이지 않은 경계는 방치되고 결국 기술 부채로 남게 된다.
- 논리적 경계를 리팩터링하는 것은 물리적 경계를 리팩터링하는 것보다 적은 비용이 든다. 그러므로 바운디드 컨텍스트를 설계할 때는 경계를 넓게 해서 시작하자.
  - 나중에 도메인 지식이 쌓이게 되면 필요에 따라 넓은 경계를 좀 더 작은 여러 경계로 쪼갠다.
- 비즈니스 로직의 적절한 구현 패턴을 선택하기 위한 효과적인 휴리스틱 질문
  - 하위 도메인이 금전 또는 통화의 트랜잭션을 추적하거나, 일관된 감사 로그를 제공하거나, 또는 비즈니스에서 하위 도메인의 동작에 대한 심층적인 분석을 요청하는가?
    그렇다면 이벤트 소싱 도메인 모델을 적용한다. 그렇지 않다면
  - 하위 도메인의 비즈니스 로직이 복잡한가? 그렇다면 도메인 모델을 구현한다. 그렇지 않다면
  - 하위 도메인이 복잡한 자료구조를 포함하는가? 그렇다면 액티브 레코드 패턴을 사용한다. 그렇지 않다면
  - 그것이 아니라면 트랜잭션 스크립트를 구현한다.
- **설계 의사결정을 내리는 것도 중요하지만, 더 중요한 것은 시간이 지나면서 과거의 의사결정이 여전히 유효한지를 검증하는 것이다.**

### 11 진화하는 설계 의사결정

- 기존 설계가 복잡한 로직을 지원하지 않아서 새로운 기능을 추가하는 것은 고통스러운 일이 된다. 이 '고통'은 중요한 신호다. 비즈니스 도메인과 설계 의사결정을
  재평가하기 위한 신호가 된다.
- **현 상황에서 가장 적합한 설계 방식을 선택하고 필요할 때 개선해야 한다.**
- 하위 도메인을 통해 다양한 비즈니스 가치의 구성요소를 식별하고 적절한 도구를 사용해서 솔루션을 설계하고 구현할 수 있어야 한다.
- 비즈니스 로직에 따라 강력하게 일관성을 유지할 필요가 없는 데이터까지 포함되면서 애그리게이트가 커진다면 이는 제거해야 하는 우발적 복잡성으로 봐야한다.
  - 비즈니스 기능을 전담 애그리게이트로 추출하면 원래 애그리게이트가 단순해질 뿐만 아니라 잠재적으로 해당 애그리게이트가 속한 바운디드 컨텍스트도 단순해진다.
- '여러 방면에 다재다능한' 바운디드 컨텍스트가 되는 것을 허용하지 마라. 바운디드 컨텍스트에 포함된 모델이 특정 문제를 해결하는 데 중점을 두고 있는지 확인하라.

### 12 이벤트스토밍

- 이벤트스토밍은 사람들이 모여 비즈니스 프로세스에 관해 브레인스토밍하고 신손하게 모델링하기 위한 로우테크 활동이다.
  - 어떤 의미에서는 비즈니스 도메인 지식을 공유하기 위한 전술적 도구다.
- 이벤트스토밍을 사용하는 경우
  - 유비쿼터스 언어 구축하기
  - 비즈니스 프로세스 모델링하기
  - 새로운비즈니스 요구사항 탐색하기
  - 도메인 지식 복구하기
  - 존재하는 비즈니스 프로세스의 개선 방법 탐색하기
  - 새로운 팀원의 훈련

### 13 실무에서의 도메인 주도 설계

- DDD 를 도입하는 가장 좋은 출발점은 조직의 비즈니스 전략과 시스템 아키텍처의 현 상황을 이해하는 데 시간을 투자하는 것이다.
- 비즈니스 도메인 이해하기
  - 조직의 비즈니스 도메인은 무엇인가?
  - 고객은 누구인가?
  - 조직이 고객에게 제공하는 서비스 또는 가치는 무엇인가?
  - 경쟁 회사 또는 그들의 제품은 무엇인가?
- 핵심 하위 도메인을 식별하는 또 하나의 강력하지만 유감스러운 휴리스틱은 최악으로 설계된 소프트웨어 컴포넌트, 즉 커다란 진흙 덩어리를 찾아내는 것이다.
- 어느 것이 다른 컴포넌트와 독립적으로 개선되고 테스트되고 배포될 수 있는지 확인하라.
- 작은 점진적인 조치가 대규모 재작성보다 안전하다.

## `Part 4` 다른 방법론 및 패턴과의 관계

### 14 마이크로서비스

- 서비스는 미리 정의된 인터페이스를 사용해 하나 이상의 역량에 접근하기 위한 메커니즘이다.
  - **미리 정의된 인터페이스**란 서비스로부터 데이터를 넣고 빼는 모든 메커니즘을 말한다.
    - 여기에는 요청/응답 모델과 같은 동기식 또는 이벤트를 제공하고 사용하는 모델과 같은 비동기식이 있다.
- 서비스는 서로 협업해야 하고 각 서비스가 반영하는 변경을 동기화해야 한다. 결과적으로, 이와 같은 연동 관련 관심사를 처리하기 위해 서비스의 인터페이스를 확장해야 한다.
- 시스템은 독립적인 컴포넌트로 구축될 수 없다. 그러나 적절히 분리된 마이크로서비스 기반 시스템에서 서비스는 여전히 서로 연동하고 통신한다.
- 적절한 마이크로서비스 기반 시스템을 설계하려면 글로벌 복잡성과 로컬 복잡성 모두를 최적화 해야 한다.
  - **로컬 복잡성**은 각각의 개별 마이크로서비스의 복잡성을 가리키고, **글로벌 복잡성**은 전체 시스템의 복잡성을 말한다.
- 바운디드 컨텍스트는 모델의 경계다.
- 하위 도메인은 비즈니스 역량의 경계, 애그리게이트와 밸류 오브젝트는 트랜잭션의 경계다.
- 시스템이 적절하지 않게 바운디드 컨텍스트를 분해하거나 마이크로서비스 임계치를 넘어서 분해된다면 각각 커다란 진흙 덩어리가 되거나 분산된 커다란 진흙 덩어리가 된다.
- 바운디드 컨텍스트는 가장 넓은 유효한 경계를 설정하지만, 애그리게이트의 경계는 가능한 한 좁게 설정한다.
- 애그리게이트를 여러 물리적 서비스 또는 바운디드 컨텍스트로 분해하는 것은 최적이 아닌 원치 않는 결과를 초래한다.
- **애그리게이트는 내부 비즈니스 규칙과 불변성, 로직의 복잡성을 감싸는 개별적인 비즈니스 기능 단위다.**
- 하위 도메인은 응집된 유스케이스의 집합을 대표한다. 즉, 같은 비즈니스 도메인 모델을 사용하고, 같거나 밀접하게 관련된 데이터를 다루며, 강한 기능 연관성을 갖는다.

### 15 이벤트 주도 아키텍처(DEA: Event-Driven Architecture)

- 이벤트는 레거시 시스템에 적용한다고 해서 느슨하게 연결된 분산 시스템으로 전환할 수 있는 일종의 비법 소스가 아니다. 오히려 그 반대다.
  EDA 를 부주의하게 적용하면 모듈식 모놀리스를 분산된 커다란 진흙 덩어리로 만들 수 있다.
- 이벤트 주도 아키텍처와 이벤트 소싱 모두 이벤트를 기반으로 하지만, 두 패턴은 개념적으로 다르다.
  - EDA 는 서비스 간 통신을 의미하는 반면, 이벤트 소싱은 서비스 내부에서 발생한다.
  - 이벤트 소싱을 위해 설계된 이벤트는 서비스에서 구현된 상태 전환을 나타낸다.
  - 이는 비즈니스 도메인의 복잡성을 파악하기 위한 것이며, **서비스를 다른 시스템 컴포넌트와 연동하기 위한 것이 아니다.**
- 이벤트(Event): 이미 발생한 변화를 설명하는 메시지
- 커맨드(Command): 수행돼야 할 작업을 설명하는 메시지
- 시스템에 이벤트를 맹목적으로 적용하면 시스템 결합도가 낮아지지도 회복력이 향상 되지도 않는다.
- 이벤트가 항상 일관되게 전달되도록 하기 위한 지침
  - 메시지를 안정적으로 발송하기 위해 아웃박스 패턴을 사용하자
  - 메시지를 발송할 때 구독자가 메시지 중복을 제거하고 순서가 잘못된 메시지를 식별하고 재정렬할 수 있게 하라
  - 보상 조치를 발행해야 하는 교차 바운디드 컨텍스트 프로세스를 조율할 때 사가 패턴과 프로세스 관리자 패턴을 활용하라
