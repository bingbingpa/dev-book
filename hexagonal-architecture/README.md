# 만들면서 배우는 클린 아키텍처
- *톰 홈버그 저/박소은 역 | 위키북스*

## 01 계층형 아키텍처의 문제는 무엇일까?

- 전통적인 계층형 구조의 웹 애플리케이션 구조
  - 맨 위의 **웹**계층에서는 요청을 받아 **도메인** 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다.
  - 서비스에서는 필요한 비즈니스 로직을 수행한다.
  - 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 **영속성** 계층의 컴포넌트를 호출한다. 
- 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
  - 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.
  - **다른 무엇보다도 도메인 로직을 먼저 만들어야 한다. 그래야만 우리가 로직을 제대로 이해 했는지 확인할 수 있다.**
    - 그리고 도메인 로직이 맞다는 것을 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.
  - 데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM(object-relational-mapping, 객체 관계 매핑) 프레임워크를 사용하기 때문이다.
    - ORM 에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다. 하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.
    - 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시로딩/지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야만 한다.
- 테스트하기 어려워진다.
  - 계층을 건너뛰는 경우(예를 들면 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하는 경우) 발생하는 두 가지 문제점
    - **도메인 로직을 웹 계층에 구현하게 된다. 그리고 유스케이스가 확장된다면 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다.**
    - 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야 한다. 이렇게 되면 단위 테스트의 복잡도가 올라간다.
- 유스케이스를 숨긴다.
  - 계층형 아키텍처는 도메인 서비스의 '너비'에 관해 규칙을 강제하지 않는다. 그렇기 때문에 시간이 지나면 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.
  - 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.
  - 결국 서비스를 테스트 하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.
- 동시 작업이 어려워진다.
  - **계층형 아키텍처에서는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을
  만들어야 한다. 그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.**
  - 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. 서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고,
  이는 병합 충돌과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하기 때문이다.
