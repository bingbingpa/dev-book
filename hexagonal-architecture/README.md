 # 만들면서 배우는 클린 아키텍처
- *톰 홈버그 저/박소은 역 | 위키북스*

## 01 계층형 아키텍처의 문제는 무엇일까?

- 전통적인 계층형 구조의 웹 애플리케이션 구조
  - 맨 위의 **웹**계층에서는 요청을 받아 **도메인** 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다.
  - 서비스에서는 필요한 비즈니스 로직을 수행한다.
  - 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 **영속성** 계층의 컴포넌트를 호출한다. 
- 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
  - 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.
  - **다른 무엇보다도 도메인 로직을 먼저 만들어야 한다. 그래야만 우리가 로직을 제대로 이해 했는지 확인할 수 있다.**
    - 그리고 도메인 로직이 맞다는 것을 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.
  - 데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM(object-relational-mapping, 객체 관계 매핑) 프레임워크를 사용하기 때문이다.
    - ORM 에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다. 하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.
    - 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시로딩/지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야만 한다.
- 테스트하기 어려워진다.
  - 계층을 건너뛰는 경우(예를 들면 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하는 경우) 발생하는 두 가지 문제점
    - **도메인 로직을 웹 계층에 구현하게 된다. 그리고 유스케이스가 확장된다면 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다.**
    - 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야 한다. 이렇게 되면 단위 테스트의 복잡도가 올라간다.
- 유스케이스를 숨긴다.
  - 계층형 아키텍처는 도메인 서비스의 '너비'에 관해 규칙을 강제하지 않는다. 그렇기 때문에 시간이 지나면 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.
  - 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.
  - 결국 서비스를 테스트 하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.
- 동시 작업이 어려워진다.
  - **계층형 아키텍처에서는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을
  만들어야 한다. 그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.**
  - 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. 서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고,
  이는 병합 충돌과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하기 때문이다.


## 02 의존성 역전하기 

- 단일 책임 원칙
  - 단일 책임 원칙의 일반적인 해석: *하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.*
  - 단일 책임 원칙의 실제 정의: **컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.**
  - **'책임'은 사실 '오로지 한 가지 일만 하는 것'보다는 '변경할 이유'로 해석해야 한다.**
- 의존성 역전 원칙
  - 계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.
  - 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.
  - **의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전 시킬 수 있다.** 만약 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기 때문에 이 의존성은 역전시킬 수 없다.
  - **도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에 구현하게 해서 DIP 를 적용 할 수 있다.**
- 클린 아키텍처
  - **도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 한다.**
  - 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.
  - 유스케이스(계층형 아키텍처의 서비스)는 단일 책임을 갖기 위해 조금 더 세분화 돼어 있고, 이를 통해 **넓은 서비스** 문제를 피할 수 있다.
- 육각형 아키텍처(헥사고날 아키텍처)
  - 애플리케이션 코어가 각 어탭터와 상호작용하기 위해 특정 포트를 제공하기 때문에 '포트와 어댑터' 아키텍처라고도 불린다.

## 03 코드 구성하기

- 계층으로 구성하기
  - ~~~
    buckpal
    ├── domain
    │   ├── Account
    │   ├── Activity
    │   ├── AccountRepository
    │   ├── AccountService
    ├── persistence
    │   ├── AccountRepositoryImpl
    └── web
        └── AccountController
    ~~~
  - 애플리케이션의 기능 조각(functional slice) 이나 특성(feature)을 구분 짓는 패키지 경계가 없다.
  - 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
  - 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하고, 해당 서비스 내의 어떤 메서드가 그에 대한 책임을 수행하는지 찾아야 한다.
- 기능으로 구성하기
  - ~~~
    buckpal
    └── account
        ├── Account
        ├── AccountController
        ├── AccountRepository
        ├── AccountRepositoryImpl
        └── SendMoneyService
    ~~~
  - 패키지 경계를 package-private 접근 수준과 결합하면 각 기능 사이의 불필요한 의존성을 방지할 수 있다.
  - 계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 떨어뜨린다.
- 아키텍처적으로 표현력 있는 패키지 구조
  - ~~~
    buckpal
    └── account
        ├── adapter
        │   ├── in
        │   │   └── web
        │   │       └── AccountController
        │   ├── out
        │   │   └── persistence
        │   │       ├── AccountPersistenceAdapter
        │   │       └── SpringDataAccountRepository
        ├── domain
        │   ├── Account
        │   └── Activity
        └── application
            └── SendMoneyService
            └── port
                ├── in
                │   └── SendMoneyUseCases
                └── out
                    ├── LoadAccountPort
                    └── UpdateAccountStatePort
    ~~~
  - 육각형 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터다.
  - 구조의 각 요소들은 패키지 하나씩에 직접 매핑된다. 최상위에는 Account 와 관련된 유스케이스를 구현한 모듈임을 나타내는 account 패키지가 있다.
  - application 패키지는 도메인 모델을 둘러싼 서비스 계층을 포함한다.
  - adapter 패키지는 애플리케이션 계층의 인커밍 포트를 호출하는 인커핑 어댑터와 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함한다.
- **완벽한 방법은 없다. 그러나 표현력 있는 패키지 구조는 적어도 코드와 아키텍처 간의 갭을 줄일 수 있게 해준다.**

## 04 유스케이스 구현하기

- 유스케이스 둘러보기
  - 유스케이스 단계
    1. 입력을 받는다.
    2. 비즈니스 규칙을 검증한다.
    3. 모델 상태를 조작한다.
    4. 출력을 반환한다.
  - 유스케이스는 인커밍 어댑터로부터 입력을 받는다.
  - 저자는 유스케이스 코드가 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안 된다고 생각한다.
  - 유스케이스는 **비즈니스 규칙을**을 검증할 책임이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.
- 입력 유효성 검증
  - 호출하는 어댑터(컨트롤러)가 입력 유효성을 검증하게 되면 유스케이스가 하나 이상의 어댑터에서 호출되게 되면 유효성 검증을 각 어댑터에서 전부 구현해야 한다.
  - 애플리케이션 계층에서 입력 유효성을 검증하자. - **입력 모델이 이 문제를 다루도록 하자!**
    - 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.
  - 입력 모델에 있는 유효성 검증 코드를 통해 유스케이스 구현체 주위에 사실상 오류 방지 계층(하나의 바운디드 컨텍스트를 다른 바운디드 컨텍스트와 격리시키는 계층)을 만들었다.
- 유스케이스마다 다른 입력 모델
  - 등록 유스케이스와 업데이트 유스케이스는 서로 다른 유효성 검증 로직이 필요하다.
  - 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다.
- 비즈니스 규칙 검증하기
  - 입력 유효성과 비즈니스 규칙 검증의 기준은?
    - **비즈니스 규칙을 검증하는 것은 도메인 모델의 현재 상태에 접근해야 하는 반면, 입력 유효성 검증은 그럴 필요가 없다.**
    - 입력 유효성을 검증하는 일은 @NotNull 애너테이션을 붙인 것처럼 선언적으로 구현할 수 있지만 비즈니스 규칙을 검증하는 일은 조금 더 맥락이 필요하다.
    - 입력 유효성을 검증하는 것은 **구문상의**(syntactical) 유효성을 검증하는 것이라고도 할 수 있다.
    - 반면 비즈니스 규칙은 유스케이스의 맥락 속에서 **의미적인**(semantical) 유효성을 검증하는 일이라고 할 수 있다.
    - 비즈니스 규칙 검증은 도메인 엔티티 안에 넣는다.
      - 여의치 않다면 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.
- 유스케이스마다 다른 출력 모델
  - 입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋다.
  - **유스케이스들 간에 같은 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합된다.**
  - **단일 책임 원칙을 적용하고 모델을 분리해서 유지하는 것은 유스케이스의 결합을 제거하는 데 도움이 된다.**
