# 1주차 1장 ~ 5장(2024.05.21)

### API 설계의 특수성

1. API 는 다른 서비스를 개발하기 위한 중간 제품
2. API 변화는 그 API 를 사용한 모든 서비스에 문제를 발생시킴

### API 설계 원칙

- 협업 - 참여한 이해관계자들의 충분한 합의(다수가 동의한 것)
- 성과 - 가치, 도메인을 중심에 둘 것(쓸모있는 것)
- 기술 - 기술 선택은 용도에 맞출 것(기술 중심이 아닐 것)
- 약속 - API 는 고객과의 약속. 큰 책임을 고려할 것(신중히 설계)
- **문서 - 무엇보다 문서가 우선될 것**

### 문서 작성 흐름

- 개발 중심 흐름

1. 개발부터하고 그 결과를 문서로 생성함
2. 개발이 변경되면 자동 생성기가 문서를 변화시킴
3. springDoc 을 비롯한 많은 자동 문서 생성기를 이용함

- API 설계 원칙 흐름

1. 5대 원칙에 근거하여 API 문서가 먼저 작성됨
2. 도메인이나 고객의 변화에 따라 API 의 변화가 생겨남
3. 실제 개발되는 코드나 언어와 무관하게 문서가 운영됨

### 문서 작성 기본 요령

- ADDR 프로세스에 따라
  - Align: 관련된 모든 것을 일정하게 나열해 정리하는 것
    - 마구 가져온 걸 분류하고 정리
    - 119 긴급출동에 대한 모든 도메인을 다 가져와봐
  - Define: 정리된 사실, 목표로부터 뭘 만들지 정의하는 것
  - Design: 정의된 것을 실체화하는 설계(디자인)
    - 아키텍처는 큰거, 디자인은 작은거. API 하나 정도는 디자인
    - 건축에서는 집 한체 아키텍처. 인테리어 디자인이라 하는데 아키텍처가 맞지 않나? 분류하기 어려움. 한국어로는 설계 하나 뿐임.
  - Refine: 만들어진 제품을 다듬고 검수하는 것

1. 도메인분석을 통한 작업스토리(유저의 욕망?!) 추출 및 디지털기능식별
2. 작업스토리별 액티비티단계 캡쳐
3. 이벤트스토밍의 네러티브를 이용한 API 경계식별(애그리거트분리)
4. 식별된 바운디드컨텍스트 내의 구체적인 개별 API 정의
5. REST 구조에 맞는 실제 설계


1. DDD 의 여러 기법 동원
2. 유저스토리매핑, 작업스토리, 스토리스토밍, 유즈케이스, 예제매핑 등

- 이벤트 스토밍 - 유저 네러티브를 중심으로 찾아낸다. 내러티브에 특화되어 있다. 너무 많은 내러티브를 가져오면 어렵다. 사회자가 주요 내러티브를 잘 정하느냐에 따라 성공 유무가 갈린다. 도메인 전문가가
  있을 때 유리하다
- 도메인 스토리텔링 - 참가자 간의 협력구조를 중심으로 도메인 탐색. 전체 도메인을 꿰뚫고 있는 전문가가 없어도 찾아나가는 과정을 겪는다
- 유저 스토리 매핑 - 사용자 간 큰 활동의 흐름을 찾고 하위 단계 탐색. 시작은 유저에서 시작해서 유저의 중심 활동에서 하위 활동들을 찾아내고 어떠한 순서대로 하는지 기술함
- 예제 매핑 - 구체적인 사례를 전개해가면서 하위 단계 탐색. 퍼소나 분석이랑 비슷함
- 스토리 스토밍 - 사용자 간 상호작용과 그 산출물 분석
- 유즈 케이스 - 다양한 내부 모델링 툴을 이용해 다각도로 도메인을 분석

3. 실제 도메인을 파악하고 시장성 있는 기능이 무엇인지 분석하는 과정

### 요청의 개념

1. 요청은 사용자의 니즈를 나타냄
2. 사용자의 니즈는 사용자가 받고 싶은 혜택을 표현함
3. 니즈와 혜택을 일치시키는 과정이 요청의 정의임

- 요청의 특성

1. 사용자가 얻게될 혜택을 추상화하여 포괄적으로 정의할수록 요청 시의 변수가 많아짐
2. 예를 들어 "우리회사 남자대리의 이름을 알고 싶다"로 혜택의 범위를 줄이면 요청시 아무런 변수도 필요없음
3. 헌데 "어떤 회사의 어떤 기간동안 재직한 직원들의 직급과 이름을 알고 싶다"로 혜택을 늘리면 많은 요청 변수가 생겨남
4. 문제는 2번과 3번이 같은 종류의 혜택인가를 **결정**해야함

- 서비스의 전략을 결정해야 한다.

### 요청, 응답의 정의

- 요청 정의 시 유의점

1. 메소드 적용을 엄격하게 할 것인가
2. 멱등성의 범위를 어떻게 정의할 것인가
3. 요청 변수는 공통 포멧을 적용할 것인가
4. 인증, 인가, 상태를 어떻게 처리할 것인가

- 응답 정의 시 유의점

1. 모든 응답의 공통 포맷을 적용할 것인가
2. 응답의 상태별 공통 포맷을 적용할 것인가
3. 정상응답의 페이로드는 공통 포맷을 적용할 것인가
4. 응답코드의 공통 기준을 적용할 것인가
5. 하이퍼미디어를 적용할 것인가

# 2주차 6장 ~ 10장(2024.05.28)

### 멱등성

- 그 짓을 한 번 하나 여러 번 하나 똑같다.
  - 엘리베이터 층번호를 한 번 누르면 취소되지 않음
  - 우주선 발사 버튼을 누르면 로켓이 점화됨
- 멱등하지 않은 예
  - 엘리베이터 층번호가 취소가능(누를 때마다 달라짐)
  - 게시판에 글쓰기 API(호출 시마다 새 글이 등록됨)
- 멱등의 장점
  - 순서나 횟수를 무시하기 때문에 안정적임
  - 복잡한 조합으로 결과를 만들지 않아 동작을 예측하기 쉬움
- API 를 멱등하게 만들수록 복잡성을 낮추고, 예측하기 쉬워진다.
- 업계에서 바라보는 멱등성의 허용범위(대충 GET 이면 멱등?)
  - 게시판 리스트는 사실 조회할 때마다 달라질 수 있음(새글, 글삭제)
  - 회원정보도 조회할 때마다 달라질 수 있음(고쳤으면)

### 비멱등한 연산을 멱등하게 만들기

- 근본적으로는 불가능함. 그렇지만 꼼수가 있다?!
- 비멱등한 부분만 격리하여 최소화하고 나머지는 멱등하게 만든다.
  - 어떤 작업은 전체가 멱등하거나 비멱등하지 않고 일부가 비멱등함
  - 비멱등한 부분만 비멱등 API 로 빼고 나머지를 멱등 API 화함
- 비멱등 구간을 최소화하여 전체 안정성을 높이고 관리성과 보안성을 높임

### 비멱등은 상태 의존적

- 비멱등한 API 가 생기는 근본적인 이유는 상태 때문이다.
  - 미리 엘리베이터 버튼을 누른 상태인가 안누른 상태인가
  - 처음 게시글을 쓰는 것인가 두번째 쓰는 것인가
- 서비스가 상태를 이용하는가 아닌가로 분류할 수 있음
  - 상태서비스 - 앞에 한 일을 기억하여 반응함(chatGPT)
  - 무상태서비스 - 상태없이 언제나 똑같은 결과를 반환함(현재시간)
- 무상태 서비스는 구현과 관리가 쉬워지지만 복잡한 도메인을 제공할 수 없음
- 도메인이란 수많은 if 로 구성되어 있고, 그 if 에 들어갈 모든 것이 상태임

### 상태 기반의 서비스

- 상태를 기반으로 하는 서비스에서는 상태에 따라 다시 분류됨
- 특정 기간 동안만 유지되는 상태
  - 은행의 대기번호표 - 발급 후 호출시까지만 유효함
  - 회원 로그인 상태 - 세션 타임아웃까지만 유효함
  - 일주일동안 이 팝업 안보기
- 장기적으로 유지되는 상태를 이용하기도 함
  - 로그인 유지 서비스
  - 푸쉬알림 안받기
- 키(토큰)기반 구현 방법: 키가 상태를 갖음
  - 유저는 키(토큰)을 발급받아 어떤 행동 시 키를 제출함
  - 키발급조건에 따라 발급여부가 결정되고
  - 발급시 유효범위, 유지조건, 상태 등을 키 파기 시까지 관리함

### 보안이란 상태인가?

- 인증 - 너는 회원이다.
- 인가 - 너는 글을 쓸 수 있다(권리)
- 보안의 정체
  - 내가 너를 회원으로 일정 시간 인증할 동안 인가된 행동을 할 수 있다.
- 일반적으로 키(토큰)으로 구현
- 요청 시 키를 삽입할 수 있는 HTTP 사양 상의 장소
  - 쿠키
  - 헤더
  - 쿼리스트링
  - 요청 본문도 가능하지만 GET, DELETE 는 본문이 없음

### API 문서 작성

- API 는 도메인을 해결함
- 해결해야 할 도메인을 혜택(benefit)이라고 함
- 따라서 문서의 중심을 두괄식으로 혜택을 중심으로 설명함
  - API 의 응답이 왜 혜택인가
  - API 의 응답을 얻기 위한 요청은 무엇인가
  - 그 요청은 도메인상 어떤 상황과 연결되는가
- 멱등성을 비롯한 기술적인 특성으로 인한 사용 상의 유의점도 명시
- 상태가 관련되어 있거나 이전 절차가 관련 되어 있으면 모두를 포함한 포괄적인 사용법을 기술
- OpenAPI 문서가 상세한 프로토콜을 기술한다고 해도 여전이 description 부분에서 사람이 충분히 읽을 수 있는 정보로 재기술되어야함(API 는 문서가 실체다!)

### 모델 기반의 도메인 파악

- 책 내용(펫시터)을 보지 않고, 도메인을 도출 할 수 있을 때까지 연습해보자.
- 모델이란?
  - 현실 세계의 복잡한 실체를 필요한 부분만 남긴 것
  - 필요한 부분? == 기억해야만 하는 부분
    - 학생모델에서 결혼여부, 좋아하는 영화 이런건 필요하지 않다. 학과, 학번등 **도메인에서 기억해야 할 부분이 모델이다.**
- 기억해야만 할 것을 판별하기
  - 기억해야만 할 것 == 도메인 지식 혹은 상태
  - 어떤 도메인 행위를 하는데 필요한 것
- 문제점과 방법론
  - 도메인이 방대하고 여러 측면이 있어서 복잡함
  - 모든 기억해야할 것을 나열하고 분야별로 정리하는 방법 -> 애자일, DDD 에서 사용하는 방법론
  - 분야부터 정해서 분야별로 기억할 것을 정리하는 방법
- 분야 == 바운디드 컨텍스트 == 엔티티 == 에그리것 == 관련된 상태 모음

### 사용자스토리를 통한 모델로부터 API 도출

- 모델은 끝없이 갱신하고 검토 하고를 반복함
- 행위로 검증하기 - 해당 모델로 도메인 내의 행동을 할 수 있나(역할)
- 상태로 검증하기 - 도메인의 요구 기간 동안 원하는 상태가 유지되나
- 위의 두 가지는 추상적인 개념으로 실제 사용하기 어려움
- 사용자 스토리 방법론은 작업스토리와 유사한 혜택을 기준으로 행위와 조건을 기술함(결국 '사용자'는 혜택으로 대변됨)
- 혜택은 네러티브를 갖는 경우가 대부분임. 작은 혜택의 스토리를 연결해 궁극적인 혜택에 도달함. 최종 혜택을 보통 요구사항이라고 함
- 따라서 요구사항은 일반적으로 여러 스토리를 연결한 네러티브로 설명됨 == 요구사항별로 적합한 스토리를 전개해야 함
- 네러티브를 충족시키는 각 스토리는 구현해야할 행위가 되고 이 행위가 바로 API 의 실체임

### 펫시티의 숨겨진 수 많은 정합성

- 사용자와 개는 암시적으로 관계가 존재함
- 구직에 등록된 개는 암시적으로 사용자의 개임
- 사용자는 다수의 역할을 수행할 수 있음
- 구직 등록자는 암시적으로 구직 지원자가 될 수 없음
- 하나의 구직에 같은 사용자가 여러 번 지원할 수 없음
- 구직에 지원하려면 역할에 도우미가 있어야함
- 구직을 등록하려면 역할에 반려동물 주인이 있어야 함
- 명시적인 역할 구분 문자열을 정의하지 않았음

API 사양만으로는 실제 바른 사용을 할 수 없음

- 문서에 이러한 정합성 조건을 전부 기술해야 함(안하면 CS 비용이 됨)
- 더 나은 방법은 API 가 위의 정합조건을 어길 수 없는 형태일 것

# 3주차 15장 ~ 17장(2024.06.04)

- 멘탈모델: 문제를 이해하고 해결하는 데 사용하는 사고방식 (예: 사용자 중심 설계).
- 스토리: 사용자 요구사항을 간단하게 서술한 것 (예: 비밀번호 재설정 기능).
- 네러티브: 스토리를 더 구체적으로 설명하고 배경과 이유를 담은 것 (예: 비밀번호 재설정 기능의 필요성과 구현 방법).

### 스프린트와 사용자 스토리

- 뭘 만들지를 모아둔 것이 사용자 스토리와 네러티브
- 사업목표 - 사용자 스토리 전체를 만들어야 함
- 현실한계 - 출시 일정과 개발 비용을 고려하여 중요한 사용자 스토리를 추려서 개발함
- 모든 사용자 스토리가 모여있는 거대한 저장소를 운영
- 그 저장소에 이번 버전에서 개발할 스토리를 추려냄
- 스프린트란 이번에 개발할 스토리 모음임
- 스프린트가 완성되면 릴리즈하고 사용자에게 **피드백을 수집함**
- 수집된 결과 완료된 스토리, 변경할 스토리가 파악됨
- 이는 스프린트에 속한 스토리 외에 저장소 스토리 전체도 해당됨
- 스프린트를 반복할 때마다 스토리의 전체 수정이 일어남 - 피봇

### 스프린트가 아닌 것

- 요구사항을 개발함 - 개발 마일스톤
- 사용자가 아닌 개발자나 사업자가 확인함 - 기획단계 참고자료
- 피드백을 통해 서비스 그 자체를 바꿀 계획이 없음 - QA 한 개발물
- 스프린트에서 가장 중요한 것
  - **실 사용자의 피드백**
  - 피드백의 진의 - 사용자가 혜택을 느끼고 소비했는가
  - 피드백 반영 - 혜택을 강화하거나 창출하기 위해 재작성
- 스프린트의 성공요소
  - 신속한 피드백이 가능한 실 사용자를 확보하고 릴리즈를 전달할 수 있나?
  - 혜택을 강화하기 위해 모든 걸 바꿀 수 있나?
  - 세 배 빠른 개발속도. 어차피 개발 속도가 느리면 다 허황된 헛소리임

### 피드백

- 피드백을 분류하여 인식함
  - 불편함 - 사용성을 개선(성능, 반응성, UI/UX)
  - 무용함 - 혜택을 재정의
  - 부족함 - 혜택을 강화
  - 파생된 기능요구 - 새로운 혜택을 추가
  - 이상함 - UI/UX 개선. 설명추가는 효과없음. 아예 혜택을 재정의
- 분류도 하지만 강도도 인식해야 함
  - 강한 요구사항 부터 처리 - 핵심 혜택관련 부분은 빨리 해소
  - 강도가 강한 부분을 아예 제거 - 존재 자체가 부정적인지 판별, 제거(의외로 회사는 이 부분을 택하는 경우가 많다?!)
- 스크럼에서는 제품관리자가 권한과 책임을 가짐. 책에서는 오너가 갖고 있음. 피드백을 판정할 포청천을 지정해야 함
- 전체 스토리 저장소를 전수 재검토해야함

### 사용자 스토리 수정

- 피드백에 의해 사용자스토리가 수정됨
  - 추가 - 기존의 스토리와 무관하게 추가됨. 기존의 다른 스토리를 유지할 수도 있지만 새로운 스토리로 인해 변형된 네러티브가 도출되어 버려지거나 수정될 스토리가 간접 발생됨
  - 수정 - 기존 스토리가 변경되어 의존성 있는 스토리에 영향을 줌
- 네러티브 수정
  - 스토리의 수정은 의존된 네러티브를 변경함
  - 네러티브의 변경이 다시 스토리에 변경을 일으킴
  - 안정화될 때까지 계속 순환 변경을 일으킴

### 멘탈모델 재검토

- 스토리와 네러티브를 피드백에 의해 수정함
- 이는 원래 스토리가 가정하는 사용자의 멘탈모델이 달라졌다는걸 의미함
- 피드백에 의한 스토리 수정은 부분적이기 때문에 그 수정으로 인해 전체 멘탈모델의 모순이 발생함
- 사용자를 새로운 스토리가 모두 성립하도록 재정의해야함
- 멘탈모델의 재정의는 다시 모든 스토리와 네러티브에 영향을 끼침
- 또한 멘탈모델은 스토리 뿐 아니라 모든 UI/UX 에 영향을 끼침
- 이것을 2주에 한 번씩?
- 이것이 스프린트의 정체임. 따라서 제품책임자의 역량이 크게 작용함

### DX(developer experience)

- 개발자도 그냥 같은 사용자다.
  - 일관성 - 동작이 이랬다 저랬다 안함
  - 통일성 - 쓰는 방법이 동일한 패턴임
  - 단순성 - 모호하지 않는 범위 내에서 최소의 단일 표현 사용
  - 표준성 - 이미 있는 내용 중 표준이 있다면 따름
  - 불변성 - 함부로 내용이 바뀌지 않음

# 4주차 18장 ~ 21장(2024.06.11)

### 오류메세지

- 일관된 메세지로 보내야 사용측 오류 처리도 일관성을 지킴
- 에러 종류
  - 주의 - 시스템은 허용하지만 보다 나은 방법을 알림(버전변경등)
  - 경고 - 주의 강화판으로 실패가 될 가능성을 시사
  - 실패 - 시스템이 받아들이지 못함
  - 위협 - 시스템에 대한 공격으로 판정
  - 조치 - 사용자의 시도에 대해 이미 처리를 함
- 에러메세지 범위
  - 발생한 에러만 묘사
  - 에러의 원인을 구체적으로 설명
  - 에러에 대한 조치 방법 안내 혹은 강제
  - 트랜잭션 에러 지원

### 실드패턴(Shield Pattern)

- 먼저 모든 값의 정합성을 계산함
- 정합하지 않은 값이 있으면 로직을 종료함
- 이후 정합한 값을 이용하는 비지니스 로직만 전개함
- 로직이 정합성 계산과 비지니스 로직이 섞이면 유지보수가 어려움
- 정합성의 종류
  - 필수와 선택
  - 값 자체 정합: 일치, 범위, 포함, 특수 조건
  - 값 간의 관계
  - 값이 다른 대상을 가리키는 경우
- 정합성 처리 방법
  - 1개가 발견되면 즉시 중지
  - 여러 개를 다 검사하여 정합하지 않은 값을 전부 계산

### 밸리데이션

- 밸리데이션은 직접 정의와 추상 정의가 있음
  - 직접 정의: 밸리데이션 로직을 기술함
  - 추상 정의: 이미 그 타입인 것으로 밸리데이션이 되어있음을 증명
- 직접 정의를 위한 풍부한 타입별 밸리데이터를 활용
- OAS 의 밸리데이터는 기본적으로 AND 조합임
- 그룹화된 OR 을 사용하려면 object 와 oneOf 의 조합을 써야함

### API 버전

- 버전구분
  - major: 사용자측의 코드를 변경해야 함
  - minor: 사용자측의 코드를 변경하면 더 좋아지지만 유지해도 됨
- 전체 버전 vs 엔드포인트별 버전
  - 전체: 서비스 전체의 일관성이 유지됨
  - 엔드포인트: 부분 업데이트를 기민하게 할 수 있다?!
    - 전체 api 의 정합성이 깨질 수 있지 않을까? 쓰지 말자...
- 기타 버전 시스템
  - 채널 운영: 알파, 베타, 까나리 등
  - A/B 테스트 등을 위한 내부 버전 분기
  - SaaS 와 온프레미스버전
  - 별도의 핫픽스버전
- 구버전 운영
  - 버전 공지 정책: deprecated level, remove level
  - 구버전도 운영
    - 종료일을 정함
    - 마이그레이션 유도(기능 차별, 혜택 감소)
- 종결 후 새 버전으로
  - 서비스 독점적 지위 또는 침투 정도에 달려있음(구글, 애플)
  - 서비스 전환 유도를 위한 프로모션 등의 연계
  - 신버전 전환시 반드시 통계를 수집하여 고객 성향을 파악해야 함
- 구버전과 신버전의 호환성
  - 초기버전을 넓게 정의하는 전략은 일반적으로 실패함
  - 오히려 범용적인 타입을 지정하면 생태계 전체가 불안정해짐

### 테스트 가이드

- 얼마나 많은 케이스를 테스트 할 것인가? - 진리표 작성
- 하나의 값을 어디까지 테스트할까?(1~10의 정수)
  - right - 올바른가 = 1~10 사이의 숫자
  - boundary - 경계조건 = 1, 10
  - Inverse - 역관계를 확인하라 = 0,-1,11,"a",5.5,null,[]
  - Crosscheck - 교차 검증하라 = v % 10 -> 0~9
  - Error condition - 에러처리 확인 = 응답값 에러출력
  - Performance - 성능이 허용범위 내인가 = 시간, 메모리 측정