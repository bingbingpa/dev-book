# 1주차 1장 ~ 5장(2024.05.21)

### API 설계의 특수성

1. API 는 다른 서비스를 개발하기 위한 중간 제품
2. API 변화는 그 API 를 사용한 모든 서비스에 문제를 발생시킴

### API 설계 원칙

- 협업 - 참여한 이해관계자들의 충분한 합의(다수가 동의한 것)
- 성과 - 가치, 도메인을 중심에 둘 것(쓸모있는 것)
- 기술 - 기술 선택은 용도에 맞출 것(기술 중심이 아닐 것)
- 약속 - API 는 고객과의 약속. 큰 책임을 고려할 것(신중히 설계)
- **문서 - 무엇보다 문서가 우선될 것**

### 문서 작성 흐름

- 개발 중심 흐름

1. 개발부터하고 그 결과를 문서로 생성함
2. 개발이 변경되면 자동 생성기가 문서를 변화시킴
3. springDoc 을 비롯한 많은 자동 문서 생성기를 이용함

- API 설계 원칙 흐름

1. 5대 원칙에 근거하여 API 문서가 먼저 작성됨
2. 도메인이나 고객의 변화에 따라 API 의 변화가 생겨남
3. 실제 개발되는 코드나 언어와 무관하게 문서가 운영됨

### 문서 작성 기본 요령

- ADDR 프로세스에 따라
    - Align: 관련된 모든 것을 일정하게 나열해 정리하는 것
        - 마구 가져온 걸 분류하고 정리
        - 119 긴급출동에 대한 모든 도메인을 다 가져와봐
    - Define: 정리된 사실, 목표로부터 뭘 만들지 정의하는 것
    - Design: 정의된 것을 실체화하는 설계(디자인)
        - 아키텍처는 큰거, 디자인은 작은거. API 하나 정도는 디자인
        - 건축에서는 집 한체 아키텍처. 인테리어 디자인이라 하는데 아키텍처가 맞지 않나? 분류하기 어려움. 한국어로는 설계 하나 뿐임.
    - Refine: 만들어진 제품을 다듬고 검수하는 것

1. 도메인분석을 통한 작업스토리(유저의 욕망?!) 추출 및 디지털기능식별
2. 작업스토리별 액티비티단계 캡쳐
3. 이벤트스토밍의 네러티브를 이용한 API 경계식별(애그리거트분리)
4. 식별된 바운디드컨텍스트 내의 구체적인 개별 API 정의
5. REST 구조에 맞는 실제 설계


1. DDD 의 여러 기법 동원
2. 유저스토리매핑, 작업스토리, 스토리스토밍, 유즈케이스, 예제매핑 등
    - 이벤트 스토밍 - 유저 네러티브를 중심으로 찾아낸다. 내러티브에 특화되어 있다. 너무 많은 내러티브를 가져오면 어렵다. 사회자가 주요 내러티브를 잘 정하느냐에 따라 성공 유무가 갈린다. 도메인 전문가가
      있을 때 유리하다
    - 도메인 스토리텔링 - 참가자 간의 협력구조를 중심으로 도메인 탐색. 전체 도메인을 꿰뚫고 있는 전문가가 없어도 찾아나가는 과정을 겪는다
    - 유저 스토리 매핑 - 사용자 간 큰 활동의 흐름을 찾고 하위 단계 탐색. 시작은 유저에서 시작해서 유저의 중심 활동에서 하위 활동들을 찾아내고 어떠한 순서대로 하는지 기술함
    - 예제 매핑 - 구체적인 사례를 전개해가면서 하위 단계 탐색. 퍼소나 분석이랑 비슷함
    - 스토리 스토밍 - 사용자 간 상호작용과 그 산출물 분석
    - 유즈 케이스 - 다양한 내부 모델링 툴을 이용해 다각도로 도메인을 분석
3. 실제 도메인을 파악하고 시장성 있는 기능이 무엇인지 분석하는 과정

### 요청의 개념

1. 요청은 사용자의 니즈를 나타냄
2. 사용자의 니즈는 사용자가 받고 싶은 혜택을 표현함
3. 니즈와 혜택을 일치시키는 과정이 요청의 정의임

- 요청의 특성

1. 사용자가 얻게될 혜택을 추상화하여 포괄적으로 정의할수록 요청 시의 변수가 많아짐
2. 예를 들어 "우리회사 남자대리의 이름을 알고 싶다"로 혜택의 범위를 줄이면 요청시 아무런 변수도 필요없음
3. 헌데 "어떤 회사의 어떤 기간동안 재직한 직원들의 직급과 이름을 알고 싶다"로 혜택을 늘리면 많은 요청 변수가 생겨남
4. 문제는 2번과 3번이 같은 종류의 혜택인가를 **결정**해야함
    - 서비스의 전략을 결정해야 한다.

### 요청, 응답의 정의

- 요청 정의 시 유의점

1. 메소드 적용을 엄격하게 할 것인가
2. 멱등성의 범위를 어떻게 정의할 것인가
3. 요청 변수는 공통 포멧을 적용할 것인가
4. 인증, 인가, 상태를 어떻게 처리할 것인가

- 응답 정의 시 유의점

1. 모든 응답의 공통 포맷을 적용할 것인가
2. 응답의 상태별 공통 포맷을 적용할 것인가
3. 정상응답의 페이로드는 공통 포맷을 적용할 것인가
4. 응답코드의 공통 기준을 적용할 것인가
5. 하이퍼미디어를 적용할 것인가

# 2주차 6장 ~ 10장(2024.05.28)

### 멱등성

- 그 짓을 한 번 하나 여러 번 하나 똑같다.
  - 엘리베이터 층번호를 한 번 누르면 취소되지 않음
  - 우주선 발사 버튼을 누르면 로켓이 점화됨
- 멱등하지 않은 예
  - 엘리베이터 층번호가 취소가능(누를 때마다 달라짐)
  - 게시판에 글쓰기 API(호출 시마다 새 글이 등록됨)
- 멱등의 장점
  - 순서나 횟수를 무시하기 때문에 안정적임
  - 복잡한 조합으로 결과를 만들지 않아 동작을 예측하기 쉬움
- API 를 멱등하게 만들수록 복잡성을 낮추고, 예측하기 쉬워진다.
- 업계에서 바라보는 멱등성의 허용범위(대충 GET 이면 멱등?)
  - 게시판 리스트는 사실 조회할 때마다 달라질 수 있음(새글, 글삭제)
  - 회원정보도 조회할 때마다 달라질 수 있음(고쳤으면)

### 비멱등한 연산을 멱등하게 만들기

- 근본적으로는 불가능함. 그렇지만 꼼수가 있다?!
- 비멱등한 부분만 격리하여 최소화하고 나머지는 멱등하게 만든다.
  - 어떤 작업은 전체가 멱등하거나 비멱등하지 않고 일부가 비멱등함
  - 비멱등한 부분만 비멱등 API 로 빼고 나머지를 멱등 API 화함
- 비멱등 구간을 최소화하여 전체 안정성을 높이고 관리성과 보안성을 높임

### 비멱등은 상태 의존적

- 비멱등한 API 가 생기는 근본적인 이유는 상태 때문이다.
  - 미리 엘리베이터 버튼을 누른 상태인가 안누른 상태인가
  - 처음 게시글을 쓰는 것인가 두번째 쓰는 것인가
- 서비스가 상태를 이용하는가 아닌가로 분류할 수 있음
  - 상태서비스 - 앞에 한 일을 기억하여 반응함(chatGPT)
  - 무상태서비스 - 상태없이 언제나 똑같은 결과를 반환함(현재시간)
- 무상태 서비스는 구현과 관리가 쉬워지지만 복잡한 도메인을 제공할 수 없음
- 도메인이란 수많은 if 로 구성되어 있고, 그 if 에 들어갈 모든 것이 상태임

### 상태 기반의 서비스

- 상태를 기반으로 하는 서비스에서는 상태에 따라 다시 분류됨
- 특정 기간 동안만 유지되는 상태
  - 은행의 대기번호표 - 발급 후 호출시까지만 유효함
  - 회원 로그인 상태 - 세션 타임아웃까지만 유효함
  - 일주일동안 이 팝업 안보기
- 장기적으로 유지되는 상태를 이용하기도 함
  - 로그인 유지 서비스
  - 푸쉬알림 안받기
- 키(토큰)기반 구현 방법: 키가 상태를 갖음
  - 유저는 키(토큰)을 발급받아 어떤 행동 시 키를 제출함
  - 키발급조건에 따라 발급여부가 결정되고
  - 발급시 유효범위, 유지조건, 상태 등을 키 파기 시까지 관리함

### 보안이란 상태인가?

- 인증 - 너는 회원이다.
- 인가 - 너는 글을 쓸 수 있다(권리)
- 보안의 정체
  - 내가 너를 회원으로 일정 시간 인증할 동안 인가된 행동을 할 수 있다.
- 일반적으로 키(토큰)으로 구현
- 요청 시 키를 삽입할 수 있는 HTTP 사양 상의 장소
  - 쿠키
  - 헤더
  - 쿼리스트링
  - 요청 본문도 가능하지만 GET, DELETE 는 본문이 없음

### API 문서 작성

- API 는 도메인을 해결함
- 해결해야 할 도메인을 혜택(benefit)이라고 함
- 따라서 문서의 중심을 두괄식으로 혜택을 중심으로 설명함
  - API 의 응답이 왜 혜택인가
  - API 의 응답을 얻기 위한 요청은 무엇인가
  - 그 요청은 도메인상 어떤 상황과 연결되는가
- 멱등성을 비롯한 기술적인 특성으로 인한 사용 상의 유의점도 명시
- 상태가 관련되어 있거나 이전 절차가 관련 되어 있으면 모두를 포함한 포괄적인 사용법을 기술
- OpenAPI 문서가 상세한 프로토콜을 기술한다고 해도 여전이 description 부분에서 사람이 충분히 읽을 수 있는 정보로 재기술되어야함(API 는 문서가 실체다!)

### 모델 기반의 도메인 파악

- 책 내용(펫시터)을 보지 않고, 도메인을 도출 할 수 있을 때까지 연습해보자.
- 모델이란?
  - 현실 세계의 복잡한 실체를 필요한 부분만 남긴 것
  - 필요한 부분? == 기억해야만 하는 부분 
    - 학생모델에서 결혼여부, 좋아하는 영화 이런건 필요하지 않다. 학과, 학번등 **도메인에서 기억해야 할 부분이 모델이다.**
- 기억해야만 할 것을 판별하기
  - 기억해야만 할 것 == 도메인 지식 혹은 상태 
  - 어떤 도메인 행위를 하는데 필요한 것
- 문제점과 방법론
  - 도메인이 방대하고 여러 측면이 있어서 복잡함
  - 모든 기억해야할 것을 나열하고 분야별로 정리하는 방법 -> 애자일, DDD 에서 사용하는 방법론
  - 분야부터 정해서 분야별로 기억할 것을 정리하는 방법
- 분야 == 바운디드 컨텍스트 == 엔티티 == 에그리것 == 관련된 상태 모음

### 사용자스토리를 통한 모델로부터 API 도출

- 모델은 끝없이 갱신하고 검토 하고를 반복함
- 행위로 검증하기 - 해당 모델로 도메인 내의 행동을 할 수 있나(역할)
- 상태로 검증하기 - 도메인의 요구 기간 동안 원하는 상태가 유지되나
- 위의 두 가지는 추상적인 개념으로 실제 사용하기 어려움
- 사용자 스토리 방법론은 작업스토리와 유사한 혜택을 기준으로 행위와 조건을 기술함(결국 '사용자'는 혜택으로 대변됨)
- 혜택은 네러티브를 갖는 경우가 대부분임. 작은 혜택의 스토리를 연결해 궁극적인 혜택에 도달함. 최종 혜택을 보통 요구사항이라고 함
- 따라서 요구사항은 일반적으로 여러 스토리를 연결한 네러티브로 설명됨 == 요구사항별로 적합한 스토리를 전개해야 함
- 네러티브를 충족시키는 각 스토리는 구현해야할 행위가 되고 이 행위가 바로 API 의 실체임

### 펫시티의 숨겨진 수 많은 정합성

- 사용자와 개는 암시적으로 관계가 존재함
- 구직에 등록된 개는 암시적으로 사용자의 개임
- 사용자는 다수의 역할을 수행할 수 있음
- 구직 등록자는 암시적으로 구직 지원자가 될 수 없음
- 하나의 구직에 같은 사용자가 여러 번 지원할 수 없음
- 구직에 지원하려면 역할에 도우미가 있어야함
- 구직을 등록하려면 역할에 반려동물 주인이 있어야 함
- 명시적인 역할 구분 문자열을 정의하지 않았음

API 사양만으로는 실제 바른 사용을 할 수 없음
- 문서에 이러한 정합성 조건을 전부 기술해야 함(안하면 CS 비용이 됨)
- 더 나은 방법은 API 가 위의 정합조건을 어길 수 없는 형태일 것

다음주는 15~18장