# OpenAPI 와 스웨거를 활용한 실전 API 설계

- *조시 포널랫, 루카스 로젠스톡 저/오명운 역 | 책만*

## 1장 API 와 OpenAPI 소개

- API 는 각 서비스가 제공할 수 있는 것이 무엇이고, 다른 서비스와 어떻게 상호작용할 수 있는지를 정의한다.
- 'API 설계자'의 역할은 사용자로부터 피드백을 받아서 변경사항에 대해 미리 협의 할 수 있도록 API 를 설계하는 것이다.
- OpenAPI
  - HTTP 기반 API 를 설명하는 방식을 정해놓은 규격이다.
  - YAML 이나 JSON 파일 형식으로 작성된다.
- 어디서부터 REST 이고 어디까지가 HTTP 인지 명확하게 경계를 짓기는 어렵지만, HTTP 는 프로토콜이고 REST 는 API 를 기술하는 한 방식이라고 이해하자.
- 실무 현장에서는 HTTP 기반 API 를 설계할 때 요구사항과 표준 또는 REST 원칙 준수 사이에서 트레이드오프를 고려한 현명한 결정을 내려야 한다.

## 3장 OpenAPI 정의서 첫인상

- OpenAPI 는 YAML 과 JSON 두 가지 모두 지원한다.
- YAML 은 JSON 의 슈퍼세트라서 JSON 이 필요한 곳에서는 JSON 을 사용할 수 있다.

## 4장 스웨거 에디터로 OpenAPI 정의서 작성

- 스웨커 데이터는 OpenAPI 정의서 작성을 도와주는 도구다.
- 작성한 YAML 문서가 OpenAPI 정의서로 인식되려면 가장 먼저 `openapi` 필드가 포함돼 있어야 한다. 사용할 OpenAPI 명세 버전을 openapi 필드 값으로 지정한다.

## 5장 API 응답 기술하기

- nullable 키워드를 사용할 수 있다.
- 모든 스키마는 type 필드를 가지며 기본 JSON 타입인 object, array, string, number, boolean, integer, null 을 값으로 지정할 수있다.
  - integer 는 정수값만 number 는 음수, 소수점이 있는 값도 가능
- type 이 array 인 배열 스키마는 배열 원소를 기술하기 위해 **items** 프로퍼티를 반드시 포함해야 하며, items 의 배열 원소에 대한
  스키마를 items 의 값으로 지정한다.
- type 이 number 인 숫자 스키마는 minimum, maximum 필드로 최소/최대값을 지정할 수 있다.
- type 이 string 인 문자열 스키마는 patterns 필드에 정규 표현식을 지정할 수 있다.

## 9장 웹 애플리케이션 설계

- 도메인 모델링은 풀어야 할 문제가 있는 도메인(또는 관심 영역)을 가져와서 컴퓨터 소프트웨어로 구현할 수 있도록 기술하는 과정이다.
- `속성`은 이름처럼 어떤 개념을 설명하는 데이터이고, `행위`는 개념이 할 수 있는 것 또는 사용작 그 개념을 가지고 할 수 있는 것을 의미한다.
- 클래스나 관계형 데이터베이스 테이블은 대부분 내부 처리 과정에 적합한 상세 구현에 가깝다.
- 모델 생성을 위해 팀이 가장 먼저 하는 일은 도메인 모델에 포함될 것 같은 모든 개념을 나열하는 것이다.
- 복잡한 도메인 모델링에 너무 깊게 빠져서 정작 중요한 API 설계를 제대로 다루지 못하면 안 되기 때문이다.
- 사용자 스토리
  - 각 사용자 스토리는 소프트웨어 제품의 사용자 관점에서 작성하며, 소프트웨어 안에서 무언가를 달성하기 위해 해야 하는 활동을 기술한다.
  - 사용자 스토리 템플릿
    - *나는 <역할>로서 <기능>을 할 수 있고, 그 결과 <보상>을 받는다.*
    - *<사전 조건>이 주어지면 나는 <기능>을 할 수 있다.*
- 현실에 존재하는 개념과 도메인 모델에 존재하는 개념 사이에 완벽한 매핑은 존재하지 않는다.

## 10장 OpenAPI 를 사용한 API 설계

- 공통으로 재사용 할 수 있는 스키마는 OpenAPI 의 components 섹션에 정의할 수 있다.
- components 에 정의된 스키마를 $ref 키워드를 사용해 참조할 수 있다.

## 11장 API 설계 우선 방식에 변경 워크플로 구축

- 설계 단계에서 모든 문제를 식별하고 해결할 수는 없다. 하지만 설계 단계에서 문제를 발견하고 해결하는 것이 가장 경제적이다.

## 12장 프론트엔드 코드 구현과 변경 대응

- 백엔드 없이 프론트엔드를 구현하기 위해 프리즘(Prism) 목 서버와 openapi.yml 파일로 목서버를 구성할 수 있다.
  - 실제 API 서버가 아니라 정해진 내용만을 정적으로 응답하는 서버이다.
  - 프리즘을 사용하면 Prefer 요청 헤더를 사용해 원하는 예제를 선택해서 테스트에 사용 할 수 있다.

## 15장 2차 API 설계

- 새로운 요구사항이 도출 되면 이 요구사항을 처리하기 위해 기존의 사용자 스토리를 재검토해보자.
  - 검토 후에는 기존의 사용자 스토리에 얼마나 변경이 필요한지 그리고 별도의 사용자 스토리가 필요할지를 파악하자.
- 사용자 스토리 목록을 관련 있는 스토리의 작은 목록으로 줄여보자.
- 개발자의 만족은 소프트웨어 팀 성공의 핵심 요소다.
- 개발자 경험(DX)에서 중요한 사항들
  - 일관성
    - 개발자가 API 내에서 비슷한 엔드포인트에 대해서는 유사한 패턴을 발견할 수 있는 일관성이 있어야 한다.
  - 에러처리
    - 발생한 에러를 개발자가 빨리 해결할 수 있도록 적절한 정보를 최대한 많이 알려줘야 한다.
    - 메시지는 명확하고 실행 가능해야 하고, 일관성이 있어야 한다.

## 16장 OpenAPI 합성을 사용한 스키마 설계

- 도메인 모델에는 더 포괄적이고 일반적인 개념도 있고 더 구체적인 개념도 있으며 이를 잘 활용하는 것이 중요하다.
- 서브타입은 슈퍼타입보다 더 구체적인 개념이다. 바꿔 말하면 슈퍼타입은 서브타입보다 더 일반적이고 포괄적인 개념이다.
  - 반려동물은 슈퍼타입이고 반려견, 반려묘는 서브타입이라고 부를 수 있다.

## 17장 컬렉션 엔드포인트에 필터와 페이징 적용

- **어떤 행위마다 항상 엔드포인트를 추가하는 방식은 단점이 많다.**
  - 이름 충돌이 발생할 수 있다.
  - 모든 행위마다 엔드포인트를 추가 한다면 필터링과 페이징, 정렬을 조합할때마다 엔드포인트를 추가해야 한다? 그렇지만 그 엔드포인트를 정의하기 애매하고 복잡하다.
- 필터링과 페이징, 정렬을 위해 별도의 엔드포인트 대신 `쿼리 파라미터`를 활용하자.
- 조회 작업에 POST 를 사용하는 것은 HTTP 문법에 위배되며 HTTP 캐싱을 사용할 수 없게 되므로 좋은 방법이 아니다.
  - 이런 상황에서는 대부분의 사용 사례를 지원하면서도 쿼리 파라미터를 단순하게 설계하는 편이 훨씬 낫다.

## 18장 problem+json 을 활용한 예외 처리

- 에러 처리를 위한 첫걸음은 먼저 잠재적 이슈를 적절히 분류하는 것이다.
  - 클라이언트 에러, 서버 에러, 네트워크 에러로 분리
- 400: 유효하지 않은 입력
- 403: 허용되지 않은 접근
- 404: 자원이 존재하지 않음
