# CHAPTER 24 지속적 배포

- 고객에게 제품을 보여주지 않은 채 진행하는 기간이 길수록 위험과 비용이 커진다. 심지어 개발자 사기마저 떨어뜨릴 수 있다.
- **코드의 가치는 서브밋 시점이 아니라 고객이 그 기능을 이용할 때 실현된다.**
- 지속적 배포(continuous delivery: CD) 의 가치
    - 민첩성: 자주, 작게 릴리스한다.
    - 자동화: 잦은 릴리스에 수반되는 반복 작업 부담을 줄이거나 없앤다.
    - 격리: 변경을 격리하여 문제를 쉽게 해결할 수 있도록 모듈화된 아키텍처를 지향한다.
    - 신뢰성: 비정상 종료와 지연시간 같은 주요 상태 지표를 측정하고 꾸준히 개선한다.
    - 데이터 중심 의사결정: A/B 실험으로 상태 지표를 비교하여 품질을 높인다.
    - 단계적 출시: 변경을 모두에게 동시에 출시하지 않고 소수의 사용자부터 이용해보게 한다.
- 지속적 배포는 현실적으로 모두가 곧바로 시행할 수 있는 정책은 아니다.
    - 그렇더라도 일하는 문화를 지속적 배포로 가는 중간 형태로 바꿔볼 수는 있다.
    - 즉, 실제로 배포하지는 않되 언제든 배포가 가능하도록 빌드하는 것이다. 이렇게 하면 언젠가 더 자주 릴리스해도 되겠다는 자신감이 싹틀 것이다.
- **당장의 안정을 위한 프로세스 수정에 저항하고 장기적인 아키텍처 개선에 투자해야 한다. 눈앞의 안정만 추구한다면 낡은 개발 프로세스로 회귀하기 쉽다.**
- ‘릴리스 열차 시간에 늦으면 기다리지 않고 출발할 것이다.’
    - **릴리스가 정기적**으로 이루어지는 세상에서는 릴리스 열차를 놓친 엔지니어는 몇 시간 후 출발할 다음 열차를 타면 된다.
- **‘클라이언트 시장의 다양성은 문제가 아니라 현실이다.’**
- 규모가 늘면서 커진 복잡성은 보통 릴리스 주기가 길어지는 형태로 나타난다.
    - 엔지니어 개개인은 코드를 매일 커밋 하더라도 릴리스가 완전히 안전하게 배포되는 데는 일주일 이상이 걸리기도 한다.
    - 그러면 일주일이나 지나서야 문제가 발견되어 일주일 전 코드를 디버깅하는 촌극이 벌어진다.
    - 그러니까 ‘늘 배포하라!!!’ 릴리스 열차가 자주오면 이전의 ‘좋은’상태와의 차이가 적어서 문제가 생겨도 살펴봐야 할 범위가 좁혀진다.
- **핵심 정리**
    - `속도는 팀 스포츠다.` 거대한 코드를 함께 개발하는 팀이 빠르게 굴러가려면 아키텍처를 모듈화하고 지속적으로 통합해야 한다.
    - `변경은 격리해 평가해야 한다.` 문제를 조기에 격리할 수 있도록 기능별로 플래그 가드를 세워두자.
    - `현실을 직시하자.` 기기가 다양하고 사용자 기반이 넓다면 단계적 출시로 대응하자. 프로덕션 환경과 비슷하지 않은 가공의 환경에 맞춰 릴리스하면  진짜 문제를 한참 후에야 알 수 있다.
    - `쓰일 기능만 배포해야 한다.` 기능별로 출시 비용과 창출 가치를 모니터링하여, 고객이 여전히 이용하며 충분한 가치를 제공하고 있는지 확인하자.
    - `원점으로 회귀하자.` 지속적 통합과 지속적 배포를 적용하여 모든 변경에 대한 판단을 더 빠르게 더 많은 데이터에 기초해 내리자.
    - `빠를수록 안전하다.` 적게 수정하여 빨리 자주 배포하면 각 릴리스의 위험이 줄고 시장 변화에 적시에 대응할 수 있다.