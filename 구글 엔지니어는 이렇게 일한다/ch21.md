# CHAPTER 21 의존성 관리

- 소스 관리와 의존성 관리는 ‘이 하위 프로젝트의 개발/업데이트/관리를 우리 조직이 통제하는가?’라는 질문으로 구분지을 수 있다.
    - 예를 들어 리포지터리, 목표, 개발 프로세스를 팀마다 다르게 가져간다면 이 팀들이 생산하는 코드끼리의 연동과 조율은 의존성 관리에 가깝다.
    - 다른 한편, 조직이 크더라도 단 하나의 저장소(모노리포)에서 모든 걸 관리한다면 소스 관리 정책을 훨씬 큰 규모까지 일관되게 적용할 수 있다.
- **’다른 조건이 모두 같다면 의존성 관리 문제보다는 소스 관리 문제를 택하라.’**
    - 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴하다.
    - 더 많은 코드를 조직 내로 가져와 투명성과 통제력을 높인다면 문제가 훨씬 단순해진다.
- 의존성 하나를 관리하는 방법이 중요한 게 아니다. 수많은 의존성들로 구성된 네트워크와 그 네트워크에 미래에 일어날 변화까지 고려해 관리하는 방법을 강구해야 한다.
- 버전 비호환 문제의 대표적인 예는 다이아몬드 의존성 문제이다.
    - 심볼을 숨기거나 이름을 바꿔 컴파일한 라이브러리를 중복 적재하는 방식은 다이아몬드 문제의 충격을 다소 완화해주지만 보편적인 해결책이 될 순 없다.
    - 이러한 요구사항 충돌 문제를 쉽게 해결하는 유일한 방법은 모두와 호환되는 더 상위 혹은 하위 버전의 라이브러리를 찾는 것뿐이다.
- 버전 여러 개를 동시에 내장하는 방식은 함수수준에서는 이름을 고쳐 동작하게 할 수 있으나 의존성 사이에 주고 받는 타입에는 불가능하다.
- **안정된 업그레이드 보장을 전면에 내세우지 않는 업스트림 프로젝트에 의존하는 건 위험하다.**
- 의존성 그래프의 어느 노드라도 영원히 변치 않으리라 가정해서는 안 된다.
- 유의적 버전(SemVer)
    - 의존성 버전을 표기하는 보편적인 방식.
    - 2.4.27 이나 1.1.4 처럼 숫자 세 개로 표현한다. 세 숫자는 차례로 메이저, 마이너, 패치 버전을 의미하며, 각각 다음과 같은 경우에 증가한다.
        - 메이저: API 가 변경되어 의존성을 이용하던 기존 코드를 깨뜨릴 수 있음
        - 마이너: 순수하게 기능 추가만 있음(기존 코드를 깨뜨리지 않음)
        - 패치: API 에 영향을 주지 않는 내부 구현 개선과 버그 수정
- **변경 자체만으로는 파괴적인지 아닌지 판단할 수 없다. ‘어떻게 쓰이고 있는가’라는 맥락이 고려되어야 비로소 판단할 수 있다.**
- 단위 테스트, 지속적 통합, (저렴한) 컴퓨팅 자원이 의존성 관리를 이해하고 처리하는 방식에 변화를 가져올 수 있다. 이 혁신적인 변화는 의존성 관리 문제와 제공자/소비자가 맡을 책임을 바라보는 업계의 시각이 근본적으로 달라져야 가능하다.