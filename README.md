study-modern-java
## ch02 동작 파라미터화 코드 전달하기 
- **동작 파라미터화(behavior parameterization)** : 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블을 의미한다. 즉 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작을 수행 할 수 있다.록
- 동작 파라미터화를 통해 탐색 로직과 각 항목에 적용할 동작을 분리 할 수 있다. 
- 파라미터로 메서드 참조를 넘길 수 있다 . Apple::test 같은 형태로(Apple 클래스의 test 함수를 파라미터로 사용)
- 인터페이스를 구현한 클래스를 파라미터로 사용. ApplePredicate 인터페이스를 구현한 클래스를 new 형태로 해서 넘긴다.
    - 예) List<Apple> greenApples = filter(inventory, new AppleColorPredicate());
- 람다를 사용 할 수 있다. 
    - 예) List<Apple> redApples = filter(inventory, (Apple apple) -> Color.RED.equals(apple.getColor()));

## ch03 람다(lambda) 표현식

- 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다. 
- 람다 표현식은 익명 함수의 일종이다. 이름은 없지만, 파라미터 리스트, 바디, 반환 형식을 가지며 예외를 던질 수 있다. 
- 함수형 인터페이스를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있다.
- 함수형 인터페이스는 하나의 추상 메서드만을 정의하는 인터페이스이다.
- 재네릭 파라미터에는 참조형만 사용할 수 있다. 
- 기본형을 참조형으로 변환하는 기능을 박싱. 참조형을 기본형으로 변한하는 반대 동작을 언박싱. 박싱과 언방식이 자동으로 이루어지는 오토박싱.
- **람다 표현식은 한 번만 할당할 수 있는 지역 변수를 캡처할 수 있다.**
- 자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 활용해서 람다의 파라미터 형식을 추론한다.
- @FunctionalInterface는 함수형 인터페이스임을 가르키는 어노테이션이다. @FunctionalInterface로 인터페이스를 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다.  
- 함수형 인터페이스의 추상 메서드는 람다 표현식의 시그니처를 묘사하고 함수형 인터페이스의 추상 메서드 시그니처를 **함수 디스크립터(function descriptor)**라고 한다.
- 많은 디폴트 메서드가 있더라도 **추상 메서드가 오직 하나면** 함수형 인터페이스다.
- 메서드 참조는 특정 람다 표현식을 축약한 것이라고 생각하면 된다. 
    - 예) inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())); 
    - 메서드 참조로 변경 : inventory.sort(comparing(Apple::getWeight));
- Predicate 인터페이스는 복잡한 프레디케이트를 만들 수 있도록 negate(반전), and, or 세 가지 메서드를 제공한다. 
- Function 인터페이스는 Function 인스턴스를 반환하는 andThen, compose 두 가지 디폴트 메서드를 제공한다. 
    - andThen : 주어진 함수를 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환한다.
        - 예) Function<Integer, Integer> f = x -> x + 1;
        - Function<Integer, Integer> g = x -> x * 2;
        - Function<Integer, Integer> h = f.andThen(g); 
        - int result = h.apply(1); (4를 반환)
    - compose : 인수로 주어진 함수를 먼저 실행한 다음에 그 결과를 외부 함수의 인수로 제공한다. 
        - 위 예제코드 결과에서 f.compose(g); 를 할경우 3을 반환 
 
## ch04 스트림 
- **스트림**은 자바 8 API에 새로 추가된 기능이다. 스트림을 이용하면 선언형(즉, 데이터를 처리하는 임시 구현 코드 대신 질의로 표현)으로 컬렉션 데이터를 처리할 수 있다. 
- filter : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다. 
- map : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다. 
- limit : 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림 크기를 축소 truncate 한다. 
- collect : 다양한 변환 방법을 인수로 받아 스트림에 누적된 요소를 특정 결과로 변환시킨다.  
- **스트림은 단 한 번만 소비할 수 있다.**
- 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. 
- 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조다. 

## ch05 스트림 활용 
- filter 메서드는 프레디케이트(불리언을 반환하는 함수)를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다. 
- distinct 메서드는 고유 요소로 이루어진 스트림을 반환하는데, 고유 여부는 스트림에서 만든 객체의 hashCode, equals 로 결정된다. 
- 자바9에 추가된 takeWhile, dropWhile 
    - takeWhile : 특정한 엘리먼트까지 왔다면 멈추고 그 엘리먼트까지 반환한다. 
    - dropWhile : takeWhile 과 반대개념으로, 프레디케이트가 거짓이 되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다. 
- skip : 처음 n개 요소를 제외한 스트림을 반환한다. 
- flatMap : Array 나 Object 로 감싸져 있는 모든 원소를 단일 원소 스트림으로 반환해준다.
- 검색과 매칭 API : allMatch, anyMatch, noneMatch, findFirst, findAny 
- reduce : 모든 스트림 요소를 처리해서 값으로 도출한다. 

## ch06 스트림으로 데이터 수집 

- Collection : 데이터의 집합, 그룹을 의미하며 크게 List, Set, Queue 3가지 상위 인터페이스로 분류 할 수 있다. 그리고 여기에 Collection 인터페이스를 상속받고 있지 않지만 Map도 Collection으로 분류 된다.
- collect() : Collector 를 매개변수로 하는 스트림의 최종연산
- Collector : collect()에서 필요한 메서드를 정의해 놓은 인터페이스 
- Collectors 클래스는 다양한 기능의 Collector를 구현한 클래스를 제공한다.
	- 변환 : mapping(), toList(), toSet(), toMap(), toCollection(), .... 
	- 통계 : counting(), summingInt(), averagingInt(), maxBy(), minBy(), summarizingInt(), ...
	- 문자열 결합 : joining()
	- 리듀싱 - reducing()
	- 그룹화와 분할 : groupingBy(), partitioningBy(), collectingAndThen()
- **가변 컨테이너 관련 작업이면서 병렬성을 확보하려면 stream.reduce 보다 collect 메서드로 리듀싱 연산을 구현하는 것이 바람직하다.**
- **collect와 reduce의 차이점** : collect 메서드는 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계된 메서드인 반면 reduce는 두 값을 하나로 도출하는 불산변형 연산이다. 가변 컨테이너 관련 작업이면서 병렬성을 확보하려면 collect 메서드로 리듀싱 연산을 구현하는 것이 바람직하다.
- 그룹화 
    - 그룹화 함수가 반환하는 키 그리고 각 키에 대응하는 스트림의 모든 항목 리스트를 값으로 갖는 맵이 반환된다. 
    - 일반적인 분류 함수와 컬렉터를 인수로 받는다. 
        - 예) Map<Dish.Tpye, List<Dish>> caloricDishesByType = menu.stream().collect(groupingBy(**Dish::getType**, **filtering(dish -> dish.getCalories() > 500, toList())**));
    - collectingAndThen : 적용할 컬렉터와 변환 함수를 인수로 받아 다른 컬렉터를 반환한다.
- 분할 
    - partitioningBy : Boolean 형태의 맵 키에 해당하는 리스트를 리턴한다. 
- Collector 인터페이스에 정의된 메서드를 구현해서 커스텀 컬렉션을 개발 할 수 있다.
    - supplier 메서드 : 새로운 결과 컨테이너 만들기
    - accumulator 메서드 : 결과 컨테이너에 요소 추가하기
    - finisher 메서드 : 최종 변환값을 결과 컨테이너로 적용하기
    - combiner 메서드 : 두 결과 컨테이너 병합
    - characteristics 메서드 : 리듀싱 연산을 돕는 힌트 특성 집합 제공 
 
## ch07 병렬 데이터 처리와 성능 

- 컬렉션에 parallelStream 을 호출하면 **병렬 스트림**이 생성된다. 병렬 스트림이란 각가의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
- 벤치마크 : 메시징 응용 프로그램을 위한 테스트 프로그램을 만들고 이 테스트 프로그램의 메시지 처리량이나 기타 성능 요소를 측정하는 프로세스. 
- JMH(Java Microbenchmark Harness) : 어노테이션 기반 방식을 지원하며, 안정적으로 자바 프로그램이나 자바 가상 머신을 대상으로 하는 다른 언어용 벤치마크를 구현할 수 있다.
- 간단하게 스트림을 병렬로 처리할 수 있지만 항상 병렬 처리가 빠른 것은 아니다. 병렬 소프트웨어 동작 방법과 성능은 직관적이지 않을 때가 많으므로 병렬처리를 사용했을 때 성능을 직접 측정해봐야 한다. 
- 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더큰 영향을 미칠 수 있다.

## ch08 컬렉션 API 개선(자바9)

- 자바 9는 적은 원소를 포함하며 바꿀 수 없는 리스트, 집합, 맵을 쉽게 만들 수 있도록 List.of, Set.of, Map.of, Map.ofEntries 등의 컬렉션 팩토리를 지원한다.  
- removeIf : 프레디케이트를 만족하는 요소를 제거한다. List 나 Set 을 구현하거나 그 구현을 상속받은 모든 클래스에서 이용할 수 있다.
- replaceAll : 리스트에서 이용할 수 있는 기능으로 UnaryOperator 함수를 이용해 요소를 바꾼다. 
- sort : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.
- Entry.comparingByValue, Entry.comparingByKey : 맵의 항목을 값 또는 키를 기준으로 정렬 
- getOrDefault : 첫 번째 인수로 키를, 두 번째 인수로 기본값을 받으며 맵에 키가 존재하지 않으면 두 번째 인수로 받은 기본값을 반환한다. 
- computeIfAbsent : 제공된 키에 해당하는 값이 없으면(값이 없거나 널), 키를 이용해 새 값을 계산하고 맵에 추가한다. (정보를 캐시할 때 활용) 
- computeIfPresent : 제공된 키가 존재하면 새 값을 계산하고 맵에 추가한다. 
- compute : 제공된 키로 새 값을 계산하고 맵에 저장한다. pshrokmc1576


## ch09 리팩터링, 테스팅, 디버깅 

- 하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 리팩터링할 수 있다. 
- 익명 클래스를 람다 표현으로 바꿀 때 대상 형식이 모호할 경우에는 명시적 형변환을 이용해서 모호함을 제거할 수 있다. 
- 람다 표현식을 메서드 참조로 리팩터링하기 
- 명령형 데이터 처리를 스트림으로 리팩터링하기 

## ch10 람다를 이용한 도메인 전용 언어 

- DSL(domain-specific languages)은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어다.
- 내부 DSL : 순수 자바 코드같은 기존 호스팅 언어를 기반으로 구현한다. 
- 외부 DSL : 호스팅 언어와는 독립적으로 자체의 문법을 가진다. 

## ch11 null 대신 Optional 클래스 

- null 을 참조하려 하면 NullPointerException 이 발생하지만 Optional.empty() 는 Optional 객체이므로 발생하지 않는다. 
- Optional 팩토리 메서드 
    - Optional.empty : 빈 Optional 객체 생성
    - Optional.of : null 이 아닌 값을 포함 하는 Optional 생성
    - Optional.ofNullable : null 값을 저장 할 수 있는 Optional 을 생성
- get : 값을 읽는 가장 간단한 메서드면서 동시에 가장 안전하지 않은 메서드다. 
- orElse : Optional 이 값을 포함하지 않을 때 기본값을 제공할 수 있다. 
- orElseThrow : Optional 이 비었을 때 예외를 발생시킨다. 
- ifPresent : 값이 존재할 때 인수로 넘겨준 동작을 실행할 수 있다. 값이 없으면 아무 일도 일어나지 않는다. 
- ifPresentOrElse(java9) : Optional 이 비었을 때 실행할 수 있는 Runnable 을 인수로 받는다는 점만 ifPresent 와 다르다.  
- 기본형 Optional(OptionalInt, OptionalLong, OptionalDouble 등) 은 가급적 사용 하지 않도록 한다.

## ch12 새로운 날짜와 시간 API

- LocalDate : 시간을 제외한 날짜를 표현 하는 불변 객체.
- LocalDateTime : 날짜와 시간을 모두 표현 할 수 있다.
- Instant : 유닉스 에포크 시간(1970년 1월 1일 0시 0분 0초 UTC)을 기준으로 특정 지점까지의 시간을 초로 표현

## ch13 디폴트 메서드 

- default 키워드는 해당 메서드가 디폴트 메서드임을 가리킨다. 
- 바이너리 호환성 : 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황을 의미한다. 
- 소스 호환성 : 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일 할 수 있음을 의미한다.
- 동작 호환성 : 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행함을 의미한다.
- 추상 클래스와 인터페이스의 차이점 
    - 클래스는 하나의 추상 클래스만 상속 받을 수 있지만 인터페이스를 여러 개 구현할 수 있다.
    - 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있지만, 인터페이스는 인스턴스 변수를 가질 수 없다.
- 같은 시그니처를 갖는 메서드가 있을 경우 해석 규칙 
    - 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다. 
    - 디폴트 메서드를 제공하는 가장 하위의 서브인터페이스가 우선권을 갖는다.
    - 두 메서드의 시그니처가 같고, 상속관계로도 충돌 문제를 핼결할 수 없을 때는 디폴트 메서드를 사용하는 클래스에서 메서드를 오버라이드해서 어떤 디폴트 메서드를 호출할지 명시적으로 결정해야 한다.
    
## ch14 자바 모듈 시스템(자바9)
- 관심사 분리(Separation Of Concerns) : 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙. 
- 정보 은닉 : 세부 구현을 숨기도록 장려하는 원칙. 
- 캡슐화 : 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미한다. 
- module-info.java 파일에 모듈의 이름, 필요한 의존성(requires) 과 공개 API(exports) 를 정의한다.

## ch15 CompletableFuture 와 리액티브 프로그래밍 컨셉의 기초

- 동시성은 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성으로 실행이 서로 겹칠 수 있는 반면 병렬성은 병렬 실행을 하드웨어 수준에서 지원한다.
- 스트림을 이용해 스레드 사용 패턴을 추상화 할 수 있다.
- 리액티브 시스템은 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 프로그램을 카리킨다.
- 스레드 풀은 유용하지만 태스크가 많아지면 문제가 발생한다. 
- CompletableFuture 클래스는 한 번의 비동기 연산을 표현한다. 콤비네이터로 비동기 연산을 조합함으로 Future 를 이용할 때 발생했던 기존의 블로킹 문제를 해결 할 수 있다.

## ch16 CompletableFuture: 안정적 비동기 프로그래밍 

- Future : 비동기 계산을 모델링 하는데 사용 한다.
- Future 를 활용 할 때는 get 메서드를 오버로드해서 우리 스레드가 대기할 최대 타임아웃 시간을 설정하는 것이 좋다.
- 블록 문제가 발생할 수 있는 상황에서는 타임아웃을 활용하는 것이 좋다.
- CompletableFuture : Future 인터페이스를 구현한 클래스로 Stream 과 비슷한 패턴, 즉 람다 표현식과 파이프라이닝을 활용한다.
    - supplyAsync : Supplier 를 인수로 받아서 CompletetableFuture 를 반환 한다. 
    - thenCompose : 첫 번째 연산의 결과를 두 번째 연산으로 전달한다.
    - thenCombine : CompletableFuture 를 합친다.
    - orTimeout(자바9) : 타임아웃 설정 
    - completeOnTimeout(자바9) : 정해진 시간동안 응답이 없을 경우 기본 값을 반환한다. 
- 스레드 풀 크기 조절 : N(threads) = N(cpu) * U(cpu) * (1 + W/C)
    - N(cpu) : Runtime.getRuntime().availableProcessors() 가 반환하는 코어 수 (jshell 에서 확인 가능)
    - U(cp) 는 0 과 1 사이의 값을 갖는 CPU 활용 비율 
    - W/C 는 대기시간과 계산시간의 비율 
- **데몬 스레드** : 자바에서 일반 스레드가 실행 중이면 자바 프로그램은 종료되지 않는다. 따라서 어떤 이벤트를 한없이 기다리면서 종료되지 않는 일반 스레드가 있으면 문제가 될 수 있다. 
반면 데몬 스레드는 자바 프로그램이 종료될 때 강제로 실행이 종료될 수 있다.
- **애플리케이션의 특성에 맞는 Executor 를 만들어 CompletableFuture 를 활용하는 것이 바람직하다.** 
- I/O 가 포함되지 않는 계산 중심의 동작을 실행할 때는 스트림 인터페이스(parallelStream)가 가장 구현하기 쉽고 효율적수 있고, I/O 를 기다리는 작업을 병렬로 실행할 때는 CompletableFuture 가 더 많은 유연성
을 제공하고 효율적이다. 
-  

## ch17 리액티브 프로그래밍(자바9)

- 리액티브 프로그래밍
    - 데이터 흐름과 변화 전파에 중점을 둔 프로그래밍 패러다임으로, 프로그래밍 언어로 정적 또는 동적인 데이터 흐름을 쉽게 표현할 수 있어야 하며,
데이터 흐름을 통해 하부 실행 모델이 자동으로 변화를 전파할 수 있는 것을 의미한다.
    - 리액티브 스트림을 사용하는 프로그래밍이다.
    - 리액티브 스트림은 잠재먹으로 무한의 비동기 데이터를 순서대로 그리고 블록하지 않는 역압력을 전제해 처리하는 표준 기술이다.
    - 역압력은 발행-구독 프로토콜에서 이벤트 스트림의 구독자가 발행자가 이벤트를 제공하는 속도보다 느린 속도로 이벤트를 소비하면서 문제가 발생하지 않도록 보장하는 장치다.
- 리액티브 핵심 원칙
    - 반응성 : 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다. 
    - 회복성 : 장애가 발생해도 시스템은 반응해야 한다. 
    - 탄력성 : 리액티브 시스템에서는 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다. 
    - 메시지 주도 : 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성등을 지원 할 수 있도록 시스템을 구성하는 컴포넌트의 경계를 명확하게 정의해야 한다. 
- 메시지는 정의된 목적지 하나를 향하는 반면, 이벤트는 관련 이벤트를 관찰하도록 등록한 컴포넌트가 수신한다는 점이 다르다.
- 자바 9에서 리액티브 프로그래밍을 제공하는 클래서 java.util.concurrent.Flow 가 추가 됐다. 
    - publisher
    - Subscriber
    - Subscription
    - Processor
- Flow API는 구현을 제공하지 않는다. 리액티브 라이브러리로는 Akka, RxJava 등이 있다. 

## ch18 함수형 관점으로 생각하기 

- 함수형 프로그래밍이란 함수를 이용하는 프로그래밍이고, **함수**란 수학전인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다.**
- 함수형이라면 **함수나 메서드가 어떤 예외도 일으키지 않아야 한다.**
- **참조 투명성** : 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환해야 한다. 
- 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는데 도움이 된다. 
- 자바에서는 고전 방식의 재귀보다는 꼬리 재구를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다. 

## ch19 함수형 프로그래밍 기법 

- 일급 함수 : 인수로 전달하거나, 결과로 반환하거나, 자료구조에 저장할 수 있는 함수.
- 고차원 함수 : 하나 이상의 함수를 인수로 받아서 다른 함수를 반환하는 함수.(comparing, andThen, compose 등)
- 커링 : 각 단계에서 하나의 인자를 가지는 함수를 생성하면서, 함수의 인자를 하나씩 하나씩 적용하는 것이다. 
- 함수형 메서드에서는 전역 자료구조나 인수로 전달된 구조를 갱신할 수 없다. 자료구조를 바꾼다면 같은 메서드를 두 번 호출했을 때 결과가 달라지면서 참조 투명성에 위배되고
인수를 결과로 단순하게 매핑 할 수 있는 능력이 상실되기 때문이다.
- 함수형에서의 **영속** : 저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태 

## ch20 OOP와 FP의 조화 : 자바와 스칼라 비교 

- 스칼라 : 객체지향과 함수형 프로그래밍을 혼합한 언어.
- 스칼라는 자바에 비해 풍부한 함수 관련 기능을 제공한다. 함수 형식, 지역 변수에 접근할 수 있는 클로저, 내장 커링 형식 등을 지원.
- 스클라의 클래스는 암묵적으로 생성자, 게터, 세터를 제공한다.  
- 스칼라는 트레이트를 지원한다. 트레이트는 필드와 디폴트 메서드를 포함 할 수 있는 인터페이스다.


