## study-core-java9

- 자바에서 protected는 패키지 수준 접근 권한을 부여하므로 다른 패키지에서 시도하는 접근만 보호한다.
- 클래스를 확장하고 인터페이스를 구현하는 클래스에서 클래스와 인터페이스에 있는 메서드 이름이 같은 경우에 항상 슈퍼 클래스 
  구현이 인터페이스 구현보다 우선한다. 그러므로 서브클래스에서 충돌을 해결할 필요가 없다. 반면 인터페이스 두 개에서 이름이 
  같은 기본 메서드를 상속받을 때는 충돌을 해결해야 한다. 
- 모든 클래스는 직간접적으로 Object 클래스를 확장한다. Object 클래스에 정의된 toString 메서드는 클래스 이름과 해시 코드를 출력한다.
- 구현한 클래스가 toString 메서드를 오버라이드 하지 않을 경우 "java.io.클래스명@2f3435" 과 같이 이름과 해시코드로 출력된다.
- 배열의 경우는 Arrays.toString(배열)로 출력할 수 있다. 다차원 배열의 경우에는 Arrays.deepToString을 사용한다.
- equals 메서드를 오버라이드할 때마다 이것과 호환되는 hashCode 메서드도 반드시 작성해야 한다. 
- clone 메서드의 목적은 객체의 '복제본(원본과 상태가 같은 별개의 객체)'를 만드는 것이다. 두 객체 중 하나의 상태를 변경하더라도 나머지 하나는 변하지 않는다. 


- 제네릭 클래스는 타입 매개변수가 한개 이상 있는 클래스이다. 
- 기본 타입으로는 타입 매개변수를 인스턴스화할 수 없다. 예를 들어 Entry<String, int>는 자바에서 쓸 수 없다. 
- 제네릭 클래스의 객체를 생성할 때 생성자의 타입 매개변수를 생략 할수 있다. 
  예를 들어 Entry<String, Integer> entry = new Entry<>("Fred", 42); 는 new Entry<String, Integer>("Fred",42)와 같다.
- 제네릭 메서드를 선언할 때는 타입 매개변수를 제어자와 반환 타입 사이에 두어야 한다.
  public static <T> void swap(T[] array, int i, int j)
- 제네릭 클래스나 메서드가 받는 타입 파라미터를 제한하고 싶은 경우에 타입 경계를 사용


- Set은 요소를 특정 위치에 삽입하지 않으며, 중복 요소를 허용하지 않는다.
- SortedSet에는 정렬 순서로 요소를 순회하는 기능이 있으며, NavigableSet에는 이웃 요소를 찾는 메서드가 있다. 
- stack은 한쪽 끝에서 요소를 추가하고 제거하는 자료 구조다. 
- Queue는 삽입 순서를 유지하지만, 테일에서만 삽입하고, 헤드에서만 제거 할 수 있다. 
- Deque은 더블 엔디드 큐로 양쪽 끝에서 삽입과 제거를 할 수 있다. 
- 맵은 연관된 키와 값을 저장한다. 연관된 키와 값을 새로 추가하거나 기존 키 값을 변경할때는 put을 호출한다. 
- 키를 정렬 순서로 방문하려면 TreeMap을 사용한다. 
- int count = counts.getOrDefault("Alice", 0); 이렇게 하면 키가 없을때 0이 반환된다.
- 우선순위 큐는 요소를 무작위로 삽입해도 정렬된 순서로 꺼낸다. 즉, remove메서드를 호출할 때마다 우선순위 큐에서 현재 가장 작은 요소를 얻는다. 


- 스트림은 요소를 저장하지 않는다. 요소는 스트림을 지원하는 컬렉션에 저장하거나 필요할 때 생성한다.
- 스트림 연산은 원본을 변경하지 않는다. 
- 스트림 연산은 가능하면 지연(lazy)방식으로 작동한다. 즉, 필요하기 전까지는 연산 결과를 실행하지 않는다. 
- Collection 인터페이스의 stream 메서드를 사용하면 어떤 컬렉션이든 스트림으로 변환 할 수 있다. 하지만 배열일 때는 정적 메서드 Stream.of를 사용해야 한다. 
- 배열의 일부에서 스트림을 만들려면 Arrays.strea(array, from, to) 를 사용해야 한다.
- 요소가 없는 스트림을 만들려면 정적 메서드 Stream.empty를 사용한다. 
- filter 변환은 특정 조건과 일치하는 요소로 구성된 새 스트림을 돌려준다. 
- stream.limit(n) 호출은 요소 n개 이후(또는 원본 스트림이 n보다 짧다면 원본 스트림이 끝날 때) 끝나는 새 스트림을 반환한다. 
  Stream<Double> randoms = Stream.generate(Math::random).limit(100);
- stream.skip(n) 호출은 limit와는 반대 작업을 수행한다. 즉, 처음 n개 요소를 버린다. 
- stream.takeWhile(predicate) 호출은 프레디케이트가 참인 동안 스트림에서 모든 요소를 가져온 후 중단한다. 
- stream.dropWhile(predicate) 메서드는 반대로 조건이 참인 동안 요소를 버리고, 조건이 처음 거짓으로 판명된 요소부터 시작해 모든 요소의 스트림을 돌려준다. 
- distinct 메서드는 원본 스트림에 있는 요소의 중복을 제외하고 같은 순서로 돌려주는 스트림을 반환한다. 
