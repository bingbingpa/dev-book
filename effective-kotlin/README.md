# 이펙티브 코틀린 *안전성, 가독성, 코드 설계, 효율성을 향상시키기 위한 52가지 전략과 기법*
- *마르친 모스칼라 저/윤인성 역 | 인사이트(insight) |*

<br>

## 아이템 목록

## 1장 안정성

#### [[아이템1] 가변성을 제한하라](#아이템1-가변성을-제한하라-1)
#### [[아이템2] 변수의 스코프를 최소화하라](#아이템2-변수의-스코프를-최소화하라-1)
#### [[아이템3] 최대한 플랫폼 타입을 사용하지 말라](#아이템3-최대한-플랫폼-타입을-사용하지-말라-1)
#### [[아이템4] inferred 타입으로 리턴하지 말라](#아이템4-inferred-타입으로-리턴하지-말라-1)
#### [[아이템5] 예외를 활용해 코드에 제한을 걸어라](#아이템5-예외를-활용해-코드에-제한을-걸어라-1)
#### [[아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라](#아이템6-사용자-정의-오류보다는-표준-오류를-사용하라-1)
#### [[아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라](#아이템7-결과-부족이-발생할-경우-null-과-Failure-를-사용하라-1)
#### [[아이템8] 적절하게 null 을 처리하라](#아이템8-적절하게-null-을-처리하라-1)
#### [[아이템9] use 를 사용하여 리소스를 닫아라](#아이템9-use-를-사용하여-리소스를-닫아라-1)
#### [[아이템10] 단위 테스트를 만들어라](#아이템10-단위-테스트를-만들어라-1)

## 2장 가독성

#### [[아이템11] 가독성을 목표로 설계하라](#아이템11-가독성을-목표로-설계하라-1)
#### [[아이템12] 연산자 오버로드를 할 때는 의미에 맞게 사용하라](#아이템12-연산자-오버로드를-할-때는-의미에-맞게-사용하라-1)
#### [[아이템13] Unit?을 리턴하지 말라](#아이템13-unit을-리턴하지-말라-1)
#### [[아이템14] 변수 타입이 명확하지 않은 경우 확실하게 지정하라](#아이템14-변수-타입이-명확하지-않은-경우-확실하게-지정하라-1)
#### [[아이템15] 리시버를 명시적으로 참조하라](#아이템15-리시버를-명시적으로-참조하라-1)
#### [[아이템16] 프로퍼티는 동작이 아니라 상태를 나타내야 한다](#아이템16-프로퍼티는-동작이-아니라-상태를-나타내야-한다-1)
#### [[아이템17] 이름 있는 아규먼트를 사용하라](#아이템17-이름-있는-아규먼트를-사용하라-1)
#### [[아이템18] 코딩 컨벤션을 지켜라](#아이템18-코딩-컨벤션을-지켜라-1)

## 3장 가독성

#### [[아이템19] knowledge 를 반복하여 사용하지 말라](#아이템19-knowledge-를-반복하여-사용하지-말라-1)
#### [[아이템20] 일반적인 알고리즘을 반복해서 구현하지 말라](#아이템20-일반적인-알고리즘을-반복해서-구현하지-말라-1)
#### [[아이템21] 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라](#아이템21-일반적인-프로퍼티-패턴은-프로퍼티-위임으로-만들어라-1)
#### [[아이템22] 일반적인 알고리즘을 구현할 때 제네릭을 사용하라](#아이템22-일반적인-알고리즘을-구현할-때-제네릭을-사용하라-1)
#### [[아이템23] 타입 파라미터의 섀도잉을 피하라](#아이템23-타입-파라미터의-섀도잉을-피하라-1)
#### [[아이템24] 제네릭 타입과 variance 한정자를 활용하라](#아이템24-제네릭-타입과-variance-한정자를-활용하라-1)
#### [[아이템25] 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라](#아이템25-공통-모듈을-추출해서-여러-플랫폼에서-재사용하라-1)

## 4장 추상화 설계

#### [[아이템26] 함수 내부의 추상화 레벨을 통일하라](#아이템26-함수-내부의-추상화-레벨을-통일하라-1)
#### [[아이템27] 변화로부터 코드를 보호하려면 추상화를 사용하라](#아이템27-변화로부터-코드를-보호하려면-추상화를-사용하라-1)
#### [[아이템28] API 안정성을 확인하라](#아이템28-API-안정성을-확인하라-1)
#### [[아이템29] 외부 API 를 랩(wrap)해서 사용하라](#아이템29-외부-api-를-랩wrap해서-사용하라-1)
#### [[아이템30] 요소의 가시성을 최소화하라](#아이템30-요소의-가시성을-최소화하라-1)
#### [[아이템31] 문서로 규약을 정의하라](#아이템31-문서로-규약을-정의하라-1)
#### [[아이템32] 추상화 규약을 지켜라](#아이템32-추상화-규약을-지켜라-1)

## 6장 클래스 설계

#### [[아이템36] 상속보다는 컴포지션을 사용하라](#아이템36-상속보다는-컴포지션을-사용하라-1)
#### [[아이템37] 데이터 집합 표현에 data 한정자를 사용하라](#아이템37-데이터-집합-표현에-data-한정자를-사용하라-1)
#### [[아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라](#아이템38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라-1)
#### [[아이템39] 태그 클래스보다는 클래스 계층을 사용하라](#아이템39-태그-클래스보다는-클래스-계층을-사용하라-1)
#### [[아이템40] equals 의 규약을 지켜라](#아이템40-equals-의-규약을-지켜라-1)
#### [[아이템41] hasCode 의 규약을 지켜라](#아이템41-hasCode-의-규약을-지켜라-1)
#### [[아이템42] compareTo 의 규약을 지켜라](#아이템42-compareTo-의-규약을-지켜라-1)
#### [[아이템43] API 의 필수적이지 않는 부분을 확장 함수로 추출하라](#아이템43-API-의-필수적이지-않는-부분을-확장-함수로-추출하라-1)
#### [[아이템44] 멤버 확장 함수의 사용을 피하라](#아이템44-멤버-확장-함수의-사용을-피하라-1)

<br>

# 1부 좋은 코드

<br>

## 1장 안정성 

### [아이템1] 가변성을 제한하라

- 상태를 갖게 하는 경우 발생하는 문제점 
  - 프로그램을 이해하고 디버그하기 힘들어진다. 
    - 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 추적하는 것이 힘들어진다.
  - 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워진다. 또한 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없다.
  - 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다. 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있다.
  - 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
- 코틀린에서 가변성 제한하기
  - 읽기 전용 프로퍼티(val)
    - 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면, 내부적으로 변할 수 있다.
    - var 은 게터와 세터를 모두 제공하지만, val 은 변경이 불가능하므로 게터만 제공한다.
    - **변수를 게터로 정의하면 스마트 캐스트를 할수 없다. 게터를 활용하므로, 값을 사용하는 시점에 따라서 다른 결과가 나올 수 있기 때문이다.**
      - 변수가 final 이고, 사용자 정의 게터를 갖지 않을 경우 스마트 캐스트 할 수 있다.
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기 
    - 읽기 전용: Iterable, Collection, Set, List
    - 읽고 쓰기 가능: MutableIterable, MutableCollection, MutableSet, MutableList
    - mutable 이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것이다.
    - **컬렉션 다운캐스팅은 예측하지 못한 결과를 초래하므로 사용하지 말자.**
      - 읽기 전용에서 mutable 로 변경해야 한다면 복제를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList 를 활용해야 한다.
  - 데이터 클래스의 copy
- immutable 객체 사용의 장점
  - 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
  - immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
  - immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
  - immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 된다.
  - immutable 객체는 set 또는 map 의 키로 사용할 수 있다.
    - mutable 객체는 요소에 수정이 일어나면 해시 테이블 내부에서 요소를 찾을 수 없게 되어 버리기 때문에 키로 사용할 수 없다.
- Delegates.observable 을 사용하면, 리스트에 변경이 있을 때 로그를 출력할 수 있다.
- **mutable 객체를 외부에 노출하지 않는 것이 좋다.**

### [아이템2] 변수의 스코프를 최소화하라

- 상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는 것이 좋다.
  - 프로퍼티보다는 지역 변수를 사용하는 것이 좋다. 
  - 최대한 좁은 스코프를 갖게 변수를 사용한다.
  - var 보다는 val 을 사용하는 것이 좋다. 
  - 람다에서는 변수를 갭처하기 때문에 주의하자. 시퀀스를 활용하는 식에서 변수를 캡처하면 의도치 않은 결과가 나올수도 있다.

### [아이템3] 최대한 플랫폼 타입을 사용하지 말라

- 플랫폼 타입이란, 다은 프로그래밍 언어에서 전달되어서 nullable 인지 알 수 없는 타입을 말한다.
- 자바를 코틀린과 함께 사용할 때, 가능한 @Nullable 과 @NotNull 어노테이션을 붙여서 사용하자.

### [아이템4] inferred 타입으로 리턴하지 말라

- **타입 추론으로 할당 할 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설전된다. 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다.**
- 타입 추론으로 할당된 변수가 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있다.
- 안전을 위해서 외부 API 를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자. 
- inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수도 있다는걸 기억하자! 

### [아이템5] 예외를 활용해 코드에 제한을 걸어라

- 코틀린에서 코드의 동젝에 제한을 거는 방법들
  - require 블록: 아규먼트와 관련된 예측을 정의할 때 사용 
  - check 블록: 상태와 관련된 동작 제한
  - assert 블록: 어떤 것이 true 인지 확인. assert 블록은 테스트 모드에서만 작동한다. 
  - return 또는 throw 와 함께 활용하는 Elvis 연산자
- 아규먼트
  - require 함수는 제한을 확인하고, 제한을 만족하지 못할 때 무조건적으로 IllegalArgumentException 을 throw 한다.
  - 람다를 활용해서 지연 메시지를 정의할수도 있다. 
    - ~~~kotlin
      require(n >= 0) { "Cannot calculate factorial of $n because it is smaller than 0"}
      ~~~
- 상태
  - 어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할때 사용한다. 
    - 어떤 객체가 미리 초기화 되어 있어야만 처리를 하게 하고 싶은 경우 
    - 객체를 사용할 수 있는 시점에 사용하고 싶은 경우 등등
  - check 함수는 require 와 비슷하지만, 지정된 예측을 만족하지 못할 때, IllegalStateException 을 throw 한다.
  - 상태가 올바른지 확인할 때 사용한다. 이러한 확인은 사용자가 규약을 어기고, 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 한다.
  - 일반적으로 require 블록 뒤에 배치한다.
- Assert 계열 함수 사용
  - assert 조건은 -ea JVM 옵션을 활성화 해야 확인 할 수 있다.
- nullability 와 스마트 캐스팅
  - 코틀린에서 require 와 check 블록으로 어떤 조건을 확인해서 true 가 나왔다면, 해당 조건은 이후로도 true 일거라고 가정한다.
  - 따라서 이를 활용해서 타입 비교를 했다면, 스마트 캐스트가 작동한다.
  - 어떤 대상이 null 인지 확인할 때 굉장히 유용하다! requireNotNull, checkNotNull 을 사용해도 괜찮다.
  - **nullability 를 목적으로, 오른쪽 throw 또는 return 을 두고 Elvis 연산자를 활용하면 유용하다.**
    - 오른쪽에 return 을 넣으면, 오류를 발생시키지 않고 단순하게 함수를 중지할 수도 있다.
    - **프로퍼티에 문제가 있어서 null 일 때 여러 처리를 해야 할 때도, return/throw 와 run 함수를 조합해서 활용할 수 있다.**

### [아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라

- 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋다. 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋다.
- IllegalArgumentException, IllegalStateException: 아이템5에서 다룬 require 와 check 를 사용해 throw 할 수 있는 예외
- IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어나는 경우 (예: ArrayList.get(Int))
- ConcurrentModificationException: 동시 수정을 금지 했는데, 발생했을 경우 
- UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없는 경우
- NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않는 경우

### [아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라

- 함수가 원하는 결과를 만들어 낼 수 없는 경우들 
  - 서버로부터 데이터를 읽어 들이려고 했는데, 네트워크 문제로 읽어 들이지 못한 경우 
  - 조건에 맞는 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우 
  - 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트 형식이 맞지 않는 경우 등등 
- 이러한 상황을 처리하는 메커니즘 두 가지 
  - null 또는 '실패를 나타내는 sealed 클래스(일반적으로 Failure 라는 이름을 붙인다.)'를 리턴
  - 예외를 throw 
- 위의 두 가지는 중요한 차이점이 있다. 일단 예외는 정보를 전달하는 방법으로 사용하면 안되고, 특별한 상황을 나타내야 하며, 처리되어야 한다.
  - 코틀린의 모든 예외는 unchecked 예외다. 따라서 사용자가 예외를 처리하지 않을 수도 있다.
    - 사용자가 반드시 처리하게 강제되는 예외를 checked 예외라고 부르고, 처리하지 않아도 실행에 문제가 없는 예외을 unchecked 예외라고 부른다.
  - 예외는 예외적인 상황을 처리하기 위해서 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않는다.
  - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한된다.
- **충분히 예측할 수 있는 범위의 오류는 null 과 Failure 를 사용하고, 예측하기 어려운 예외적인 범위의 오류는 예외를 throw 해서 처리하는 것이 좋다.**
- null 값과 sealed result 클래스의 차이는 추가적인 정보의 전달 유무다.

### [아이템8] 적절하게 null 을 처리하라

- nullable 타입을 처리하는 방법들
  - ?., 스마트캐스팅, Elvis 연산자 들을 활용해서 안전하게 처리 
  - 오류를 throw
  - 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꾼다.
- !! 은 타입은 nullable 이지만, null 이 나오지 않는다는 것이 거의 확실한 상황에서 많이 사용된다.
- 변수를 null 로 설정하고, 이후에 !! 연산자를 사용하는 방법은 좋은 방법이 아니다.
- nullability 를 피할 때 사용할 수 있는 방법들
  - 클래스에서 nullability 에 따라 여러 함수를 만들어서 제공. 예) List\<T> 의 get 과 getOrNull
  - 어떤 값이 클래스 생성 이후에 확실하게 설정된다는 보장이 있다면, lateinit 프로퍼티와 notNull 델리게이트를 사용하라.
  - null 대신 빈 컬렉션을 리턴하라.
- lateinit 는 Int, Long 과 같은 기본 타입과 연결된 타입으로 프로퍼티를 초기화 해야하는 경우 사용할 수 없다. 이때는 lateinit 보다는 약간 느리지만, Delegates.notNull 을 사용한다.

### [아이템9] use 를 사용하여 리소스를 닫아라

- use 함수는 모든 Closeable 객체에 사용할 수 있다.
- 파일을 한줄씩 처리할 때는 userLines 함수를 사용할 수 있다.

### [아이템10] 단위 테스트를 만들어라

- 단위 테스트로 확인할 내용들 
  - 일반적인 유스 케이스: 요소가 사용될 거라고 예상되는 일반적인 방법을 테스트한다.
  - 일반적인 오류 케이스와 잠재적인 문제: 제대로 동작하지 않을 거라고 예상되는 일반적인 부분, 과거에 문제가 발생했던 부분 등을 테스트 
  - 에지 케이스와 잘못된 아규먼트: Int 의 경우 Int.MAX_VALUE 를 사용하는 경우, nullable 의 경우 null 또는 null 값으로 채워진 객체를 사용하는 경우, 아규먼트의 경계값에 대한 테스트 등등

## 2장 가독성

### [아이템11] 가독성을 목표로 설계하라

- 코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아니라, **가독성**을 좋게 하는데 목표를 두고 설계된 프로그래밍 언어이다.
- 가독성이란 코드르 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
- '인지 부하'를 줄이는 방향으로 코드를 작성하라. 
- let 을 많이 사용하는 경우 
  - nullable 가변 프로퍼티가 있고, null 이 아닐 때만 어떤 작업을 수행해야 하는 경우
  - 연산을 아규먼트 처리 후로 이동시킬 때
    - ~~~kotlin
      print(students.filter{}.joinToString{}) // 이러한 코드에서 print 라는 연산을 뒤로 이동 시켜서 아래 처럼 만드는 경우를 의미한다.
      students.filter{}.joinToString{}.let(::print)
      ~~~
  - 데코레이터를 사용해서 객체를 랩할 때
- 컨벤션
  - ~~~kotlin
    operator fun String.invoke(f: () -> String): String = this + f()
    infix fun String.and(s: String) = this + s
    val abc = "A" { "B" } and "C"
    println(abc)
    ~~~
  - 연산자는 의미에 맞게 사용해야 한다. invoke 를 위와 같은 형태로 사용하면 안된다. 
  - and 라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않는다.
  - 문자열을 결합하는 기능은 이미 언어에 내장되어 있다. 이미 있는 것을 다시 만들 필요는 없다.

### [아이템12] 연산자 오버로드를 할 때는 의미에 맞게 사용하라

- 코틀린에서 연산자에 대응되는 함수 이름

| 연산자    | 대응되는 함수             |
|:-------|:--------------------|
| +a     | a.unaryPlus()       |
| -a     | a.unaryMinus()      |
| !a     | a.not()             |
| ++a    | a.inc()             |
| --a    | a.dec()             |
| a+b    | a.plus(b)           |
| a-b    | a.minus(b)          |
| a*b    | a.times(b)          |
| a/b    | a.div(b)            |
| a..b   | a.rangeTo(b)        |
| a in b | b.contains(a)       |
| a+=b   | a.plusAssign(b)     |
| a-=b   | a.minusAssign(b)    |
| a*=b   | a.timesAssign(b)    |
| a/=b   | a.divAssign(b)      |
| a==b   | a.equals(b)         |
| a>b    | a.compareTo(b) > 0  |
| a<b    | a.compareTo(b) < 0  |
| a>=b   | a.compareTo(b) >= 0 |
| a<=b   | a.compareTo(b) <= 0 |

- 확장 함수를 정의할 때는 함수의 이름이 수행하는 논리 연산에 맞도록 하자. 
  - Int.not() 이라는 확장함수를 만들고 해당 Int 값의 팩토리얼을 계산하도록 한다면(5!) 혼란스럽고 오해의 소지가 생긴다.
- 의미가 명확하지 않은데 꼭 연산자 같은 형태로 사용하고 싶다면, infix 를 활용한 확장 함수를 사용하는 것이 좋다.
- 톱레벨 함수(클래스 또는 다른 대상 내부에 있지 않고, 가장 외부에 있는 함수)를 사용하는 것도 좋다.
- **연산자 오버로딩은 그 이름의 의미에 맞게 사용하도록 하자.**

### [아이템13] Unit?을 리턴하지 말라

- Unit? 으로 불을 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.
  - ~~~kotlin
    fun verifyKey(key: String): Unit? = //...
    verifyKey(key) ?: return
    ~~~
- 따라서 Boolean 을 사용하는 형태로 변경하는 것이 좋다.

### [아이템14] 변수 타입이 명확하지 않은 경우 확실하게 지정하라

- 가독성을 위해 코드를 설계할 때는 읽는 사람에게 중요한 정보를 숨겨서는 안된다.
- 타입을 무조건 지정하라는 것은 아니고 상황에 맞게 사용하도록 하자?..

### [아이템15] 리시버를 명시적으로 참조하라

- 확장 리시버(예: 확장 메서드에서의 this)를 명시적으로 참조하게 하여 가독성을 높일 수 있다.
- 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋다.(apply, with, run 등등)
- also 를 사용하면, 명시적으로 리시버를 지정하게 된다. 
- 일반적으로 also 또는 let 을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택지이다.
- **리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해주는 것이 좋다.**
- 레이블 없이 리시버를 사용하면, 가장 가까운 리시버를 의미한다. 외부에 있는 리시버를 사용하려면, 레이블을 사용해야 한다.
- DslMarker
  - 코틀린 DSL 사용시 잘못된 사용을 막기 위해 암묵적으로 외부 리시버를 사용하는 것을 막기 위한 메타 어노테이션
  - **annotation class 에만 사용 가능하다.**
  - DSL 에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제할 수 있다.

### [아이템16] 프로퍼티는 동작이 아니라 상태를 나타내야 한다

- 코틀린의 프로퍼티는 자바의 필드와 비슷해 보이지만 다른 개념이다.
- 프로퍼티에는 사용자 정의 게터와 세터를 가질 수 있다.
  - 사용자 정의 게터, 세터 에는 field 라는 식별자가 있다. 이는 프로퍼티의 데이터를 저장해 두는 백킹 필드(backing field)에 대한 레퍼런스다.
  - 이러한 백킹 필드는 따로 만들지 않아도 디폴트로 생성된다.
  - val 을 사용해서 읽기 전용 프로퍼티를 만들 때는 field 가 만들어지지 않는다.
  - var 을 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있으며, 이러한 프로퍼티를 파생 프로퍼티(derived property) 라고 부른다.
- 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있다. 따라서 인터페이스를 구현하는 클래스에서 오버라이드 할 수 있다.
- **프로퍼티를 함수 대신 사용할 수도 있지만, 그렇다고 완전히 대체해서 사용하는 것은 좋지 않다.**
  - 게터에서 어떠한 알고리즘의 동작을 나타내는 것은 좋지 않다. 
  - 큰 컬렉션의 경우 결과를 받기까지 많은 계산량이 필요하고, 관습적으로 게터에 그런 계산량이 필요하다고 예상하지 않는다. 
  - 이러한 처리는 프로퍼티가 아니라 함수로 구현하는 것이 낫다.
- **프로퍼티 대신 함수를 사용하는 것이 좋은 경우**
  - 연산 비용이 높거나, 복잡도가 O(1) 보다 큰 경우
    - 연산비용이 많이 들어간다면, 함수를 사용하자. 그래야 사용자가 연산 비용을 예측하기 쉽고, 이를 기반으로 캐싱 등을 고려 할 수 있다.
  - 비즈니스 로직을 포함하는 경우
  - 결정적이지 않은 경우: 같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있다면, 함수를 사용하자. 
  - 반환의 경우: 변환을 프로퍼티로 만들면, 오해를 불러 일으킬 수 있다.
  - 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우

### [아이템17] 이름 있는 아규먼트를 사용하라

- 이름 있는 아규먼트를 사용하면 값이 무엇을 나타내는지 알 수 있고, 파라미터의 입력 순서와 상관 없으므로 안전하다.
- 이름 있는 아규먼트를 사용하는게 좋은 경우
  - 디폴트 아규먼트의 경우 
  - 같은 타입의 파라미터가 많은 경우 
  - 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)
    - 일반적으로 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋다.
    - 그 밖의 모든 함수 타입 아규먼트는 이름 있는 아규먼트를 사용하는 것이 좋다.

### [아이템18] 코딩 컨벤션을 지켜라

- 많은 파라미터를 갖고 있는 클래스나 함수는 각각의 파라미터를 한 줄씩 작성하자.
- 공통된 컨벤션을 위해 intellij 포매터, ktlint 같은 도구들을 활용해보자.

<br>

# 2부 코드 설계 

<br>

## 3장 재사용성 

### [아이템19] knowledge 를 반복하여 사용하지 말라

- 이 장에서 knowledge 는 우리가 일바적으로 표현하는 '지식'과 약간 다르게 '의도적인 정보'를 나타내는 개념이다. 
  - 알고리즘의 작동 방식, UI 의 형태, 우리가 원하는 결과 등이 모두 '의도적인 정보'이며, knowledge 이다.
  - knowledge 는 코드, 설정, 템플릿 등으로 표현할 수 있다.
- knowledge 반복이 얼마나 위험하고 문제가 있는지 알려주는 예
  - 프로젝트의 여러 곳에서 사용되고 있는 범용적인 버튼이 있고, 이 버튼의 모양을 변경해야 할 때. 모든 부분을 하나하나 수정해야 한다면 거대한 작업이 된다.
    - 사용자 정의 스타일 기능을 통해 한꺼번에 전체적인 뷰와 컴포넌트의 디자인을 변경해서 해결 할 수 있다.
  - 데이터베이스 내부의 테이블 이름을 변경해야 할때. 사용하는 모든 곳들을 찾아서 변경해야 한다.
    - 하이버네이트와 같은 ORM 을 활용해서 해결 할 수 있다.
  - *결국은 적절한 추상화가 중요하다는 개인적인 생각이 든다.*
- 반복되는 두 코드가 같은 knowledge 를 나타내는지, 다른 knowledge 를 나타내는지 판단하는 방법
  - **"함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?"에 대해 생각해본다.**
  - 코드를 추출하는 이유는 변경을 쉽게 만들기 위함이므로, 이 질문은 가장 근복적인 질문이라고 할 수 있다.
- 단일 책임 원칙
  - 단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한 가지여야 한다'라는 의미이다.
  - 두 액터(actor)가 같은 클래스를 변경하는 일은 없어야 한다.
    - 여기서 액터는 서로의 업무와 분야에 대해서 잘모르는 개발자들로 비유된다.
  - **서로 다른 곳에서 사용하는 knowledge 는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowledge 로 취급하는 것이 좋다.**
  - **다른 knowledge 는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.**

### [아이템20] 일반적인 알고리즘을 반복해서 구현하지 말라

- 객체를 생성하고 값을 set 하는 자바빈 패턴을 사용하지 말자.
  - 이런 형태보다는 팩토리 메서드를 활용하거나, 기본 생성자를 활용하는 것이 좋다. 
  - 그래도 자바빈 패턴을 써야겠다면, 최소한 apply 를 활용해서 모든 단일 객체들의 프로퍼티를 암묵적으로 설정하는 것이 좋다.
- 확장 함수가 톰레벨 함수, 프로퍼티 위임, 클래스 등에 비해서 가지고 있는 장점
  - 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다. 특히 side-effect 가 없는 경우에는 더 좋다.
  - 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋다.
  - 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋다. 
  - 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능등으로 제안이 이루어지므로 쉽게 찾을 수 있다.
    - 예를 들어 TextUtils.isEmpty("Text") 보다는 "Text".isEmpty() 가 더 사용하기 쉽다.
    - TextUtils.isEmpty 는 사용하기 전에 isEmpty 가 어디에 포험되어 있는지를 알고 있어야 한다. 

### [아이템21] 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라

- 프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용 할 수 있다.
  - ~~~kotlin
    val value by lazy { createValue() }
    ~~~
- 프로퍼티 위임을 사용하면, 이외에도 변화가 있을 때 이름 감지하는 observable 패턴을 쉽게 만들 수 있다.
  - ~~~kotlin
    var items: List<Item> by
        Delegates.observable(listOf()) { _, _, ->
            notifyDataSetChanged()
        }
    ~~~
- 프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터와 세터)를 만드는 방식이다.
  - 이 때 다른 객체의 메서드 이름이 중요한데, 게터는 getValue, 세터는 setValue 함수를 사용해서 만들어야 한다.
  - 객체를 만든 뒤에는 by 키워드를 사용해서 getValue 와 setValue 를 정의한 클래스와 연결해 주면 된다.
- kotlin stdlib 에 있는 프로퍼티 델리게이트
  - lazy
  - Delegates.observable
  - Delegates.vetoable
  - Delegates.notNull

### [아이템22] 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

- 타입 아규먼트를 사용하는 함수(즉, 타입 파라미터를 갖는 함수)를 **제네릭 함수**라고 부른다.
- 타임 파라미터는 컴파일러에 타입과 관련된 정보를 제공하여 컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해준다.
- 제네릭은 기본적으로 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능이다.
- 타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 타입을 제한하는 것이다.

### [아이템23] 타입 파라미터의 섀도잉을 피하라

- 섀도잉: 지역 파라미터가 외부 스코프에 있는 프로퍼티를 가리는 것
- 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어렵고, 예측하지 못한 결과를 발생시킬 수 있다.
- 타입 파라미터 섀도잉을 피하고, 만약 사용한다면 섀도잉되는 코드를 주의해서 살펴 보아야 한다. 
- 이런식으로 작성하지 말자
  - 아래 코드는 Forest 와 addTree 의 타입 파라미터가 독립적으로 동작한다.
  - ~~~kotlin
    interface Tree
    class Birch: Tree
    class Spruce: Tree
    
    class Forest<T: Tree> {
        fun <T: Tree> addTree(tree: T) {
            // ...
        }
    }
    ~~~

### [아이템24] 제네릭 타입과 variance 한정자를 활용하라

- ~~~kotlin
  class Cup<T>
  ~~~
- 위의 코드에서 타입 파라미터 T 는 variance 한정자(out 또는 in)가 없으므로, 기본적으로 invariant(불공변성)이다.
- invariant 라는 것은 제네릭 타입으로 만들어지는 타입들이 서로 관련성이 없다는 의미이다.
- 만약에 어떤 관련성을 원한다면, out 또는 in 이라는 variance 한정자를 붙여야 한다.
- **out 은 타입 파라미터를 covariant(공변성)로 만든다. 이는 A 가 B 의 서브 타입일 때, Cup\<A\> 가 Cup\<B\> 의 서브타입이라는 의미이다.**
- **in 한정자는 반대 의미이다. in 한정자는 타입 파라미터를 contravariant(반변성)으로 만든다. 이는 A 가 B 의 서브타입일 때, Cup\<A\> 가 Cup\<B\> 의 슈퍼타입이라는 것을 의미한다.**
- **코틀린 함수 타입의 모든 파라미터 타입은 contravariant(반변성) 이고, 리턴 타입은 covariant(공변성) 이다.**
- variance 한정자의 안정성
  - 코틀린은 public in 한정자 위치에 covariant 타입 파라미터(out 한정자)가 오는 것을 금지한다.
  - 가시성을 private 로 제한하면, 오류가 발생하지 않는다. 객체 내부에서는 업캐스트 객체에 covariant(out 한정자)를 사용할 수 없기 때문이다.
  - covariant(out 한정자)는 public out 한정자 위치에서도 안전하므로 따로 제한되지 않는다.
  - 이러한 안정성의 이유로 생성되거나 노출되는 타입에만 covariant(out 한정자)를 사용한다.
  - 코틀린은 contravariant 타입 파라미터(in 한정자)를 public out 한정자 위치에 사용하는 것을 금지한다.
- List 와 Set 의 타입 파라미터는 covariant(out 한정자)이다.
- Map 에서 값의 타입을 나타내는 타입 파라미터는 covariant(out 한정자)이다.
- Array, MutableList, MutableSet, MutableMap 의 타입 파라미터는 invariant(한정자 지정 없음) 이다.
- **리턴만 되는 타입에는 covariant(out 한정자)를 사용한다.**
- **허용만 되는 타입에는 contravariant(in 한정자)를 사용한다.**

### [아이템25] 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

- 코틀린으로 작성할 수 있는 것들의 예
  - 코틀린/JVM 을 사용한 백엔드 개발 - 스프링, Ktor 등
  - 코틀린/JS 를 사용한 웹사이트 개발 - 리액트 등
  - 코틀린/JVM 을 사용한 안드로이드 개발 - 안드로이드 SDK 등
  - 코틀린/네이티브를 통해 Objective-C/스위프트로 IOS 프레임워크 개발
  - 코틀린/JVM 을 사용한 데스크톱 개발 - TornadoFX 등
  - 코틀린/네이티브를 사용한 라즈베리파이, 리눅스, macOS 프로그램 개발

## 4장 추상화 설계

- 컴퓨터 과학에서 추상화는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다.
- 추상화는 복잡성을 숨기기 위해 사용되는 단순한 형식을 의미한다.
- 추상화를 하려면 객체에서 무엇을 감추고 무엇을 노출해야 하는지를 결정해야 한다.
- 프로그래밍에서 추상화를 사용하는 목적
  - 복잡성을 숨기기 위해
  - 코드를 체계화하기 위해
  - 만드는 사람에게 변화의 자유를 주기 위해

### [아이템26] 함수 내부의 추상화 레벨을 통일하라

- 함수는 간단해야 한다. 
- 함수는 작아야 하며, 최소한의 책임만을 가져야 한다.
- 작고 최소한의 책임만 갖는 함수가 이해하기 쉽다.

### [아이템27] 변화로부터 코드를 보호하려면 추상화를 사용하라

- 상수
  - 리터럴을 상수 프로퍼티로 변경하여 해당 값에 의미 있는 이름을 붙이자.
  - 두 번 이상 사용되는 값은 상수로 추출하는 것이 좋다.
- 함수: 의미 있는 이름을 가지도록 하자.
- 클래스: 클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다는 점 때문이다.
- 인터페이스
  - 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있다.
  - 즉, 결합(coupling)을 줄일 수 있다.
- 추상화가 너무 많으면 코드를 이해하기 어렵다.
- 어떻게 균형을 맞춰야 할까?
  - 팀의 크기
  - 팀의 경험
  - 프로젝트의 크기
  - 특징 세트(feature set)
  - 도메인 지식
- 사용할 수 있는 몇가지 규칙
  - 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어렵다. 따라서 최대한 모듈과 부분(part)을 분리해서 추상화 하는것이 옺ㅎ다.
  - 의존성 주입 프레임워크를 사용하자.
  - 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면  추상화를 사용하자.
  - 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮다. 문제가 발생했다면, 최대한 빨리 직접 변경하면 된다.
- 추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아니다.

### [아이템28] API 안정성을 확인하라

- 시멘틱 버저닝(Semantic Versioning, SemVer)
  - 버전 번호를 세 번호, 즉 MAJOR, MINOR, PATCH 로 나누어서 구성
  - 각각의 부분은 0 이상의 정수로 구성되며, 0 부터 시작해서 API 다음과 같은 변경 사항이 있을 때 1씩 증가시킨디ㅏ.
    - MAJOR 버전: 호환되지 않는 수준의 API 변경
    - MINOR 버전: 이전 변경과 호환되는 기능을 추가
    - PATCH 버전: 간단한 버그 수정 
  - MAJOR 를 증가시킬 때는 MINOR 와 PATCH 를 0 으로 둘려둔다.
  - MINOR 를 증가시킬 때는 PATCH 를 0 으로 돌려둔다.

### [아이템29] 외부 API 를 랩(wrap)해서 사용하라

- 외부 라이브러리 API 를 wrap 하면 좋은점
  - 문제가 있다면 래퍼만 변경하면 되므로, API 변경에 쉽게 대응 할 수 있다.
  - 프로젝트의 스타일에 맞춰서 API 의 형태를 조정할 수 있다.
  - 특정 라이브러리에서 문제가 발생하면, 래퍼를 수정해서 다른 라이브러리를 사용하도록 코드를 쉽게 변경할 수 있다.
  - 필요한 경우 쉽게 동작을 추가하거나 수정할 수 있다.
- 단점
  - 래퍼를 따로 정의해야 한다.
  - 다른 개발자가 프로젝트를 다룰 때, 어떤 래퍼들이 있는지 따로 확인해야 한다.
  - 래퍼들은 프로젝트 내부에서만 유효하므로, 문제가 생겨도 질문할 수 없다.
- 장점과 단점을 모두 이해하고 랩할 API 를 결정하자.

### [아이템30] 요소의 가시성을 최소화하라

- 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화 하는 것이 좋다.
- 가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있으며, 프로퍼티의 상태를 더 쉽게 이해할 수 있다.
- 데이터를 저장하도록 설계된 클래스(데이터 모델 클래스, DTO)에는 가시성을 제한하지 않는 것이 좋다. 데이터를 저장하기 위한 클래스이기 때문에 숨길 이유가 없기 때문이다.
- 요소의 가시성은 최대한 제한적인 것이 좋다.
  - 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다.
  - 최대한 제한이 되어 있어야 변경하기 쉽다.
  - 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다.
  - 가시성이 제한되면 API 의 변경을 쉽게 추적할 수 있다.

### [아이템31] 문서로 규약을 정의하라

- 이름, 주석과 문서, 객체에 대한 타입으로 규약을 정의하자.
- KDoc 형식: 모든 KDoc 주석은 /** 로 시작해서 */ 로 끝난다. 또한 이 사이의 모든 줄은 일반적으로 * 로 시작한다.
- 공식적인 코틀린 문서 생성 도구의 이름은 Dokka 이다.

### [아이템32] 추상화 규약을 지켜라

- 프로그램을 안정적으로 유지하고 싶다면, 규약을 지켜라!
- 규약을 깰 수 밖에 없다면, 이를 잘 문서화하자.

## 6장 클래스 설계

### [아이템36] 상속보다는 컴포지션을 사용하라

- 상속은 'is-a' 관계의 객체 계층 구조를 만들기 위해 설계 되었다. 따라서 단순하게 코드 추출 또는 재사용을 위해 상속을 사용하려고 한다면, 조금 더 신중하게 생각해야 한다. 
  - 일반적으로 이러한 경우에는 상속보다는 컴포지션을 사용하는 것이 좋다.
- 상속의 몇 가지 단점
  - 상속은 하나의 클래스만을 대상으로 할 수 있다.
    - 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어진다. 
  - 상속은 클래스의 모든 것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어지고 인터페이스 분리 원칙을 위반하게 된다. 
  - 상속은 이해하기 어렵다. 개발자가 메서드를 읽고, 메서드의 작동 방식을 이해하기 위해 슈퍼 클래스를 여러 번 확인해야 한다면, 문제가 있는 것이다.
- **컴포지션을 사용한다는 것은 객체를 프로퍼티로 갖고, 함수를 호출하는 형태로 재사용하는 것을 의미한다.**
  - 객체를 다른 모든 객체에서 갖고 활용하는 추가 코드가 필요하다.
  - 하지만 이런 추가 코드로 인해서 코드를 읽는 사람들이 코드의 실행을 더 명확하게 예측할 수 있고, 컴포지션 객체를 훨씬 자유롭게 사용할 수 있다는 장점도 있다.
  - 컴포지션을 활용하면, 하나의 클래스 내부에서 여러 기능을 재사용 할 수 있게 된다.
    - 상속으로 이를 구현하려면, 두 기능을 하나의 슈퍼클래스에 배치해야 한다. 이 때문에 클래스들에 복잡한 계층 구조가 만들어질 수 있다.
    - 하지만 이것은 굉장히 나쁜 해결방법이다. 서브클래스가 필요하지도 않은 기능을 갖고, 단순하게 이를 차단할 뿐이다. 
- 모든 것을 가져올 수밖에 없는 상속
  - 상속은 슈퍼클래스의 메서드, 제약, 행위 등 모든 것을 가져온다.
  - 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구이지만 일부분을 재사용하기 위한 목적으로는 적합하지 않다.
  - 일부분만 재사용하고 싶다면, 컴포지션을 사용하는 것이 좋다. 컴포지션은 우리가 원하는 행위만 가져올 수 있기 때문이다.
- 캡슐화를 깨는 상속
  - 상속을 잘못 활용하면 내부적인 구현 방법 변경에 의해서 클래스의 캡슐화가 깨질 수 있다.
  - 컴포지션을 사용하면 다형성이 사라질 수 있는데, 만약 이를 유지하고 싶다면 위임 패턴을 사용할 수 있다.
    - 위임 패턴은 클래스가 인터페이스를 상속받게 하고, 포함한 객체의 메서드들을 활용해서, 인터페이스에서 정의한 메서드를 구현하는 패턴이다.
    - 이렇게 구현된 메서드를 포워딩 메서드라고 부른다.
    - 코틀린은 위임 패턴을 쉽게 구현할 수 있는 문법을 제공한다.
- 오버라이딩 제한하기
  - 상속은 허용하지만, 메서드는 오버라이드 하지 못하게 만들때는 open 키워드를 사용한다. open 클래스는 open 메서드만 오버랑드 할 수 있다.
  - 메서드를 오버라이드할 때, 서브클래스에서 해당 메서드에 final 을 붙일 수 있다.
- 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정하지 않아도 되는데 이것은 덜 명시적이고, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험하다.
- 그렇다면 상속은 언제 사용하면 좋을까?
  - 명확한 'is-a 관계' 일 때 
  - 슈퍼클래스를 상속하는 모든 서브클래스는 슈퍼클래스로 동작할 수 있어야 한다.
  - 슈퍼클래스의 모든 단위 테스트는 서브클래스도 통과할 수 있어야 한다.(리스코프 치환 원칙)
- 상속을 위해 설계되지 않은 메서드는 final 로 만들어 두는 것이 좋다.

### [아이템37] 데이터 집합 표현에 data 한정자를 사용하라

- data 한정자를 붙이면, 다음과 같은 몇 가지 함수가 자동으로 생성된다. 
  - toString
  - equals 와 hashCode
  - copy
  - componentN(component1, component2 등)
- toString: 클래스의 이름과 기본 생성자 형태로 모든 프로퍼티와 값을 출력해준다. 로그 출력할 때나 디버그할 때 유용하다.
- equals: 기본 생성자의 프로퍼티가 같은지 확인해 준다. 그리고 hashCode 는 equals 와 같은 결과를 나타낸다.
- copy
  - immutable 데이터 클래스를 만들 때 편리하다.
  - copy 는 기본 생성자 프로퍼티가 같은 새로운 객체를 복제한다. 새로 만들어진 객체의 값은 이름있는 아규먼트를 활용해서 변경할 수 있다.
    - ~~~kotlin
      val newObj = player.copy(name = "Thor")
      print(newObj) // Player(id=0, name=Thor, points=9999)
      ~~~
  - copy 메서드는 객체를 얕은 복사하지만, 이것은 객체가 immutable 이라면 상관이 없다. immutable 객체는 깊은 복사한 객체가 필요 없기 때문이다.
- componentN 
  - 위치를 기반으로 객체를 해제할 수 있게 해준다.
  - ~~~kotlin
    val player = Player(0, "Gecko", 9999)
    val id: Int = player.component1()
    val name: String = player.component2()
    val pts = player.component3()
    ~~~
  - componentN 함수만 있다면, List 와 Map.Entry 등의 원하는 형태로도 객체를 해제할 수 있다.
  - 객체를 해제할 때는 주의해야 하므로 데이터 클래스의 기본 생성자에 붙어 있는 프로퍼티 이름과 같은 이름을 사용하는 것이 좋다.
    - 그렇게 하면 순서등을 잘못 지정했을 때, 인텔리제이와 안드로이드 스튜디오가 관련된 경고를 준다.
  - 값을 하나만 갖는 데이터 클래스는 해제하지 않도록 하자.
    - ~~~kotlin
      val (name) = User("John") // 이렇게 쓰지 말자
      val user = User("John")
      user.let { (a) -> print(A) } // 이렇게 쓰지 말자
      ~~~
- 튜플 대신 데이터 클래스 사용하기
  - 데이터 클래스는 듀플보다 많은 것을 제공한다.
  - 코틀린의 튜플은 Serializable 을 기반으로 만들어지며, toString 을 사용할 수 있는 제네릭 데이터 클래스이다.
  - Pair 와 Triple 이 코틀린에 남아 있는 마지막 튜플이다. 
    - 과거에는 더 많은 튜플을 정의할 수 있었다. 그러나 튜플은 데이터 클래스와 같은 역할을 하면서, 훨씬 가독성이 나쁘다.  그래서 점차 없어진 것이다.
    - 튜플만 보고는 어떤 타입을 나타내는지 예측할 수 없다.
  - 값에 간단하게 이름을 붙이거나, 미리 알 수 없는 aggregate(집합)를 표현하는 경우에나 사용한다.
  - 튜플 대신 데이터 클래스를 사용하는 이점 
    - 함수의 리턴 타입이 더 명확해진다.
    - 리턴 타입이 더 짧아지며, 전달하기 쉬워진다.
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면, 경고가 출력된다.

### [아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라

- SAM(Single-Abstract Method): 메서드가 하나만 있는 인터페이스
  - ~~~kotlin
    interface OnClick {
        fun clicked(view: View)
    }
    ~~~
- 함수가 SAM 을 받는다면, 이러한 인터페이스를 구현한 객체를 전달받는다는 의미이다.
- 파라미터를 전달하는 다양한 방법들 
  - 람다 표현식 또는 익명 함수로 전달
    - ~~~kotlin
      setOnclickListener { /*...*/ }
      setOnclickListener(fun(view) { /*...*/ })
      ~~~
  - 함수 레퍼런스 또는 제한된 함수 레퍼런스 전달
    - ~~~kotlin
      setOnclickListener(::println)
      setOnclickListener(this::showUsers)
      ~~~
  - 선언된 함수 타입을 구현한 객체로 전달
    - ~~~kotlin
      class ClickListener: (View)->Unit {
          override fun invoke(view: View) {
              // ...
          } 
      }
      setOnClickListener(ClickListener())
      ~~~
- SAM 의 장점은 '그 아규먼트에 이름이 붙어 있는 것' 이라고 말하는 사람들도 있지만, 타입 별칭(type aliase)을 사용하면, 함수 타입도 이름을 붙일 수 있다.
  - ~~~kotlin
    typealias OnClick = (View) -> Unit
    ~~~
- 람다 표현식을 사용할 때는 아규먼트 분해(destructure argument)도 사용 할 수 있다.
- **인터페이스를 사용해야 하는 특별한 이유가 없다면, 함수 타입을 활용하는게 좋다.**
- 언제 SAM 을 사용해야 할까?
  - 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계 할때 사용.
  - 자바에서는 인터페이스가 더 명확하다.
  - 함수 타입으로 만들어진 클래스는 자바에서 타입 별칭과 IDE 의 지원등을 제대로 받을 수 없다.

### [아이템39] 태그 클래스보다는 클래스 계층을 사용하라

- 상수(constant) 모드를 태그(tag)라고 부르며, 태그를 포함한 클래스를 태그 클래스(tagged class)라고 부른다.
- 태그 클래스의 문제점
  - 서로 다른 책임을 한 클래스에 태그로 구분해서 넣는다.
  - 한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가 된다.
  - 여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있으며, 더 많은 프로퍼티가 필요하다.
  - 요소가 여러 목적을 가지고, 요소를 여러 방법으로 설정할 수 있는 경우에는 상태의 일관성과 정확성을 지키기 어렵다.
  - 팩토리 메서드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 굉장히 어렵다.
- 코틀른은 그래서 일반적으로 태그 클래스보다 sealed 클래스를 많이 사용한다.
  - 한 클래스에 여러 모드를 만드는 방법 대신에, 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.
  - 이러한 클래스에는 sealed 한정자를 붙여서 서브클래스 정의를 제한한다.
- sealed 한정자
  - abstract 한정자를 사용할 수도 있지만, sealed 한정자는 외부 파일에서 서브 클래스를 만드는 행위 자체를 모두 제한한다.
  - 외부에서 추가적인 서브클래스를 만들 수 없으므로, 타입이 추가되지 않을 거라는게 보장된다. 
  - 따라서 when 을 사용할 때 else 브랜치를 따로 만들 필요가 없다.
  - sealed 한정자를 사용하면, 확장 함수를 사용해서 클래스에 새로운 함수를 추가하거나, 클래스의 다양한 변경을 쉽게 처리할 수 있다.
  - 클래스의 서브 클래스를 제어하려면, sealed 한정자를 사용해야 한다. 
  - abstract 는 상속과 관련된 설계를 할 때 사용한다.
- 태그 클래스와 상태 패턴의 차이
  - 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.
  - 상태 패턴은 프론트엔드 컨트롤러, 프레젠터(presenter), 뷰모델을 설계할 때 많이 사용된다.
  - 상태는 더 많은 책임을 가진 클래스이며, 상태는 변경할 수 있다.
  - 구체 상태는 객체를 활용해서 표현하는 것이 일반적이며, 태크 클래스보다는 sealed 클래스 계층으로 만들도록 하자.
  - 또한 이를 immutable 객체로 만들고, 변경해야 할 때마다 state 프로퍼티를 변경하게 만들자.

### [아이템40] equals 의 규약을 지켜라

- 코틀린의 Any 에는 다음과 같이 잘 설정된 규약들을 가진 메서드들이 있다.
  - equals
  - hashCode
  - toString
- 동등성
  - 코틀린에는 두 가지 종류의 동등성(equality)이 있다.
    - 구조적 동등성(structural equality)
      - equals 메서드와 이를 기반으로 만들어진 == 연산자(!= 포함)로 확인하는 동등성이다.
      - a 가 nullable 이 아니라면 a == b 는 a.equals(b) 로 변환되고, a 가 nullable 이라면 a?.equals(b) ?: (b === null) 로 변환된다.
    - 레퍼런스적 동등성(referential equality)
      - === 연산자(!== 포함)로 확인하는 동등성이다.
      - 두 피연산자가 같은 객체를 가리키면 true 를 리턴한다.
  - equals 는 모든 클래스의 슈퍼클래스인 Any 에 구현되어 있으므로, 모든 객체에서 사용할 수 있다.
  - 다만, 연산자를 사용해서 다른 타입의 두 객체를 비교하는 것은 허용되지 않는다.
    - "".equals(1) 은 가능하지만, "" == 1 은 불가능하다.
    - 같은 타입을 비교하거나, 둘이 상속 관계를 갖는 경우에는 비교할 수 있다.
- equals 가 필요한 이유 
  - Any 클래스에 구현되어 있는 equals 메서드는 디폴트로 === 처럼 두 인스턴스가 완전히 같은 객체인지를 비교한다. 
  - 이는 모든 객체는 디폴트로 유일한 객체라는 것을 의미한다.
  - data 한정자를 붙여서 데이터 클래스로 정의하면, 두 객체가 기본 생성자와 프로퍼티가 같다면 동등성으로 동작한다.
  - 모든 프로퍼티가 아닌 일부 프로퍼티로만 동등성을 비교 할때는 데이터 클래스에서 동등성 비교 대상이 아닌 프로퍼티를 생성자 프로퍼티가 아닌 클래스 프로퍼티로 선언하면 된다.
    - 기본 생성자에 선언되지 않은 프로퍼티는 copy() 메서드로 복사되지 않는다.
  - **equals 를 직접 구현해야 하는 경우**
    - 기본적으로 제공되는 동작과 다른 동작을 해야 하는 경우
    - 일부 프로퍼티만으로 비교해야 하는 경우
    - data 한정자를 붙이는 것을 원하지 않거나, 비교해야 하는 프로퍼티가 기본 생성자에 없는 경우
- equals 의 규약
  - 반사적(reflexive) 동작: x 가 null 이 아닌 값이라면, x.equals(x) 는 true 를 리턴해야 한다.
  - 대칭적(symmetric) 동작: x 와 y 가 null 이 아닌 값이라면, x.equals(y) 는 y.equals(x)와 같은 결과를 출력해야 한다.
    - x == y 와 y == x 가 같아야 한다는 의미이다.
    - 일반적으로 다른 타입과 동등성을 확인하려고 할 때, 이런 동작이 위반된다.
    - 객체가 대칭적인 동작을 하지 못한다면 예쌍하지 못한 오류가 발생할 수 있으며, 디버깅 중에 찾기는 정말 어렵다.
    - **결론적으로 다른 클래스는 동등하지 않게 만들어 버리는 것이 좋다.**
    - 코틀린에서는 Any 이외의 공통 슈퍼클래스가 없는 두 타입끼리 == 연산자로 비교할 수 없다.
  - 연속적(transitive) 동작: x, y, z 가 null 이 아닌 값이고 x.equals(y) 와 y.equals(z) 가 true 라면, x.equals(z) 도 true 여야 한다.
    - 상속 관계를 가지고 있을때, 같은 객체끼리만 비교하게 만드는 방법은 좋지 않은 선택지이다.
    - 이렇게 구현하면 리스코프 치환 원칙을 위반하게 된다. 처음부터 상속 대신 컴포지션을 사용하고 두 객체를 아예 비교하지 못하게 만드는 것이 좋다.
  - 일관적(consistent) 동작: x 와 y 가 null 이 아닌 값이라면, x.equals(y) 는 (비교에 사용되는 프로퍼티를 변경한 것이 아니라면) 여러 번 실행하더라도 항상 같은 결과를 리턴해야 한다.
    - equals 는 반드시 비교 대상이 되는 두 객체에만 의존하는 순수 함수여야 한다.
  - null 과 관련된 동작: x 가 null 이 아닌 값이라면, x.equals(null) 은 항상 false 를 리턴해야 한다.
  - 추가로, equals, toString, hashCode 의 동작은 매우 빠를 거라 예측되므로, 빠르게 동작해야 한다.
- java.net.URL 은 객체 2개를 비교하면 동일한 IP 주소로 해석될 때는 true, 아닐 때는 false 가 나온다.
  - 문제는 이 결과가 네트워크 상태에 따라서 달라진다.
  - java.net.URI 를 사용하도록 하자.
- equals 구현하기
  - **특별한 이유가 없는 이상, 직접 equals 를 구현하는 것은 좋지 않다.**
  - 만약 상속을 한다면, 서브클래스에서 equals 가 작동하는 방식을 변경하면 안 된다는 것을 기억하자.

### [아이템41] hasCode 의 규약을 지켜라

- hashCode 함수는 해시 테이블을 구축할 때 사용된다.
- 해시 테이블
  - 해시 테이블은 각 요소에 숫자를 할당하는 함수가 필요하다. 이 함수를 해시 함수라고 부르며, 같은 요소라면 항상 같은 숫자를 리턴한다.
  - 해시 함수가 갖고 있으면 좋은 특성
    - 빠르다.
    - 충돌이 적다(다른 값이라면 최대한 다른 숫자를 리턴한다는 의미).
  - 해시 함수는 각각의 요소에 특정한 숫자를 할당하고, 이를 기반으로 요소를 다른 버킷(bucket, 통)에 넣는다.
  - 버킷은 버킷 수와 같은 크기의 배열인 해시 테이블에 보관된다.
  - 해시 함수는 같은 요소라면 같은 값을 리턴하므로, 다른 버킷을 확인할 필요 없이 바로 원하는 것이 들어 있는 버킷을 찾을 수 있다.
- **세트와 맵의 키로 mutable 요소를 사용하면 안 되며, 사용하더라도 요소를 변경해서는 안된다.**
- hashCode 의 규약
  - 어떤 객체를 변경하지 않았다면(equals 에서 비교에 사용된 정보가 수정되지 않는 이상), hashCode 는 여러 번 호출해도 그 결과가 항상 같아야 한다.
  - equals 메서드의 실행 결과로 두 객체가 같다고 나온다면, hashCode 메서드의 호출 결과도 같다고 나와야 한다.
    - hashCode 는 equals 와 같이 일관성 있는 동작을 해야 한다. 즉, 같은 요소는 반드시 같은 해시 코드를 가져야 한다.
  - hashCode 는 최대한 요소를 넓게 퍼뜨려야 한다.(필수는 아님)
    - hashCode 가 항상 동일한 숫자를 리턴한다면 항상 같은 버킷에 배치하게 되고, 해시 테이블을 사용할 필요가 없어진다.
- hashCode 구현하기
  - equals 를 따로 정의했다면, 반드시 hashCode 도 함께 정의해 줘야 한다.
  - equals 로 같은 요소라고 판정되는 요소는 hashCode 가 반드시 같은 값을 리턴해야 한다.
  - hashCode 는 기본적으로 equals 에서 비교에 사용되는 프로퍼티를 기반으로 해시 코드를 만들어야 한다.
  - 해시 코드 만들기
    - 일반적으로 모든 해시 코드의 값을 더한다.
    - 더하는 과정마다 이전까지의 결과에 31을 곱한 뒤 더해준다.(31일 필요는 없지만, 관례적으로 31을 많이 사용한다.)
  - 코틀린/JVM 의 Objects.hash() 함수를 이용해 해시를 계산 할 수 있다.
  - 코틀린 stdlib 에는 이런 함수가 따로 없기 때문에 직접 구현해야 한다. 
  - hashCode 를 직접 구현할 일은 거의 없다. data 한정자를 쓰도록 하자.

### [아이템42] compareTo 의 규약을 지켜라
### [아이템43] API 의 필수적이지 않는 부분을 확장 함수로 추출하라
### [아이템44] 멤버 확장 함수의 사용을 피하라