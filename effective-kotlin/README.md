# 이펙티브 코틀린 *안전성, 가독성, 코드 설계, 효율성을 향상시키기 위한 52가지 전략과 기법*
- *마르친 모스칼라 저/윤인성 역 | 인사이트(insight) |*

<br>

## 아이템 목록

#### [[아이템1] 가변성을 제한하라](#아이템1-가변성을-제한하라-1)
#### [[아이템2] 변수의 스코프를 최소화하라](#아이템2-변수의-스코프를-최소화하라-1)
#### [[아이템3] 최대한 플랫폼 타입을 사용하지 말라](#아이템3-최대한-플랫폼-타입을-사용하지-말라-1)
#### [[아이템4] inferred 타입으로 리턴하지 말라](#아이템4-inferred-타입으로-리턴하지-말라-1)
#### [[아이템5] 예외를 활용해 코드에 제한을 걸어라](#아이템5-예외를-활용해-코드에-제한을-걸어라-1)
#### [[아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라](#아이템6-사용자-정의-오류보다는-표준-오류를-사용하라-1)
#### [[아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라](#아이템7-결과-부족이-발생할-경우-null-과-Failure-를-사용하라-1)
#### [[아이템8] 적절하게 null 을 처리하라](#아이템8-적절하게-null-을-처리하라-1)
#### [[아이템9] use 를 사용하여 리소스를 닫아라](#아이템9-use-를-사용하여-리소스를-닫아라-1)
#### [[아이템10] 단위 테스트를 만들어라](#아이템10-단위-테스트를-만들어라-1)

<br>

# 1부 좋은 코드

<br>

## 1장 안정성 

### [아이템1] 가변성을 제한하라

- 상태를 갖게 하는 경우 발생하는 문제점 
  - 프로그램을 이해하고 디버그하기 힘들어진다. 
    - 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 추적하는 것이 힘들어진다.
  - 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워진다. 또한 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없다.
  - 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다. 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있다.
  - 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
- 코틀린에서 가변성 제한하기
  - 읽기 전용 프로퍼티(val)
    - 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면, 내부적으로 변할 수 있다.
    - var 은 게터와 세터를 모두 제공하지만, val 은 변경이 불가능하므로 게터만 제공한다.
    - **변수를 게터로 정의하면 스마트 캐스트를 할수 없다. 게터를 활용하므로, 값을 사용하는 시점에 따라서 다른 결과가 나올 수 있기 때문이다.**
      - 변수가 final 이고, 사용자 정의 게터를 갖지 않을 경우 스마트 캐스트 할 수 있다.
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기 
    - 읽기 전용: Iterable, Collection, Set, List
    - 읽고 쓰기 가능: MutableIterable, MutableCollection, MutableSet, MutableList
    - mutable 이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것이다.
    - **컬렉션 다운캐스팅은 예측하지 못한 결과를 초래하므로 사용하지 말자.**
      - 읽기 전용에서 mutable 로 변경해야 한다면 복제를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList 를 활용해야 한다.
  - 데이터 클래스의 copy
- immutable 객체 사용의 장점
  - 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
  - immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
  - immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
  - immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 된다.
  - immutable 객체는 set 또는 map 의 키로 사용할 수 있다.
    - mutable 객체는 요소에 수정이 일어나면 해시 테이블 내부에서 요소를 찾을 수 없게 되어 버리기 때문에 키로 사용할 수 없다.
- Delegates.observable 을 사용하면, 리스트에 변경이 있을 때 로그를 출력할 수 있다.
- **mutable 객체를 외부에 노출하지 않는 것이 좋다.**

### [아이템2] 변수의 스코프를 최소화하라

- 상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는 것이 좋다.
  - 프로퍼티보다는 지역 변수를 사용하는 것이 좋다. 
  - 최대한 좁은 스코프를 갖게 변수를 사용한다.
  - var 보다는 val 을 사용하는 것이 좋다. 
  - 람다에서는 변수를 갭처하기 때문에 주의하자. 시퀀스를 활용하는 식에서 변수를 캡처하면 의도치 않은 결과가 나올수도 있다.

### [아이템3] 최대한 플랫폼 타입을 사용하지 말라

- 플랫폼 타입이란, 다은 프로그래밍 언어에서 전달되어서 nullable 인지 알 수 없는 타입을 말한다.
- 자바를 코틀린과 함께 사용할 때, 가능한 @Nullable 과 @NotNull 어노테이션을 붙여서 사용하자.

### [아이템4] inferred 타입으로 리턴하지 말라

- **타입 추론으로 할당 할 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설전된다. 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다.**
- 타입 추론으로 할당된 변수가 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있다.
- 안전을 위해서 외부 API 를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자. 
- inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수도 있다는걸 기억하자! 

### [아이템5] 예외를 활용해 코드에 제한을 걸어라

- 코틀린에서 코드의 동젝에 제한을 거는 방법들
  - require 블록: 아규먼트와 관련된 예측을 정의할 때 사용 
  - check 블록: 상태와 관련된 동작 제한
  - assert 블록: 어떤 것이 true 인지 확인. assert 블록은 테스트 모드에서만 작동한다. 
  - return 또는 throw 와 함께 활용하는 Elvis 연산자
- 아규먼트
  - require 함수는 제한을 확인하고, 제한을 만족하지 못할 때 무조건적으로 IllegalArgumentException 을 throw 한다.
  - 람다를 활용해서 지연 메시지를 정의할수도 있다. 
    - ~~~kotlin
      require(n >= 0) { "Cannot calculate factorial of $n because it is smaller than 0"}
      ~~~
- 상태
  - 어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할때 사용한다. 
    - 어떤 객체가 미리 초기화 되어 있어야만 처리를 하게 하고 싶은 경우 
    - 객체를 사용할 수 있는 시점에 사용하고 싶은 경우 등등
  - check 함수는 require 와 비슷하지만, 지정된 예측을 만족하지 못할 때, IllegalStateException 을 throw 한다.
  - 상태가 올바른지 확인할 때 사용한다. 이러한 확인은 사용자가 규약을 어기고, 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 한다.
  - 일반적으로 require 블록 뒤에 배치한다.
- Assert 계열 함수 사용
  - assert 조건은 -ea JVM 옵션을 활성화 해야 확인 할 수 있다.
- nullability 와 스마트 캐스팅
  - 코틀린에서 require 와 check 블록으로 어떤 조건을 확인해서 true 가 나왔다면, 해당 조건은 이후로도 true 일거라고 가정한다.
  - 따라서 이를 활용해서 타입 비교를 했다면, 스마트 캐스트가 작동한다.
  - 어떤 대상이 null 인지 확인할 때 굉장히 유용하다! requireNotNull, checkNotNull 을 사용해도 괜찮다.
  - **nullability 를 목적으로, 오른쪽 throw 또는 return 을 두고 Elvis 연산자를 활용하면 유용하다.**
    - 오른쪽에 return 을 넣으면, 오류를 발생시키지 않고 단순하게 함수를 중지할 수도 있다.
    - **프로퍼티에 문제가 있어서 null 일 때 여러 처리를 해야 할 때도, return/throw 와 run 함수를 조합해서 활용할 수 있다.**

### [아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라

- 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋다. 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋다.
- IllegalArgumentException, IllegalStateException: 아이템5에서 다룬 require 와 check 를 사용해 throw 할 수 있는 예외
- IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어나는 경우 (예: ArrayList.get(Int))
- ConcurrentModificationException: 동시 수정을 금지 했는데, 발생했을 경우 
- UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없는 경우
- NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않는 경우

### [아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라

- 함수가 원하는 결과를 만들어 낼 수 없는 경우들 
  - 서버로부터 데이터를 읽어 들이려고 했는데, 네트워크 문제로 읽어 들이지 못한 경우 
  - 조건에 맞는 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우 
  - 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트 형식이 맞지 않는 경우 등등 
- 이러한 상황을 처리하는 메커니즘 두 가지 
  - null 또는 '실패를 나타내는 sealed 클래스(일반적으로 Failure 라는 이름을 붙인다.)'를 리턴
  - 예외를 throw 
- 위의 두 가지는 중요한 차이점이 있다. 일단 예외는 정보를 전달하는 방법으로 사용하면 안되고, 특별한 상황을 나타내야 하며, 처리되어야 한다.
  - 코틀린의 모든 예외는 unchecked 예외다. 따라서 사용자가 예외를 처리하지 않을 수도 있다.
    - 사용자가 반드시 처리하게 강제되는 예외를 checked 예외라고 부르고, 처리하지 않아도 실행에 문제가 없는 예외을 unchecked 예외라고 부른다.
  - 예외는 예외적인 상황을 처리하기 위해서 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않는다.
  - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한된다.
- **충분히 예측할 수 있는 범위의 오류는 null 과 Failure 를 사용하고, 예측하기 어려운 예외적인 범위의 오류는 예외를 throw 해서 처리하는 것이 좋다.**
- null 값과 sealed result 클래스의 차이는 추가적인 정보의 전달 유무다.

### [아이템8] 적절하게 null 을 처리하라
### [아이템9] use 를 사용하여 리소스를 닫아라
### [아이템10] 단위 테스트를 만들어라