# 이펙티브 코틀린 *안전성, 가독성, 코드 설계, 효율성을 향상시키기 위한 52가지 전략과 기법*
- *마르친 모스칼라 저/윤인성 역 | 인사이트(insight) |*

<br>

## 아이템 목록

## 1장 안정성

#### [[아이템1] 가변성을 제한하라](#아이템1-가변성을-제한하라-1)
#### [[아이템2] 변수의 스코프를 최소화하라](#아이템2-변수의-스코프를-최소화하라-1)
#### [[아이템3] 최대한 플랫폼 타입을 사용하지 말라](#아이템3-최대한-플랫폼-타입을-사용하지-말라-1)
#### [[아이템4] inferred 타입으로 리턴하지 말라](#아이템4-inferred-타입으로-리턴하지-말라-1)
#### [[아이템5] 예외를 활용해 코드에 제한을 걸어라](#아이템5-예외를-활용해-코드에-제한을-걸어라-1)
#### [[아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라](#아이템6-사용자-정의-오류보다는-표준-오류를-사용하라-1)
#### [[아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라](#아이템7-결과-부족이-발생할-경우-null-과-Failure-를-사용하라-1)
#### [[아이템8] 적절하게 null 을 처리하라](#아이템8-적절하게-null-을-처리하라-1)
#### [[아이템9] use 를 사용하여 리소스를 닫아라](#아이템9-use-를-사용하여-리소스를-닫아라-1)
#### [[아이템10] 단위 테스트를 만들어라](#아이템10-단위-테스트를-만들어라-1)

## 2장 가독성

#### [[아이템11] 가독성을 목표로 설계하라](#아이템11-가독성을-목표로-설계하라-1)
#### [[아이템12] 연산자 오버로드를 할 때는 의미에 맞게 사용하라](#아이템12-연산자-오버로드를-할-때는-의미에-맞게-사용하라-1)
#### [[아이템13] Unit?을 리턴하지 말라](#아이템13-unit을-리턴하지-말라-1)
#### [[아이템14] 변수 타입이 명확하지 않은 경우 확실하게 지정하라](#아이템14-변수-타입이-명확하지-않은-경우-확실하게-지정하라-1)
#### [[아이템15] 리시버를 명시적으로 참조하라](#아이템15-리시버를-명시적으로-참조하라-1)
#### [[아이템16] 프로퍼티는 동작이 아니라 상태를 나타내야 한다](#아이템16-프로퍼티는-동작이-아니라-상태를-나타내야-한다-1)
#### [[아이템17] 이름 있는 아규먼트를 사용하라](#아이템17-이름-있는-아규먼트를-사용하라-1)
#### [[아이템18] 코딩 컨벤션을 지켜라](#아이템18-코딩-컨벤션을-지켜라-1)

## 3장 가독성

#### [[아이템19] knowledge 를 반복하여 사용하지 말라](#아이템19-knowledge-를-반복하여-사용하지-말라-1)
#### [[아이템20] 일반적인 알고리즘을 반복해서 구현하지 말라](#아이템20-일반적인-알고리즘을-반복해서-구현하지-말라-1)
#### [[아이템21] 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라](#아이템21-일반적인-프로퍼티-패턴은-프로퍼티-위임으로-만들어라-1)
#### [[아이템22] 일반적인 알고리즘을 구현할 때 제네릭을 사용하라](#아이템22-일반적인-알고리즘을-구현할-때-제네릭을-사용하라-1)
#### [[아이템23] 타입 파라미터의 섀도잉을 피하라](#아이템23-타입-파라미터의-섀도잉을-피하라-1)
#### [[아이템24] 제네릭 타입과 variance 한정자를 활용하라](#아이템24-제네릭-타입과-variance-한정자를-활용하라-1)
#### [[아이템25] 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라](#아이템25-공통-모듈을-추출해서-여러-플랫폼에서-재사용하라-1)

#### [[아이템36] 상속보다는 컴포지션을 사용하라](#아이템36-상속보다는-컴포지션을-사용하라-1)
#### [[아이템37] 데이터 집합 표현에 data 한정자를 사용하라](#아이템37-데이터-집합-표현에-data-한정자를-사용하라-1)
#### [[아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라](#아이템38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라-1)
#### [[아이템39] 태그 클래스보다는 클래스 계층을 사용하라](#아이템39-태그-클래스보다는-클래스-계층을-사용하라-1)
#### [[아이템40] equals 의 규약을 지켜라](#아이템40-equals-의-규약을-지켜라-1)
#### [[아이템41] hasCode 의 규약을 지켜라](#아이템41-hasCode-의-규약을-지켜라-1)
#### [[아이템42] compareTo 의 규약을 지켜라](#아이템42-compareTo-의-규약을-지켜라-1)
#### [[아이템43] API 의 필수적이지 않는 부분을 확장 함수로 추출하라](#아이템43-API-의-필수적이지-않는-부분을-확장-함수로-추출하라-1)
#### [[아이템44] 멤버 확장 함수의 사용을 피하라](#아이템44-멤버-확장-함수의-사용을-피하라-1)

<br>

# 1부 좋은 코드

<br>

## 1장 안정성 

### [아이템1] 가변성을 제한하라

- 상태를 갖게 하는 경우 발생하는 문제점 
  - 프로그램을 이해하고 디버그하기 힘들어진다. 
    - 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 추적하는 것이 힘들어진다.
  - 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워진다. 또한 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없다.
  - 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다. 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있다.
  - 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
- 코틀린에서 가변성 제한하기
  - 읽기 전용 프로퍼티(val)
    - 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면, 내부적으로 변할 수 있다.
    - var 은 게터와 세터를 모두 제공하지만, val 은 변경이 불가능하므로 게터만 제공한다.
    - **변수를 게터로 정의하면 스마트 캐스트를 할수 없다. 게터를 활용하므로, 값을 사용하는 시점에 따라서 다른 결과가 나올 수 있기 때문이다.**
      - 변수가 final 이고, 사용자 정의 게터를 갖지 않을 경우 스마트 캐스트 할 수 있다.
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기 
    - 읽기 전용: Iterable, Collection, Set, List
    - 읽고 쓰기 가능: MutableIterable, MutableCollection, MutableSet, MutableList
    - mutable 이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것이다.
    - **컬렉션 다운캐스팅은 예측하지 못한 결과를 초래하므로 사용하지 말자.**
      - 읽기 전용에서 mutable 로 변경해야 한다면 복제를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList 를 활용해야 한다.
  - 데이터 클래스의 copy
- immutable 객체 사용의 장점
  - 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
  - immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
  - immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
  - immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 된다.
  - immutable 객체는 set 또는 map 의 키로 사용할 수 있다.
    - mutable 객체는 요소에 수정이 일어나면 해시 테이블 내부에서 요소를 찾을 수 없게 되어 버리기 때문에 키로 사용할 수 없다.
- Delegates.observable 을 사용하면, 리스트에 변경이 있을 때 로그를 출력할 수 있다.
- **mutable 객체를 외부에 노출하지 않는 것이 좋다.**

### [아이템2] 변수의 스코프를 최소화하라

- 상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는 것이 좋다.
  - 프로퍼티보다는 지역 변수를 사용하는 것이 좋다. 
  - 최대한 좁은 스코프를 갖게 변수를 사용한다.
  - var 보다는 val 을 사용하는 것이 좋다. 
  - 람다에서는 변수를 갭처하기 때문에 주의하자. 시퀀스를 활용하는 식에서 변수를 캡처하면 의도치 않은 결과가 나올수도 있다.

### [아이템3] 최대한 플랫폼 타입을 사용하지 말라

- 플랫폼 타입이란, 다은 프로그래밍 언어에서 전달되어서 nullable 인지 알 수 없는 타입을 말한다.
- 자바를 코틀린과 함께 사용할 때, 가능한 @Nullable 과 @NotNull 어노테이션을 붙여서 사용하자.

### [아이템4] inferred 타입으로 리턴하지 말라

- **타입 추론으로 할당 할 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설전된다. 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다.**
- 타입 추론으로 할당된 변수가 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있다.
- 안전을 위해서 외부 API 를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자. 
- inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수도 있다는걸 기억하자! 

### [아이템5] 예외를 활용해 코드에 제한을 걸어라

- 코틀린에서 코드의 동젝에 제한을 거는 방법들
  - require 블록: 아규먼트와 관련된 예측을 정의할 때 사용 
  - check 블록: 상태와 관련된 동작 제한
  - assert 블록: 어떤 것이 true 인지 확인. assert 블록은 테스트 모드에서만 작동한다. 
  - return 또는 throw 와 함께 활용하는 Elvis 연산자
- 아규먼트
  - require 함수는 제한을 확인하고, 제한을 만족하지 못할 때 무조건적으로 IllegalArgumentException 을 throw 한다.
  - 람다를 활용해서 지연 메시지를 정의할수도 있다. 
    - ~~~kotlin
      require(n >= 0) { "Cannot calculate factorial of $n because it is smaller than 0"}
      ~~~
- 상태
  - 어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할때 사용한다. 
    - 어떤 객체가 미리 초기화 되어 있어야만 처리를 하게 하고 싶은 경우 
    - 객체를 사용할 수 있는 시점에 사용하고 싶은 경우 등등
  - check 함수는 require 와 비슷하지만, 지정된 예측을 만족하지 못할 때, IllegalStateException 을 throw 한다.
  - 상태가 올바른지 확인할 때 사용한다. 이러한 확인은 사용자가 규약을 어기고, 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 한다.
  - 일반적으로 require 블록 뒤에 배치한다.
- Assert 계열 함수 사용
  - assert 조건은 -ea JVM 옵션을 활성화 해야 확인 할 수 있다.
- nullability 와 스마트 캐스팅
  - 코틀린에서 require 와 check 블록으로 어떤 조건을 확인해서 true 가 나왔다면, 해당 조건은 이후로도 true 일거라고 가정한다.
  - 따라서 이를 활용해서 타입 비교를 했다면, 스마트 캐스트가 작동한다.
  - 어떤 대상이 null 인지 확인할 때 굉장히 유용하다! requireNotNull, checkNotNull 을 사용해도 괜찮다.
  - **nullability 를 목적으로, 오른쪽 throw 또는 return 을 두고 Elvis 연산자를 활용하면 유용하다.**
    - 오른쪽에 return 을 넣으면, 오류를 발생시키지 않고 단순하게 함수를 중지할 수도 있다.
    - **프로퍼티에 문제가 있어서 null 일 때 여러 처리를 해야 할 때도, return/throw 와 run 함수를 조합해서 활용할 수 있다.**

### [아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라

- 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋다. 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋다.
- IllegalArgumentException, IllegalStateException: 아이템5에서 다룬 require 와 check 를 사용해 throw 할 수 있는 예외
- IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어나는 경우 (예: ArrayList.get(Int))
- ConcurrentModificationException: 동시 수정을 금지 했는데, 발생했을 경우 
- UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없는 경우
- NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않는 경우

### [아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라

- 함수가 원하는 결과를 만들어 낼 수 없는 경우들 
  - 서버로부터 데이터를 읽어 들이려고 했는데, 네트워크 문제로 읽어 들이지 못한 경우 
  - 조건에 맞는 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우 
  - 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트 형식이 맞지 않는 경우 등등 
- 이러한 상황을 처리하는 메커니즘 두 가지 
  - null 또는 '실패를 나타내는 sealed 클래스(일반적으로 Failure 라는 이름을 붙인다.)'를 리턴
  - 예외를 throw 
- 위의 두 가지는 중요한 차이점이 있다. 일단 예외는 정보를 전달하는 방법으로 사용하면 안되고, 특별한 상황을 나타내야 하며, 처리되어야 한다.
  - 코틀린의 모든 예외는 unchecked 예외다. 따라서 사용자가 예외를 처리하지 않을 수도 있다.
    - 사용자가 반드시 처리하게 강제되는 예외를 checked 예외라고 부르고, 처리하지 않아도 실행에 문제가 없는 예외을 unchecked 예외라고 부른다.
  - 예외는 예외적인 상황을 처리하기 위해서 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않는다.
  - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한된다.
- **충분히 예측할 수 있는 범위의 오류는 null 과 Failure 를 사용하고, 예측하기 어려운 예외적인 범위의 오류는 예외를 throw 해서 처리하는 것이 좋다.**
- null 값과 sealed result 클래스의 차이는 추가적인 정보의 전달 유무다.

### [아이템8] 적절하게 null 을 처리하라

- nullable 타입을 처리하는 방법들
  - ?., 스마트캐스팅, Elvis 연산자 들을 활용해서 안전하게 처리 
  - 오류를 throw
  - 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꾼다.
- !! 은 타입은 nullable 이지만, null 이 나오지 않는다는 것이 거의 확실한 상황에서 많이 사용된다.
- 변수를 null 로 설정하고, 이후에 !! 연산자를 사용하는 방법은 좋은 방법이 아니다.
- nullability 를 피할 때 사용할 수 있는 방법들
  - 클래스에서 nullability 에 따라 여러 함수를 만들어서 제공. 예) List\<T> 의 get 과 getOrNull
  - 어떤 값이 클래스 생성 이후에 확실하게 설정된다는 보장이 있다면, lateinit 프로퍼티와 notNull 델리게이트를 사용하라.
  - null 대신 빈 컬렉션을 리턴하라.
- lateinit 는 Int, Long 과 같은 기본 타입과 연결된 타입으로 프로퍼티를 초기화 해야하는 경우 사용할 수 없다. 이때는 lateinit 보다는 약간 느리지만, Delegates.notNull 을 사용한다.

### [아이템9] use 를 사용하여 리소스를 닫아라

- use 함수는 모든 Closeable 객체에 사용할 수 있다.
- 파일을 한줄씩 처리할 때는 userLines 함수를 사용할 수 있다.

### [아이템10] 단위 테스트를 만들어라

- 단위 테스트로 확인할 내용들 
  - 일반적인 유스 케이스: 요소가 사용될 거라고 예상되는 일반적인 방법을 테스트한다.
  - 일반적인 오류 케이스와 잠재적인 문제: 제대로 동작하지 않을 거라고 예상되는 일반적인 부분, 과거에 문제가 발생했던 부분 등을 테스트 
  - 에지 케이스와 잘못된 아규먼트: Int 의 경우 Int.MAX_VALUE 를 사용하는 경우, nullable 의 경우 null 또는 null 값으로 채워진 객체를 사용하는 경우, 아규먼트의 경계값에 대한 테스트 등등

## 2장 가독성

### [아이템11] 가독성을 목표로 설계하라

- 코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아니라, **가독성**을 좋게 하는데 목표를 두고 설계된 프로그래밍 언어이다.
- 가독성이란 코드르 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
- '인지 부하'를 줄이는 방향으로 코드를 작성하라. 
- let 을 많이 사용하는 경우 
  - nullable 가변 프로퍼티가 있고, null 이 아닐 때만 어떤 작업을 수행해야 하는 경우
  - 연산을 아규먼트 처리 후로 이동시킬 때
    - ~~~kotlin
      print(students.filter{}.joinToString{}) // 이러한 코드에서 print 라는 연산을 뒤로 이동 시켜서 아래 처럼 만드는 경우를 의미한다.
      students.filter{}.joinToString{}.let(::print)
      ~~~
  - 데코레이터를 사용해서 객체를 랩할 때
- 컨벤션
  - ~~~kotlin
    operator fun String.invoke(f: () -> String): String = this + f()
    infix fun String.and(s: String) = this + s
    val abc = "A" { "B" } and "C"
    println(abc)
    ~~~
  - 연산자는 의미에 맞게 사용해야 한다. invoke 를 위와 같은 형태로 사용하면 안된다. 
  - and 라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않는다.
  - 문자열을 결합하는 기능은 이미 언어에 내장되어 있다. 이미 있는 것을 다시 만들 필요는 없다.

### [아이템12] 연산자 오버로드를 할 때는 의미에 맞게 사용하라

- 코틀린에서 연산자에 대응되는 함수 이름

| 연산자    | 대응되는 함수             |
|:-------|:--------------------|
| +a     | a.unaryPlus()       |
| -a     | a.unaryMinus()      |
| !a     | a.not()             |
| ++a    | a.inc()             |
| --a    | a.dec()             |
| a+b    | a.plus(b)           |
| a-b    | a.minus(b)          |
| a*b    | a.times(b)          |
| a/b    | a.div(b)            |
| a..b   | a.rangeTo(b)        |
| a in b | b.contains(a)       |
| a+=b   | a.plusAssign(b)     |
| a-=b   | a.minusAssign(b)    |
| a*=b   | a.timesAssign(b)    |
| a/=b   | a.divAssign(b)      |
| a==b   | a.equals(b)         |
| a>b    | a.compareTo(b) > 0  |
| a<b    | a.compareTo(b) < 0  |
| a>=b   | a.compareTo(b) >= 0 |
| a<=b   | a.compareTo(b) <= 0 |

- 확장 함수를 정의할 때는 함수의 이름이 수행하는 논리 연산에 맞도록 하자. 
  - Int.not() 이라는 확장함수를 만들고 해당 Int 값의 팩토리얼을 계산하도록 한다면(5!) 혼란스럽고 오해의 소지가 생긴다.
- 의미가 명확하지 않은데 꼭 연산자 같은 형태로 사용하고 싶다면, infix 를 활용한 확장 함수를 사용하는 것이 좋다.
- 톱레벨 함수(클래스 또는 다른 대상 내부에 있지 않고, 가장 외부에 있는 함수)를 사용하는 것도 좋다.
- **연산자 오버로딩은 그 이름의 의미에 맞게 사용하도록 하자.**

### [아이템13] Unit?을 리턴하지 말라

- Unit? 으로 불을 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.
  - ~~~kotlin
    fun verifyKey(key: String): Unit? = //...
    verifyKey(key) ?: return
    ~~~
- 따라서 Boolean 을 사용하는 형태로 변경하는 것이 좋다.

### [아이템14] 변수 타입이 명확하지 않은 경우 확실하게 지정하라

- 가독성을 위해 코드를 설계할 때는 읽는 사람에게 중요한 정보를 숨겨서는 안된다.
- 타입을 무조건 지정하라는 것은 아니고 상황에 맞게 사용하도록 하자?..

### [아이템15] 리시버를 명시적으로 참조하라

- 확장 리시버(예: 확장 메서드에서의 this)를 명시적으로 참조하게 하여 가독성을 높일 수 있다.
- 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋다.(apply, with, run 등등)
- also 를 사용하면, 명시적으로 리시버를 지정하게 된다. 
- 일반적으로 also 또는 let 을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택지이다.
- **리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해주는 것이 좋다.**
- 레이블 없이 리시버를 사용하면, 가장 가까운 리시버를 의미한다. 외부에 있는 리시버를 사용하려면, 레이블을 사용해야 한다.
- DslMarker
  - 코틀린 DSL 사용시 잘못된 사용을 막기 위해 암묵적으로 외부 리시버를 사용하는 것을 막기 위한 메타 어노테이션
  - **annotation class 에만 사용 가능하다.**
  - DSL 에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제할 수 있다.

### [아이템16] 프로퍼티는 동작이 아니라 상태를 나타내야 한다

- 코틀린의 프로퍼티는 자바의 필드와 비슷해 보이지만 다른 개념이다.
- 프로퍼티에는 사용자 정의 게터와 세터를 가질 수 있다.
  - 사용자 정의 게터, 세터 에는 field 라는 식별자가 있다. 이는 프로퍼티의 데이터를 저장해 두는 백킹 필드(backing field)에 대한 레퍼런스다.
  - 이러한 백킹 필드는 따로 만들지 않아도 디폴트로 생성된다.
  - val 을 사용해서 읽기 전용 프로퍼티를 만들 때는 field 가 만들어지지 않는다.
  - var 을 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있으며, 이러한 프로퍼티를 파생 프로퍼티(derived property) 라고 부른다.
- 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있다. 따라서 인터페이스를 구현하는 클래스에서 오버라이드 할 수 있다.
- **프로퍼티를 함수 대신 사용할 수도 있지만, 그렇다고 완전히 대체해서 사용하는 것은 좋지 않다.**
  - 게터에서 어떠한 알고리즘의 동작을 나타내는 것은 좋지 않다. 
  - 큰 컬렉션의 경우 결과를 받기까지 많은 계산량이 필요하고, 관습적으로 게터에 그런 계산량이 필요하다고 예상하지 않는다. 
  - 이러한 처리는 프로퍼티가 아니라 함수로 구현하는 것이 낫다.
- **프로퍼티 대신 함수를 사용하는 것이 좋은 경우**
  - 연산 비용이 높거나, 복잡도가 O(1) 보다 큰 경우
    - 연산비용이 많이 들어간다면, 함수를 사용하자. 그래야 사용자가 연산 비용을 예측하기 쉽고, 이를 기반으로 캐싱 등을 고려 할 수 있다.
  - 비즈니스 로직을 포함하는 경우
  - 결정적이지 않은 경우: 같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있다면, 함수를 사용하자. 
  - 반환의 경우: 변환을 프로퍼티로 만들면, 오해를 불러 일으킬 수 있다.
  - 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우

### [아이템17] 이름 있는 아규먼트를 사용하라

- 이름 있는 아규먼트를 사용하면 값이 무엇을 나타내는지 알 수 있고, 파라미터의 입력 순서와 상관 없으므로 안전하다.
- 이름 있는 아규먼트를 사용하는게 좋은 경우
  - 디폴트 아규먼트의 경우 
  - 같은 타입의 파라미터가 많은 경우 
  - 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)
    - 일반적으로 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋다.
    - 그 밖의 모든 함수 타입 아규먼트는 이름 있는 아규먼트를 사용하는 것이 좋다.

### [아이템18] 코딩 컨벤션을 지켜라

- 많은 파라미터를 갖고 있는 클래스나 함수는 각각의 파라미터를 한 줄씩 작성하자.
- 공통된 컨벤션을 위해 intellij 포매터, ktlint 같은 도구들을 활용해보자.

<br>

# 2부 코드 설계 

<br>

## 3장 재사용성 

### [아이템19] knowledge 를 반복하여 사용하지 말라

- 이 장에서 knowledge 는 우리가 일바적으로 표현하는 '지식'과 약간 다르게 '의도적인 정보'를 나타내는 개념이다. 
  - 알고리즘의 작동 방식, UI 의 형태, 우리가 원하는 결과 등이 모두 '의도적인 정보'이며, knowledge 이다.
  - knowledge 는 코드, 설정, 템플릿 등으로 표현할 수 있다.
- knowledge 반복이 얼마나 위험하고 문제가 있는지 알려주는 예
  - 프로젝트의 여러 곳에서 사용되고 있는 범용적인 버튼이 있고, 이 버튼의 모양을 변경해야 할 때. 모든 부분을 하나하나 수정해야 한다면 거대한 작업이 된다.
    - 사용자 정의 스타일 기능을 통해 한꺼번에 전체적인 뷰와 컴포넌트의 디자인을 변경해서 해결 할 수 있다.
  - 데이터베이스 내부의 테이블 이름을 변경해야 할때. 사용하는 모든 곳들을 찾아서 변경해야 한다.
    - 하이버네이트와 같은 ORM 을 활용해서 해결 할 수 있다.
  - *결국은 적절한 추상화가 중요하다는 개인적인 생각이 든다.*
- 반복되는 두 코드가 같은 knowledge 를 나타내는지, 다른 knowledge 를 나타내는지 판단하는 방법
  - **"함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?"에 대해 생각해본다.**
  - 코드를 추출하는 이유는 변경을 쉽게 만들기 위함이므로, 이 질문은 가장 근복적인 질문이라고 할 수 있다.
- 단일 책임 원칙
  - 단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한 가지여야 한다'라는 의미이다.
  - 두 액터(actor)가 같은 클래스를 변경하는 일은 없어야 한다.
    - 여기서 액터는 서로의 업무와 분야에 대해서 잘모르는 개발자들로 비유된다.
  - **서로 다른 곳에서 사용하는 knowledge 는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowledge 로 취급하는 것이 좋다.**
  - **다른 knowledge 는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.**

### [아이템20] 일반적인 알고리즘을 반복해서 구현하지 말라

- 객체를 생성하고 값을 set 하는 자바빈 패턴을 사용하지 말자.
  - 이런 형태보다는 팩토리 메서드를 활용하거나, 기본 생성자를 활용하는 것이 좋다. 
  - 그래도 자바빈 패턴을 써야겠다면, 최소한 apply 를 활용해서 모든 단일 객체들의 프로퍼티를 암묵적으로 설정하는 것이 좋다.
- 확장 함수가 톰레벨 함수, 프로퍼티 위임, 클래스 등에 비해서 가지고 있는 장점
  - 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다. 특히 side-effect 가 없는 경우에는 더 좋다.
  - 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋다.
  - 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋다. 
  - 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능등으로 제안이 이루어지므로 쉽게 찾을 수 있다.
    - 예를 들어 TextUtils.isEmpty("Text") 보다는 "Text".isEmpty() 가 더 사용하기 쉽다.
    - TextUtils.isEmpty 는 사용하기 전에 isEmpty 가 어디에 포험되어 있는지를 알고 있어야 한다. 

### [아이템21] 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라

- 프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용 할 수 있다.
  - ~~~kotlin
    val value by lazy { createValue() }
    ~~~
- 프로퍼티 위임을 사용하면, 이외에도 변화가 있을 때 이름 감지하는 observable 패턴을 쉽게 만들 수 있다.
  - ~~~kotlin
    var items: List<Item> by
        Delegates.observable(listOf()) { _, _, ->
            notifyDataSetChanged()
        }
    ~~~
- 프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터와 세터)를 만드는 방식이다.
  - 이 때 다른 객체의 메서드 이름이 중요한데, 게터는 getValue, 세터는 setValue 함수를 사용해서 만들어야 한다.
  - 객체를 만든 뒤에는 by 키워드를 사용해서 getValue 와 setValue 를 정의한 클래스와 연결해 주면 된다.
- kotlin stdlib 에 있는 프로퍼티 델리게이트
  - lazy
  - Delegates.observable
  - Delegates.vetoable
  - Delegates.notNull

### [아이템22] 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

- 타입 아규먼트를 사용하는 함수(즉, 타입 파라미터를 갖는 함수)를 **제네릭 함수**라고 부른다.
- 타임 파라미터는 컴파일러에 타입과 관련된 정보를 제공하여 컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해준다.
- 제네릭은 기본적으로 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능이다.
- 타입 파라미터의 중요한 기능 중 하나는 구체적인 타입의 서브타입만 사용하게 타입을 제한하는 것이다.

### [아이템23] 타입 파라미터의 섀도잉을 피하라

- 섀도잉: 지역 파라미터가 외부 스코프에 있는 프로퍼티를 가리는 것
- 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어렵고, 예측하지 못한 결과를 발생시킬 수 있다.
- 타입 파라미터 섀도잉을 피하고, 만약 사용한다면 섀도잉되는 코드를 주의해서 살펴 보아야 한다. 
- 이런식으로 작성하지 말자
  - 아래 코드는 Forest 와 addTree 의 타입 파라미터가 독립적으로 동작한다.
  - ~~~kotlin
    interface Tree
    class Birch: Tree
    class Spruce: Tree
    
    class Forest<T: Tree> {
        fun <T: Tree> addTree(tree: T) {
            // ...
        }
    }
    ~~~

### [아이템24] 제네릭 타입과 variance 한정자를 활용하라

- ~~~kotlin
  class Cup<T>
  ~~~
- 위의 코드에서 타입 파라미터 T 는 variance 한정자(out 또는 in)가 없으므로, 기본적으로 invariant(불공변성)이다.
- invariant 라는 것은 제네릭 타입으로 만들어지는 타입들이 서로 관련성이 없다는 의미이다.
- 만약에 어떤 관련성을 원한다면, out 또는 in 이라는 variance 한정자를 붙여야 한다.
- **out 은 타입 파라미터를 covariant(공변성)로 만든다. 이는 A 가 B 의 서브 타입일 때, Cup\<A\> 가 Cup\<B\> 의 서브타입이라는 의미이다.**
- **in 한정자는 반대 의미이다. in 한정자는 타입 파라미터를 contravariant(반변성)으로 만든다. 이는 A 가 B 의 서브타입일 때, Cup\<A\> 가 Cup\<B\> 의 슈퍼타입이라는 것을 의미한다.**

### [아이템25] 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

## 6장 클래스 설계

### [아이템36] 상속보다는 컴포지션을 사용하라

- 상속은 'is-a' 관계의 객체 계층 구조를 만들기 위해 설계 되었다. 따라서 단순하게 코드 추출 또는 재사용을 위해 상속을 사용하려고 한다면, 조금 더 신중하게 생각해야 한다. 
  - 일반적으로 이러한 경우에는 상속보다는 컴포지션을 사용하는 것이 좋다.
- 상속의 몇 가지 단점
  - 상속은 하나의 클래스만을 대상으로 할 수 있다.
    - 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어진다. 
  - 상속은 클래스의 모든 것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어지고 인터페이스 분리 원칙을 위반하게 된다. 
  - 상속은 이해하기 어렵다. 개발자가 메서드를 읽고, 메서드의 작동 방식을 이해하기 위해 슈퍼 클래스를 여러 번 확인해야 한다면, 문제가 있는 것이다.
- **컴포지션을 사용한다는 것은 객체를 프로퍼티로 갖고, 함수를 호출하는 형태로 재사용하는 것을 의미한다.**
  - 객체를 다른 모든 객체에서 갖고 활용하는 추가 코드가 필요하다.
  - 하지만 이런 추가 코드로 인해서 코드를 읽는 사람들이 코드의 실행을 더 명확하게 예측할 수 있고, 컴포지션 객체를 훨씬 자유롭게 사용할 수 있다는 장점도 있다.
  - 컴포지션을 활용하면, 하나의 클래스 내부에서 여러 기능을 재사용 할 수 있게 된다.
    - 상속으로 이를 구현하려면, 두 기능을 하나의 슈퍼클래스에 배치해야 한다. 이 때문에 클래스들에 복잡한 계층 구조가 만들어질 수 있다.
    - 하지만 이것은 굉장히 나쁜 해결방법이다. 서브클래스가 필요하지도 않은 기능을 갖고, 단순하게 이를 차단할 뿐이다. 
- 모든 것을 가져올 수밖에 없는 상속
  - 상속은 슈퍼클래스의 메서드, 제약, 행위 등 모든 것을 가져온다.
  - 객체의 계층 구조를 나타낼 때 굉장히 좋은 도구이지만 일부분을 재사용하기 위한 목적으로는 적합하지 않다.
  - 일부분만 재사용하고 싶다면, 컴포지션을 사용하는 것이 좋다. 컴포지션은 우리가 원하는 행위만 가져올 수 있기 때문이다.
- 캡슐화를 깨는 상속
  - 상속을 잘못 활용하면 내부적인 구현 방법 변경에 의해서 클래스의 캡슐화가 깨질 수 있다.
  - 컴포지션을 사용하면 다형성이 사라질 수 있는데, 만약 이를 유지하고 싶다면 위임 패턴을 사용할 수 있다.
    - 위임 패턴은 클래스가 인터페이스를 상속받게 하고, 포함한 객체의 메서드들을 활용해서, 인터페이스에서 정의한 메서드를 구현하는 패턴이다.
    - 이렇게 구현된 메서드를 포워딩 메서드라고 부른다.
    - 코틀린은 위임 패턴을 쉽게 구현할 수 있는 문법을 제공한다.
- 오버라이딩 제한하기
  - 상속은 허용하지만, 메서드는 오버라이드 하지 못하게 만들때는 open 키워드를 사용한다. open 클래스는 open 메서드만 오버랑드 할 수 있다.
  - 메서드를 오버라이드할 때, 서브클래스에서 해당 메서드에 final 을 붙일 수 있다.
- 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정하지 않아도 되는데 이것은 덜 명시적이고, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험하다.
- 그렇다면 상속은 언제 사용하면 좋을까?
  - 명확한 'is-a 관계' 일 때 
  - 슈퍼클래스를 상속하는 모든 서브클래스는 슈퍼클래스로 동작할 수 있어야 한다.
  - 슈퍼클래스의 모든 단위 테스트는 서브클래스도 통과할 수 있어야 한다.(리스코프 치환 원칙)
- 상속을 위해 설계되지 않은 메서드는 final 로 만들어 두는 것이 좋다.

### [아이템37] 데이터 집합 표현에 data 한정자를 사용하라

- data 한정자를 붙이면, 다음과 같은 몇 가지 함수가 자동으로 생성된다. 
  - toString
  - equals 와 hashCode
  - copy
  - componentN(component1, component2 등)
- toString: 클래스의 이름과 기본 생성자 형태로 모든 프로퍼티와 값을 출력해준다. 로그 출력할 때나 디버그할 때 유용하다.
- equals: 기본 생성자의 프로퍼티가 같은지 확인해 준다. 그리고 hashCode 는 equals 와 같은 결과를 나타낸다.
- copy
  - immutable 데이터 클래스를 만들 때 편리하다.
  - copy 는 기본 생성자 프로퍼티가 같은 새로운 객체를 복제한다. 새로 만들어진 객체의 값은 이름있는 아규먼트를 활용해서 변경할 수 있다.
    - ~~~kotlin
      val newObj = player.copy(name = "Thor")
      print(newObj) // Player(id=0, name=Thor, points=9999)
      ~~~
  - copy 메서드는 객체를 얕은 복사하지만, 이것은 객체가 immutable 이라면 상관이 없다. immutable 객체는 깊은 복사한 객체가 필요 없기 때문이다.
- componentN 
  - 위치를 기반으로 객체를 해제할 수 있게 해준다.
  - ~~~kotlin
    val player = Player(0, "Gecko", 9999)
    val id: Int = player.component1()
    val name: String = player.component2()
    val pts = player.component3()
    ~~~
  - componentN 함수만 있다면, List 와 Map.Entry 등의 원하는 형태로도 객체를 해제할 수 있다.
  - 객체를 해제할 때는 주의해야 하므로 데이터 클래스의 기본 생성자에 붙어 있는 프로퍼티 이름과 같은 이름을 사용하는 것이 좋다.
    - 그렇게 하면 순서등을 잘못 지정했을 때, 인텔리제이와 안드로이드 스튜디오가 관련된 경고를 준다.
  - 값을 하나만 갖는 데이터 클래스는 해제하지 않도록 하자.
    - ~~~kotlin
      val (name) = User("John") // 이렇게 쓰지 말자
      val user = User("John")
      user.let { (a) -> print(A) } // 이렇게 쓰지 말자
      ~~~
- 튜플 대신 데이터 클래스 사용하기
  - 데이터 클래스는 듀플보다 많은 것을 제공한다.
  - 코틀린의 튜플은 Serializable 을 기반으로 만들어지며, toString 을 사용할 수 있는 제네릭 데이터 클래스이다.
  - Pair 와 Triple 이 코틀린에 남아 있는 마지막 튜플이다. 
    - 과거에는 더 많은 튜플을 정의할 수 있었다. 그러나 튜플은 데이터 클래스와 같은 역할을 하면서, 훨씬 가독성이 나쁘다.  그래서 점차 없어진 것이다.
    - 튜플만 보고는 어떤 타입을 나타내는지 예측할 수 없다.
  - 값에 간단하게 이름을 붙이거나, 미리 알 수 없는 aggregate(집합)를 표현하는 경우에나 사용한다.
  - 튜플 대신 데이터 클래스를 사용하는 이점 
    - 함수의 리턴 타입이 더 명확해진다.
    - 리턴 타입이 더 짧아지며, 전달하기 쉬워진다.
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면, 경고가 출력된다.


### [아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라
### [아이템39] 태그 클래스보다는 클래스 계층을 사용하라
### [아이템40] equals 의 규약을 지켜라
### [아이템41] hasCode 의 규약을 지켜라
### [아이템42] compareTo 의 규약을 지켜라
### [아이템43] API 의 필수적이지 않는 부분을 확장 함수로 추출하라
### [아이템44] 멤버 확장 함수의 사용을 피하라