# 이펙티브 코틀린 *안전성, 가독성, 코드 설계, 효율성을 향상시키기 위한 52가지 전략과 기법*
- *마르친 모스칼라 저/윤인성 역 | 인사이트(insight) |*

<br>

## 아이템 목록

#### [[아이템1] 가변성을 제한하라](#아이템1-가변성을-제한하라-1)
#### [[아이템2] 변수의 스코프를 최소화하라](#아이템2-변수의-스코프를-최소화하라-1)
#### [[아이템3] 최대한 플랫폼 타입을 사용하지 말라](#아이템3-최대한-플랫폼-타입을-사용하지-말라-1)
#### [[아이템4] inferred 타입으로 리턴하지 말라](#아이템4-inferred-타입으로-리턴하지-말라-1)
#### [[아이템5] 예외를 활용해 코드에 제한을 걸어라](#아이템5-예외를-활용해-코드에-제한을-걸어라-1)
#### [[아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라](#아이템6-사용자-정의-오류보다는-표준-오류를-사용하라-1)
#### [[아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라](#아이템7-결과-부족이-발생할-경우-null-과-Failure-를-사용하라-1)
#### [[아이템8] 적절하게 null 을 처리하라](#아이템8-적절하게-null-을-처리하라-1)
#### [[아이템9] use 를 사용하여 리소스를 닫아라](#아이템9-use-를-사용하여-리소스를-닫아라-1)
#### [[아이템10] 단위 테스트를 만들어라](#아이템10-단위-테스트를-만들어라-1)
#### [[아이템11] 가독성을 목표로 설계하라](#아이템11-가독성을 목표로 설계하라-1)
#### [[아이템12] 연산자 오버로드를 할 때는 의미에 맞게 사용하라](#아이템12-연산자-오버로드를-할-때는-의미에-맞게-사용하라-1)
#### [[아이템13] Unit?을 리턴하지 말라](#아이템13-Unit?을-리턴하지-말라-1)
#### [[아이템14] 변수 타입이 명확하지 않은 경우 확실하게 지정하라](#아이템14-변수-타입이-명확하지-않은-경우-확실하게-지정하라-1)
#### [[아이템15] 리시버를 명시적으로 참조하라](#아이템15-리시버를-명시적으로-참조하라-1)
#### [[아이템16] 프로퍼티는 동작이 아니라 상태를 나타내야 한다](#아이템16-프로퍼티는-동작이-아니라-상태를-나타내야-한다-1)
#### [[아이템17] 이름 있는 아규먼트를 사용하라](#아이템17-이름-있는-아규먼트를-사용하라-1)
#### [[아이템18] 코딩 컨벤션을 지켜라](#아이템18-코딩-컨벤션을-지켜라-1)

#### [[아이템36] 상속보다는 컴포지션을 사용하라](#아이템36-상속보다는-컴포지션을-사용하라-1)
#### [[아이템37] 데이터 집합 표현에 data 한정자를 사용하라](#아이템37-데이터-집합-표현에-data-한정자를-사용하라-1)
#### [[아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라](#아이템38-연산-또는-액션을-전달할-때는-인터페이스-대신-함수-타입을-사용하라-1)
#### [[아이템39] 태그 클래스보다는 클래스 계층을 사용하라](#아이템39-태그-클래스보다는-클래스-계층을-사용하라-1)
#### [[아이템40] equals 의 규약을 지켜라](#아이템40-equals-의-규약을-지켜라-1)
#### [[아이템41] hasCode 의 규약을 지켜라](#아이템41-hasCode-의-규약을-지켜라-1)
#### [[아이템42] compareTo 의 규약을 지켜라](#아이템42-compareTo-의-규약을-지켜라-1)
#### [[아이템43] API 의 필수적이지 않는 부분을 확장 함수로 추출하라](#아이템43-API-의-필수적이지-않는-부분을-확장-함수로-추출하라-1)
#### [[아이템44] 멤버 확장 함수의 사용을 피하라](#아이템44-멤버-확장-함수의-사용을-피하라-1)

<br>

# 1부 좋은 코드

<br>

## 1장 안정성 

### [아이템1] 가변성을 제한하라

- 상태를 갖게 하는 경우 발생하는 문제점 
  - 프로그램을 이해하고 디버그하기 힘들어진다. 
    - 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 추적하는 것이 힘들어진다.
  - 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워진다. 또한 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없다.
  - 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다. 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있다.
  - 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
- 코틀린에서 가변성 제한하기
  - 읽기 전용 프로퍼티(val)
    - 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면, 내부적으로 변할 수 있다.
    - var 은 게터와 세터를 모두 제공하지만, val 은 변경이 불가능하므로 게터만 제공한다.
    - **변수를 게터로 정의하면 스마트 캐스트를 할수 없다. 게터를 활용하므로, 값을 사용하는 시점에 따라서 다른 결과가 나올 수 있기 때문이다.**
      - 변수가 final 이고, 사용자 정의 게터를 갖지 않을 경우 스마트 캐스트 할 수 있다.
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기 
    - 읽기 전용: Iterable, Collection, Set, List
    - 읽고 쓰기 가능: MutableIterable, MutableCollection, MutableSet, MutableList
    - mutable 이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것이다.
    - **컬렉션 다운캐스팅은 예측하지 못한 결과를 초래하므로 사용하지 말자.**
      - 읽기 전용에서 mutable 로 변경해야 한다면 복제를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList 를 활용해야 한다.
  - 데이터 클래스의 copy
- immutable 객체 사용의 장점
  - 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
  - immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
  - immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
  - immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 된다.
  - immutable 객체는 set 또는 map 의 키로 사용할 수 있다.
    - mutable 객체는 요소에 수정이 일어나면 해시 테이블 내부에서 요소를 찾을 수 없게 되어 버리기 때문에 키로 사용할 수 없다.
- Delegates.observable 을 사용하면, 리스트에 변경이 있을 때 로그를 출력할 수 있다.
- **mutable 객체를 외부에 노출하지 않는 것이 좋다.**

### [아이템2] 변수의 스코프를 최소화하라

- 상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는 것이 좋다.
  - 프로퍼티보다는 지역 변수를 사용하는 것이 좋다. 
  - 최대한 좁은 스코프를 갖게 변수를 사용한다.
  - var 보다는 val 을 사용하는 것이 좋다. 
  - 람다에서는 변수를 갭처하기 때문에 주의하자. 시퀀스를 활용하는 식에서 변수를 캡처하면 의도치 않은 결과가 나올수도 있다.

### [아이템3] 최대한 플랫폼 타입을 사용하지 말라

- 플랫폼 타입이란, 다은 프로그래밍 언어에서 전달되어서 nullable 인지 알 수 없는 타입을 말한다.
- 자바를 코틀린과 함께 사용할 때, 가능한 @Nullable 과 @NotNull 어노테이션을 붙여서 사용하자.

### [아이템4] inferred 타입으로 리턴하지 말라

- **타입 추론으로 할당 할 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설전된다. 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다.**
- 타입 추론으로 할당된 변수가 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있다.
- 안전을 위해서 외부 API 를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자. 
- inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수도 있다는걸 기억하자! 

### [아이템5] 예외를 활용해 코드에 제한을 걸어라

- 코틀린에서 코드의 동젝에 제한을 거는 방법들
  - require 블록: 아규먼트와 관련된 예측을 정의할 때 사용 
  - check 블록: 상태와 관련된 동작 제한
  - assert 블록: 어떤 것이 true 인지 확인. assert 블록은 테스트 모드에서만 작동한다. 
  - return 또는 throw 와 함께 활용하는 Elvis 연산자
- 아규먼트
  - require 함수는 제한을 확인하고, 제한을 만족하지 못할 때 무조건적으로 IllegalArgumentException 을 throw 한다.
  - 람다를 활용해서 지연 메시지를 정의할수도 있다. 
    - ~~~kotlin
      require(n >= 0) { "Cannot calculate factorial of $n because it is smaller than 0"}
      ~~~
- 상태
  - 어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할때 사용한다. 
    - 어떤 객체가 미리 초기화 되어 있어야만 처리를 하게 하고 싶은 경우 
    - 객체를 사용할 수 있는 시점에 사용하고 싶은 경우 등등
  - check 함수는 require 와 비슷하지만, 지정된 예측을 만족하지 못할 때, IllegalStateException 을 throw 한다.
  - 상태가 올바른지 확인할 때 사용한다. 이러한 확인은 사용자가 규약을 어기고, 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 한다.
  - 일반적으로 require 블록 뒤에 배치한다.
- Assert 계열 함수 사용
  - assert 조건은 -ea JVM 옵션을 활성화 해야 확인 할 수 있다.
- nullability 와 스마트 캐스팅
  - 코틀린에서 require 와 check 블록으로 어떤 조건을 확인해서 true 가 나왔다면, 해당 조건은 이후로도 true 일거라고 가정한다.
  - 따라서 이를 활용해서 타입 비교를 했다면, 스마트 캐스트가 작동한다.
  - 어떤 대상이 null 인지 확인할 때 굉장히 유용하다! requireNotNull, checkNotNull 을 사용해도 괜찮다.
  - **nullability 를 목적으로, 오른쪽 throw 또는 return 을 두고 Elvis 연산자를 활용하면 유용하다.**
    - 오른쪽에 return 을 넣으면, 오류를 발생시키지 않고 단순하게 함수를 중지할 수도 있다.
    - **프로퍼티에 문제가 있어서 null 일 때 여러 처리를 해야 할 때도, return/throw 와 run 함수를 조합해서 활용할 수 있다.**

### [아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라

- 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋다. 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로, 이를 재사용하는 것이 좋다.
- IllegalArgumentException, IllegalStateException: 아이템5에서 다룬 require 와 check 를 사용해 throw 할 수 있는 예외
- IndexOutOfBoundsException: 인덱스 파라미터의 값이 범위를 벗어나는 경우 (예: ArrayList.get(Int))
- ConcurrentModificationException: 동시 수정을 금지 했는데, 발생했을 경우 
- UnsupportedOperationException: 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없는 경우
- NoSuchElementException: 사용자가 사용하려고 했던 요소가 존재하지 않는 경우

### [아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라

- 함수가 원하는 결과를 만들어 낼 수 없는 경우들 
  - 서버로부터 데이터를 읽어 들이려고 했는데, 네트워크 문제로 읽어 들이지 못한 경우 
  - 조건에 맞는 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우 
  - 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트 형식이 맞지 않는 경우 등등 
- 이러한 상황을 처리하는 메커니즘 두 가지 
  - null 또는 '실패를 나타내는 sealed 클래스(일반적으로 Failure 라는 이름을 붙인다.)'를 리턴
  - 예외를 throw 
- 위의 두 가지는 중요한 차이점이 있다. 일단 예외는 정보를 전달하는 방법으로 사용하면 안되고, 특별한 상황을 나타내야 하며, 처리되어야 한다.
  - 코틀린의 모든 예외는 unchecked 예외다. 따라서 사용자가 예외를 처리하지 않을 수도 있다.
    - 사용자가 반드시 처리하게 강제되는 예외를 checked 예외라고 부르고, 처리하지 않아도 실행에 문제가 없는 예외을 unchecked 예외라고 부른다.
  - 예외는 예외적인 상황을 처리하기 위해서 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않는다.
  - try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수 있는 최적화가 제한된다.
- **충분히 예측할 수 있는 범위의 오류는 null 과 Failure 를 사용하고, 예측하기 어려운 예외적인 범위의 오류는 예외를 throw 해서 처리하는 것이 좋다.**
- null 값과 sealed result 클래스의 차이는 추가적인 정보의 전달 유무다.

### [아이템8] 적절하게 null 을 처리하라

- nullable 타입을 처리하는 방법들
  - ?., 스마트캐스팅, Elvis 연산자 들을 활용해서 안전하게 처리 
  - 오류를 throw
  - 함수 또는 프로퍼티를 리팩터링해서 nullable 타입이 나오지 않게 바꾼다.
- !! 은 타입은 nullable 이지만, null 이 나오지 않는다는 것이 거의 확실한 상황에서 많이 사용된다.
- 변수를 null 로 설정하고, 이후에 !! 연산자를 사용하는 방법은 좋은 방법이 아니다.
- nullability 를 피할 때 사용할 수 있는 방법들
  - 클래스에서 nullability 에 따라 여러 함수를 만들어서 제공. 예) List\<T> 의 get 과 getOrNull
  - 어떤 값이 클래스 생성 이후에 확실하게 설정된다는 보장이 있다면, lateinit 프로퍼티와 notNull 델리게이트를 사용하라.
  - null 대신 빈 컬렉션을 리턴하라.
- lateinit 는 Int, Long 과 같은 기본 타입과 연결된 타입으로 프로퍼티를 초기화 해야하는 경우 사용할 수 없다. 이때는 lateinit 보다는 약간 느리지만, Delegates.notNull 을 사용한다.

### [아이템9] use 를 사용하여 리소스를 닫아라

- use 함수는 모든 Closeable 객체에 사용할 수 있다.
- 파일을 한줄씩 처리할 때는 userLines 함수를 사용할 수 있다.

### [아이템10] 단위 테스트를 만들어라

- 단위 테스트로 확인할 내용들 
  - 일반적인 유스 케이스: 요소가 사용될 거라고 예상되는 일반적인 방법을 테스트한다.
  - 일반적인 오류 케이스와 잠재적인 문제: 제대로 동작하지 않을 거라고 예상되는 일반적인 부분, 과거에 문제가 발생했던 부분 등을 테스트 
  - 에지 케이스와 잘못된 아규먼트: Int 의 경우 Int.MAX_VALUE 를 사용하는 경우, nullable 의 경우 null 또는 null 값으로 채워진 객체를 사용하는 경우, 아규먼트의 경계값에 대한 테스트 등등

## 2장 가독성

### [아이템11] 가독성을 목표로 설계하라

- 코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아니라, **가독성**을 좋게 하는데 목표를 두고 설계된 프로그래밍 언어이다.
- 가독성이란 코드르 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
- '인지 부하'를 줄이는 방향으로 코드를 작성하라. 
- let 을 많이 사용하는 경우 
  - nullable 가변 프로퍼티가 있고, null 이 아닐 때만 어떤 작업을 수행해야 하는 경우
  - 연산을 아규먼트 처리 후로 이동시킬 때
    - ~~~kotlin
      print(students.filter{}.joinToString{}) // 이러한 코드에서 print 라는 연산을 뒤로 이동 시켜서 아래 처럼 만드는 경우를 의미한다.
      students.filter{}.joinToString{}.let(::print)
      ~~~
  - 데코레이터를 사용해서 객체를 랩할 때
- 컨벤션
  - ~~~kotlin
    operator fun String.invoke(f: () -> String): String = this + f()
    infix fun String.and(s: String) = this + s
    val abc = "A" { "B" } and "C"
    println(abc)
    ~~~
  - 연산자는 의미에 맞게 사용해야 한다. invoke 를 위와 같은 형태로 사용하면 안된다. 
  - and 라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않는다.
  - 문자열을 결합하는 기능은 이미 언어에 내장되어 있다. 이미 있는 것을 다시 만들 필요는 없다.

### [아이템12] 연산자 오버로드를 할 때는 의미에 맞게 사용하라

- 코틀린에서 연산자에 대응되는 함수 이름

| 연산자    | 대응되는 함수             |
|:-------|:--------------------|
| +a     | a.unaryPlus()       |
| -a     | a.unaryMinus()      |
| !a     | a.not()             |
| ++a    | a.inc()             |
| --a    | a.dec()             |
| a+b    | a.plus(b)           |
| a-b    | a.minus(b)          |
| a*b    | a.times(b)          |
| a/b    | a.div(b)            |
| a..b   | a.rangeTo(b)        |
| a in b | b.contains(a)       |
| a+=b   | a.plusAssign(b)     |
| a-=b   | a.minusAssign(b)    |
| a*=b   | a.timesAssign(b)    |
| a/=b   | a.divAssign(b)      |
| a==b   | a.equals(b)         |
| a>b    | a.compareTo(b) > 0  |
| a<b    | a.compareTo(b) < 0  |
| a>=b   | a.compareTo(b) >= 0 |
| a<=b   | a.compareTo(b) <= 0 |

- 확장 함수를 정의할 때는 함수의 이름이 수행하는 논리 연산에 맞도록 하자. 
  - Int.not() 이라는 확장함수를 만들고 해당 Int 값의 팩토리얼을 계산하도록 한다면(5!) 혼란스럽고 오해의 소지가 생긴다.
- 의미가 명확하지 않은데 꼭 연산자 같은 형태로 사용하고 싶다면, infix 를 활용한 확장 함수를 사용하는 것이 좋다.
- 톱레벨 함수(클래스 또는 다른 대상 내부에 있지 않고, 가장 외부에 있는 함수)를 사용하는 것도 좋다.
- **연산자 오버로딩은 그 이름의 의미에 맞게 사용하도록 하자.**

### [아이템13] Unit?을 리턴하지 말라

- Unit? 으로 불을 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.
  - ~~~kotlin
    fun verifyKey(key: String): Unit? = //...
    verifyKey(key) ?: return
    ~~~
- 따라서 Boolean 을 사용하는 형태로 변경하는 것이 좋다.

### [아이템14] 변수 타입이 명확하지 않은 경우 확실하게 지정하라

- 가독성을 위해 코드를 설계할 때는 읽는 사람에게 중요한 정보를 숨겨서는 안된다.
- 타입을 무조건 지정하라는 것은 아니고 상황에 맞게 사용하도록 하자?..

### [아이템15] 리시버를 명시적으로 참조하라

- 확장 리시버(예: 확장 메서드에서의 this)를 명시적으로 참조하게 하여 가독성을 높일 수 있다.
- 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋다.(apply, with, run 등등)
- also 를 사용하면, 명시적으로 리시버를 지정하게 된다. 
- 일반적으로 also 또는 let 을 사용하는 것이 nullable 값을 처리할 때 훨씬 좋은 선택지이다.
- **리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해주는 것이 좋다.**
- 레이블 없이 리시버를 사용하면, 가장 가까운 리시버를 의미한다. 외부에 있는 리시버를 사용하려면, 레이블을 사용해야 한다.
- DslMarker
  - 코틀린 DSL 사용시 잘못된 사용을 막기 위해 암묵적으로 외부 리시버를 사용하는 것을 막기 위한 메타 어노테이션
  - **annotation class 에만 사용 가능하다.**
  - DSL 에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제할 수 있다.

### [아이템16] 프로퍼티는 동작이 아니라 상태를 나타내야 한다

- 코틀린의 프로퍼티는 자바의 필드와 비슷해 보이지만 다른 개념이다.
- 프로퍼티에는 사용자 정의 게터와 세터를 가질 수 있다.
  - 사용자 정의 게터, 세터 에는 field 라는 식별자가 있다. 이는 프로퍼티의 데이터를 저장해 두는 백킹 필드(backing field)에 대한 레퍼런스다.
  - 이러한 백킹 필드는 따로 만들지 않아도 디폴트로 생성된다.
  - val 을 사용해서 읽기 전용 프로퍼티를 만들 때는 field 가 만들어지지 않는다.
  - var 을 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있으며, 이러한 프로퍼티를 파생 프로퍼티(derived property) 라고 부른다.
- 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있다. 따라서 인터페이스를 구현하는 클래스에서 오버라이드 할 수 있다.
- **프로퍼티를 함수 대신 사용할 수도 있지만, 그렇다고 완전히 대체해서 사용하는 것은 좋지 않다.**
  - 게터에서 어떠한 알고리즘의 동작을 나타내는 것은 좋지 않다. 
  - 큰 컬렉션의 경우 결과를 받기까지 많은 계산량이 필요하고, 관습적으로 게터에 그런 계산량이 필요하다고 예상하지 않는다. 
  - 이러한 처리는 프로퍼티가 아니라 함수로 구현하는 것이 낫다.
- **프로퍼티 대신 함수를 사용하는 것이 좋은 경우**
  - 연산 비용이 높거나, 복잡도가 O(1) 보다 큰 경우
    - 연산비용이 많이 들어간다면, 함수를 사용하자. 그래야 사용자가 연산 비용을 예측하기 쉽고, 이를 기반으로 캐싱 등을 고려 할 수 있다.
  - 비즈니스 로직을 포함하는 경우
  - 결정적이지 않은 경우: 같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있다면, 함수를 사용하자. 
  - 반환의 경우: 변환을 프로퍼티로 만들면, 오해를 불러 일으킬 수 있다.
  - 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우

### [아이템17] 이름 있는 아규먼트를 사용하라

- 이름 있는 아규먼트를 사용하면 값이 무엇을 나타내는지 알 수 있고, 파라미터의 입력 순서와 상관 없으므로 안전하다.
- 이름 있는 아규먼트를 사용하는게 좋은 경우
  - 디폴트 아규먼트의 경우 
  - 같은 타입의 파라미터가 많은 경우 
  - 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)
    - 일반적으로 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋다.
    - 그 밖의 모든 함수 타입 아규먼트는 이름 있는 아규먼트를 사용하는 것이 좋다.

### [아이템18] 코딩 컨벤션을 지켜라

- 많은 파라미터를 갖고 있는 클래스나 함수는 각각의 파라미터를 한 줄씩 작성하자.
- 공통된 컨벤션을 위해 intellij 포매터, ktlink 같은 도구들을 활용해보자.

<br>

# 2부 코드 설계 

<br>

## 6장 클래스 설계

### [아이템36] 상속보다는 컴포지션을 사용하라
### [아이템37] 데이터 집합 표현에 data 한정자를 사용하라
### [아이템38] 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라
### [아이템39] 태그 클래스보다는 클래스 계층을 사용하라
### [아이템40] equals 의 규약을 지켜라
### [아이템41] hasCode 의 규약을 지켜라
### [아이템42] compareTo 의 규약을 지켜라
### [아이템43] API 의 필수적이지 않는 부분을 확장 함수로 추출하라
### [아이템44] 멤버 확장 함수의 사용을 피하라