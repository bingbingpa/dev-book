# 이펙티브 코틀린 *안전성, 가독성, 코드 설계, 효율성을 향상시키기 위한 52가지 전략과 기법*
- *마르친 모스칼라 저/윤인성 역 | 인사이트(insight) |*

<br>

## 아이템 목록

#### [[아이템1] 가변성을 제한하라](#아이템1-가변성을-제한하라-1)
#### [[아이템2] 변수의 스코프를 최소화하라](#아이템2-변수의-스코프를-최소화하라-1)
#### [[아이템3] 최대한 플랫폼 타입을 사용하지 말라](#아이템3-최대한-플랫폼-타입을-사용하지-말라-1)
#### [[아이템4] inferred 타입으로 리턴하지 말라](#아이템4-inferred-타입으로-리턴하지-말라-1)
#### [[아이템5] 예외를 활용해 코드에 제한을 걸어라](#아이템5-예외를-활용해-코드에-제한을-걸어라-1)
#### [[아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라](#아이템6-사용자-정의-오류보다는-표준-오류를-사용하라-1)
#### [[아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라](#아이템7-결과-부족이-발생할-경우-null-과-Failure-를-사용하라-1)
#### [[아이템8] 적절하게 null 을 처리하라](#아이템8-적절하게-null-을-처리하라-1)
#### [[아이템9] use 를 사용하여 리소스를 닫아라](#아이템9-use-를-사용하여-리소스를-닫아라-1)
#### [[아이템10] 단위 테스트를 만들어라](#아이템10-단위-테스트를-만들어라-1)

<br>

# 1부 좋은 코드

<br>

## 1장 안정성 

### [아이템1] 가변성을 제한하라

- 상태를 갖게 하는 경우 발생하는 문제점 
  - 프로그램을 이해하고 디버그하기 힘들어진다. 
    - 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 추적하는 것이 힘들어진다.
  - 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워진다. 또한 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없다.
  - 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다. 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있다.
  - 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
- 코틀린에서 가변성 제한하기
  - 읽기 전용 프로퍼티(val)
    - 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면, 내부적으로 변할 수 있다.
    - var 은 게터와 세터를 모두 제공하지만, val 은 변경이 불가능하므로 게터만 제공한다.
    - **변수를 게터로 정의하면 스마트 캐스트를 할수 없다. 게터를 활용하므로, 값을 사용하는 시점에 따라서 다른 결과가 나올 수 있기 때문이다.**
      - 변수가 final 이고, 사용자 정의 게터를 갖지 않을 경우 스마트 캐스트 할 수 있다.
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기 
    - 읽기 전용: Iterable, Collection, Set, List
    - 읽고 쓰기 가능: MutableIterable, MutableCollection, MutableSet, MutableList
    - mutable 이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것이다.
    - **컬렉션 다운캐스팅은 예측하지 못한 결과를 초래하므로 사용하지 말자.**
      - 읽기 전용에서 mutable 로 변경해야 한다면 복제를 통해서 새로운 mutable 컬렉션을 만드는 list.toMutableList 를 활용해야 한다.
  - 데이터 클래스의 copy
- immutable 객체 사용의 장점
  - 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
  - immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
  - immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
  - immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 된다.
  - immutable 객체는 set 또는 map 의 키로 사용할 수 있다.
    - mutable 객체는 요소에 수정이 일어나면 해시 테이블 내부에서 요소를 찾을 수 없게 되어 버리기 때문에 키로 사용할 수 없다.
- Delegates.observable 을 사용하면, 리스트에 변경이 있을 때 로그를 출력할 수 있다.
- **mutable 객체를 외부에 노출하지 않는 것이 좋다.**

### [아이템2] 변수의 스코프를 최소화하라
### [아이템3] 최대한 플랫폼 타입을 사용하지 말라
### [아이템4] inferred 타입으로 리턴하지 말라
### [아이템5] 예외를 활용해 코드에 제한을 걸어라
### [아이템6] 사용자 정의 오류보다는 표준 오류를 사용하라
### [아이템7] 결과 부족이 발생할 경우 null 과 Failure 를 사용하라
### [아이템8] 적절하게 null 을 처리하라
### [아이템9] use 를 사용하여 리소스를 닫아라
### [아이템10] 단위 테스트를 만들어라