# webflux 스터디(2024.10.17~)


## 1주차(2024.10.17) 

### 워커쓰레드 패턴

- [코드](https://gist.github.com/hikaMaeng/7f30f8497478fd15a81118aac4d44650)
- 쓰레드 여러 개를 실행
  - 동시에 처리할 작업만큼 쓰레드를 생성
  - 한정된 쓰레드가 쌓여진 작업을 해소
- 쌓여진 작업
  - 작업 생성 - 일반적으로 함수객체
  - 쌓아두기 - 동기화 큐에 넣기
  - 작업해소 - 무한 루프를 돌면서 큐에서 꺼내서 처리

### 순서가 있는 작업을 동시성으로 처리하려면?

- 동시성은 순서를 보장하지 않음
- 앞에 작업이 끝날 때 큐에 새로운 작업을 추가하는 방식을 사용
- 긴 작업을 얼마나 짧은 작업으로 쪼개는 가가 전체 동시성의 핵심

### 워커쓰레드 패턴 심화 #1

- 하나의 연결된 작업은 순차적으로 실행됨
  - 동시성 관리가 필요없음. 단일쓰레드에서 순차적으로 실행됨
  - 멀티쓰레딩은 하나의 연결된 작업이 아닌 이런거 여러 개를 동시에 함 
- 개별 작업은 동기적으로 쓰레드를 블록함 
  - 따라서 최대한 블록을 짧게하는 작업으로 분리해야함
  - 그 작업이 다시 다른 쓰레드를 쓰기도 함. 이 경우 다른 쓰레드의 종료를 수신하여 현재 작업 쓰레드를 종료해야 함(sink)
- 컨텍스트 스위칭이 일어나지 않음
  - 쓰레드가 한 번 실행하면 영원히 실행됨
  - 큐의 동기화는 순간적임. 큐 넣고 빼는 동기 비용은 개별작업 실행비용에 비하면 미미함. 작업 실행에 동기화 비용이 없음

### 워커쓰레드 패턴 심화 #2

- 쪼개진 작업이 끝날 때마다 보고를 받는게 장점
  - 쪼개진 작업시마다 업무를 처리해야 이점이 발생함
  - 어차피 다 모아서 끝난 다음에 할거면 큰 차이가 없음
  - 하다가 중단할 수 있지만 이것도 쪼개진 작업별로 처리할 경우임
- 워커쓰레드 패턴의 장점을 제거하는 예
  - 레코드셋 전체를 모아서 보내기 - 레코드 하나씩 SSE 로 쏘기
  - 긴 트랜잭션 구간 사용하기 - 결과적 일관성으로 옮기기
  - json 의 구조가 {data:[리스트]} 로 되어있음 - 작은 json 을 SSE 로 쏘기
  - 디비 질의가 큰 레코드셋을 반환하게 함
  - 여러 파일의 업로드가 다 끝나면 처리함 - 하나 올 때마다 처리
