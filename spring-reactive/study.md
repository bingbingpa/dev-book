# webflux 스터디(2024.10.17~)


## 1주차(2024.10.17) 

### 워커쓰레드 패턴

- [코드](https://gist.github.com/hikaMaeng/7f30f8497478fd15a81118aac4d44650)
- 쓰레드 여러 개를 실행
  - 동시에 처리할 작업만큼 쓰레드를 생성
  - 한정된 쓰레드가 쌓여진 작업을 해소
- 쌓여진 작업
  - 작업 생성 - 일반적으로 함수객체
  - 쌓아두기 - 동기화 큐에 넣기
  - 작업해소 - 무한 루프를 돌면서 큐에서 꺼내서 처리

### 순서가 있는 작업을 동시성으로 처리하려면?

- 동시성은 순서를 보장하지 않음
- 앞에 작업이 끝날 때 큐에 새로운 작업을 추가하는 방식을 사용
- 긴 작업을 얼마나 짧은 작업으로 쪼개는 가가 전체 동시성의 핵심

### 워커쓰레드 패턴 심화 #1

- 하나의 연결된 작업은 순차적으로 실행됨
  - 동시성 관리가 필요없음. 단일쓰레드에서 순차적으로 실행됨
  - 멀티쓰레딩은 하나의 연결된 작업이 아닌 이런거 여러 개를 동시에 함 
- 개별 작업은 동기적으로 쓰레드를 블록함 
  - 따라서 최대한 블록을 짧게하는 작업으로 분리해야함
  - 그 작업이 다시 다른 쓰레드를 쓰기도 함. 이 경우 다른 쓰레드의 종료를 수신하여 현재 작업 쓰레드를 종료해야 함(sink)
- 컨텍스트 스위칭이 일어나지 않음
  - 쓰레드가 한 번 실행하면 영원히 실행됨
  - 큐의 동기화는 순간적임. 큐 넣고 빼는 동기 비용은 개별작업 실행비용에 비하면 미미함. 작업 실행에 동기화 비용이 없음

### 워커쓰레드 패턴 심화 #2

- 쪼개진 작업이 끝날 때마다 보고를 받는게 장점
  - 쪼개진 작업시마다 업무를 처리해야 이점이 발생함
  - 어차피 다 모아서 끝난 다음에 할거면 큰 차이가 없음
  - 하다가 중단할 수 있지만 이것도 쪼개진 작업별로 처리할 경우임
- 워커쓰레드 패턴의 장점을 제거하는 예
  - 레코드셋 전체를 모아서 보내기 - 레코드 하나씩 SSE 로 쏘기
  - 긴 트랜잭션 구간 사용하기 - 결과적 일관성으로 옮기기
  - json 의 구조가 {data:[리스트]} 로 되어있음 - 작은 json 을 SSE 로 쏘기
  - 디비 질의가 큰 레코드셋을 반환하게 함
  - 여러 파일의 업로드가 다 끝나면 처리함 - 하나 올 때마다 처리

## 2주차(2024.10.24)

### 웹플럭스의 응답

- Mono\<X> - 하나 X 를 응답으로 보냄
- Flux\<X> - [SSE](https://medium.com/deliveryherotechhub/what-is-server-sent-events-sse-and-how-to-implement-it-904938bffd73) 로 여러 개의 X 를 응답으로 보냄
- Mono\<Void> - 스프링이 자동으로 응답을 보내지 않음. 왜 쓸까?
  - 1, 2 번은 스프링이 일반적인 경우에 대해 기본처리를 해 줌
  - 헌데 보다 정밀한 청크처리나 SSE 가 아닌 형식의 스트림을 쓰고 싶다면 스트림을 통제해야 함
  - SSE 를 왜 안쓸까?
    - 보통 브라우저에서 SSE 를 구현하는 방법은 EventSource 라는 객체를 사용하는 것임 
    - 근데 이 브라우저 객체를 사용해 통신하면 요청에 헤더값을 넣을 수 없음
    - fetch 를 복잡하게 커스터마이즈 해야함
    - 이럴거면 굳이 SSE 스펙을 지킬 이유가 있나?

### Mono\<Void> 사용하기

- ServerHttpRequest 의 body 가 Flux 로 들어옴
- ServerHttpResponse 의 [writeAndFlushWith](https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests?hl=ko) 를 사용하면 응답을 Flux 로 할 수 있음
- 가장 raw 한 레벨의 http 통신은 전부 DataBuffer(byteArray) 수준으로 주고 받음
- http1.1 이냐 http2 냐 결정하기
  - 1.1 은 심플렉스 - 모든 request 공정이 끝나야 response 가 가능
  - 2는 멀티플렉스 - request 스트림과 response 스트림이 동시에 가능
- [코드1](https://gist.github.com/hikaMaeng/432e48ab2d37e638bfb468e50493c466)
- [코드2](https://gist.github.com/hikaMaeng/d92f27d67d109c746740850495ae849d)

### 이것저것

- flatMap, concat, merge, sink 는 확실히 알아두자!