# Kotlin in Action
- *드미트리 제메로프, 스베트라나 이사코바 저/오현석 역 | 에이콘출판사*

<br>

# 1부 코틀린 소개

<br>

## 1장 코틀린이란 무엇이며, 왜 필요한가?

- 코틀린도 자바와 마찬가지로 정적 타입 지정 언어다. 정적 타입 지정이라는 말은 모든 프로그램 구성 요소의 타입을 
컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 검증해준다는 뜻이다.
- 정적 타입 지정의 장점
  - 성능: 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다.
  - 신뢰성: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
  - 유지 보수성: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 함수형 프로그래밍의 핵심 개념
  - 일급 시민인(first class) 함수: 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
  - 불면성(immutability): 일단 한번 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다. 
  - 부수 효과(side effect) 없음: 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.
- 코틀린은 객체지향과 함수형 프로그래밍 스타일을 모두 지원한다. 코틀인에서는 일급 시민 함수를 사용해 수준 높은 추상화가 가능하고,
불변 값 지원을 통해 다중 스레드 애플리케이션 개발과 테스트를 더 쉽게 할 수 있다.
- 코틀린의 철학
  - 실용성: 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존하면서 실용성을 높였다.
  - 간결성: getter, setter, 생성자 파라미터를 필드에 대입하기 위한 로직 등 여러 가지 번거로운 준비 코드를 묵시적으로 제공하기 때문에 더 간결하다.
  - 안전성: JVM 에서 실행하면서 이미 상당한 안전성을 보장하고, 코틀린의 타입 시스템은 null 이 될 수 없는 값을 추적하며, 실행 시점에 NPE 이 발생할 수 있는 연산을 사용하는 코드를 금지한다.
  - 상호운용성: 다른 일부 JVM 언어와 달리 코틀린은 상호운옹성 측면에서 훨씬 더 많은 것을 제공한다.

## 2장 코틀린 기초

### 2.1 기본 요소: 함수와 변수

- 코틀린 기본 문법
  - 함수를 선언할 때 fun 키워드를 사용한다.
  - 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다. 변수를 선언할 때도 마찬가지 방식으로 타입을 지정한다. 
  - 함수를 최상위 수준에 정의할 수 있다. 자바와 달리 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
  - 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다. 
  - 코틀인 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다. println 도 그런 함수중 하나다.
  - 줄 끝에 세미콜론을 붙이지 않아도 된다.
- 문(statement) 과 식(expression)의 구분
  - **코틀린에서 if 는 식이지 문이 아니다.** 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 할 수 있는 반면
문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.
  - 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다. 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.
  - 코틀린의 if (a > b) a else b 는 자바의 a > b ? a : b 처럼 작동한다.
  - 코틀린에서는 if 가 값을 만들어 내기 때문에 자바와 달리 3항 연산자가 따로 없다.
- 본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.
- 변수
  - 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.
    - ~~~kotlin
      val question = "삶, 우주에 대한 질문"
      val answer: Int = 42
      ~~~
  - 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
  - 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 따라서 그런 경우 타입을 반드시 지정해야 한다.
  - **변경 가능한 변수와 변경 불가능한 변수**
    - val(값을 뜻하는 value 에서 따옴): 변경 불가능한(immutable) 참조를 지정하는 변수다. 자바로 말하면 final 변수 
    - var(변수를 뜻하는 variable 에서 따옴): 변경 가능한(mutable) 참조다. 자바의 일반 변수
    - **기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var 로 변경하라.**
  - 문자열 템플릿
    - 컴파일러는 각 식을 정적으로 (컴파일 시점에) 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.
    - '$' 문자를 문자열에 넣고 싶으면 println("\$x") 와 같이 \ 를 사용해 $ 를 이스케이프(escape) 시켜야 한다.  

### 2.2 클래스와 프로퍼티

- 코드가 없이 데이터만 저장하는 클래스를 **값 객체**(value object)라 부르며, 다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.
- 코틀린의 기본 가시성은 public 이므로 이런 경우 변경자를 생략해도 된다.
- **클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.**
- 자바에서는 필드와 접근자를 한데 묶어 **프로퍼티**(property)라고 부르며, 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.
- **자바로 변환시 읽기 전용 프로퍼티(val)의 경우 게터만 만들어내고, 쓸 수 있는 프로퍼티(var)의 경우는 게터, 세터를 만들어낸다.**
  - intellij 에서 코틀린 파일을 자바로 확인하는 방법
    - Tools - Kotlin - Show Kotlin ByteCode - Decompile 선택
- 자바로 변환시 게터와 세터의 이름을 정하는 규칙의 예외
  - 이름이 is 로 시작하는 프로퍼티의 게터에는 get 이 붙지 않고 원래 이름 그대로 사용하며, 세터에는 is 를 set 으로 바꾼 이름을 사용한다.
- 디렉터리와 패키지
  - 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다.
    - **자바와 코틀린은 할께 사용하는 경우를 고려해서 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다.**
  - 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.
  - 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다.

### 2.3 enum 과 when

- when
  - if 와 마찬가지로 when 도 값을 만들어내는 식이다. 따라서 식이 본문인 함수에 when 을 바로 사용 할 수 있다.
  - 자바와 달리 각 분기의 끝에 break 를 넣지 않아도 된다.
  - 한 분기 안에서 여러 값을 매치 패턴으로 사용 할 수 있고, 그럴 경우 값 사이를 콤마(,)로 분리한다.
  - 자바에서 처럼 상수 값을 임포트해서 사용 할 수 있다.
  - 분기 조건에 상수만을 사용할 수 있는 자바 switch 와 달리 코틀린 when 의 분기 조건은 임의의 객체를 허용한다.
  - 인자가 없는 when 식을 사용하면 불필요한 객체 생성을 막을 수 있다. 하지만 코드는 약간 읽기 어려워진다. 성능 향상과 가독성의 필요성에 따라 적절하게 사용하자.
  - **when 에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.**
- 스마트 캐스트: 타입 검사와 타입 캐스트를 조합
  - 코틀린에서는 is 를 사용해 어떤 변수가 원하는 타입인지 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅 하지 않아도 사용 할 수 있다. 
  - 실제로는 컴파일러가 캐스팅을 수행해주는데 이를 **스마트 캐스트**라고 부른다.
- *블록의 마지막 식이 블록의 결과*라는 규칙은 함수에 대해서는 성립하지 않는다. 식이 본문인 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return 문이 반드시 있어야 한다.

### 2.4 while 과 for 루프

- 코틀린에는 자바의 for 루프에 해당하는 요소가 없다. 가장 흔한 용례인 초깃값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 코틀린에서는 범위(range)를 사용한다.
- 범위는 기본적으로 두 값으로 이루어진 구간이다. .. 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다. 
  - ~~~kotlin
    val oneToTen = 1..10
    ~~~
- 코틀린의 범위는 양끝을 포함하는 구간으로(위예에서는 10)이 항상 범위에 포함된다는 뜻이다.
- step 을 사용해서 증가 값을 사용 할 수 있다.
- downTo 를 이용해 역방향으로 순회할 수 있다.
- .. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다.('A'..'F')
- 리스트 순회시 list.withIndex() 를 사용해 인덱스를 쓸 수 있다.
- !in 을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.
  
### 2.5 코틀린의 예외 처리

- 자바와 달리 코틀린의 throw 는 식이므로 다른 식에 포함될 수 있다.
- **자바 코드와 가장 큰 차이는 throws 절이 코드에 없다는 점이다.**
- 코틀린에서는 체크 예외와 언체크 예외(unchecked)를 구별하지 않는다.
- 코틀린의 try 키워드는 if 나 when 과 마찬가지로 식이다. 따라서 try 의 값을 변수에 대입할 수 있다.