# Kotlin in Action
- *드미트리 제메로프, 스베트라나 이사코바 저/오현석 역 | 에이콘출판사*

<br>

# 1부 코틀린 소개

<br>

## 1장 코틀린이란 무엇이며, 왜 필요한가?

- 코틀린도 자바와 마찬가지로 정적 타입 지정 언어다. 정적 타입 지정이라는 말은 모든 프로그램 구성 요소의 타입을 
컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 검증해준다는 뜻이다.
- 정적 타입 지정의 장점
  - 성능: 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다.
  - 신뢰성: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
  - 유지 보수성: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 함수형 프로그래밍의 핵심 개념
  - 일급 시민인(first class) 함수: 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
  - 불면성(immutability): 일단 한번 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다. 
  - 부수 효과(side effect) 없음: 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.
- 코틀린은 객체지향과 함수형 프로그래밍 스타일을 모두 지원한다. 코틀인에서는 일급 시민 함수를 사용해 수준 높은 추상화가 가능하고,
불변 값 지원을 통해 다중 스레드 애플리케이션 개발과 테스트를 더 쉽게 할 수 있다.
- 코틀린의 철학
  - 실용성: 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존하면서 실용성을 높였다.
  - 간결성: getter, setter, 생성자 파라미터를 필드에 대입하기 위한 로직 등 여러 가지 번거로운 준비 코드를 묵시적으로 제공하기 때문에 더 간결하다.
  - 안전성: JVM 에서 실행하면서 이미 상당한 안전성을 보장하고, 코틀린의 타입 시스템은 null 이 될 수 없는 값을 추적하며, 실행 시점에 NPE 이 발생할 수 있는 연산을 사용하는 코드를 금지한다.
  - 상호운용성: 다른 일부 JVM 언어와 달리 코틀린은 상호운옹성 측면에서 훨씬 더 많은 것을 제공한다.

## 2장 코틀린 기초

### 2.1 기본 요소: 함수와 변수

- 코틀린 기본 문법
  - 함수를 선언할 때 fun 키워드를 사용한다.
  - 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다. 변수를 선언할 때도 마찬가지 방식으로 타입을 지정한다. 
  - 함수를 최상위 수준에 정의할 수 있다. 자바와 달리 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
  - 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다. 
  - 코틀인 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다. println 도 그런 함수중 하나다.
  - 줄 끝에 세미콜론을 붙이지 않아도 된다.
- 문(statement) 과 식(expression)의 구분
  - **코틀린에서 if 는 식이지 문이 아니다.** 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 할 수 있는 반면
문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.
  - 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다. 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.
  - 코틀린의 if (a > b) a else b 는 자바의 a > b ? a : b 처럼 작동한다.
  - 코틀린에서는 if 가 값을 만들어 내기 때문에 자바와 달리 3항 연산자가 따로 없다.
- 본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.
- 변수
  - 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.
    - ~~~kotlin
      val question = "삶, 우주에 대한 질문"
      val answer: Int = 42
      ~~~
  - 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
  - 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 따라서 그런 경우 타입을 반드시 지정해야 한다.
  - **변경 가능한 변수와 변경 불가능한 변수**
    - val(값을 뜻하는 value 에서 따옴): 변경 불가능한(immutable) 참조를 지정하는 변수다. 자바로 말하면 final 변수 
    - var(변수를 뜻하는 variable 에서 따옴): 변경 가능한(mutable) 참조다. 자바의 일반 변수
    - **기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var 로 변경하라.**
  - 문자열 템플릿
    - 컴파일러는 각 식을 정적으로 (컴파일 시점에) 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.
    - '$' 문자를 문자열에 넣고 싶으면 println("\$x") 와 같이 \ 를 사용해 $ 를 이스케이프(escape) 시켜야 한다.  

### 2.2 클래스와 프로퍼티

- 코드가 없이 데이터만 저장하는 클래스를 **값 객체**(value object)라 부르며, 다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.
- 코틀린의 기본 가시성은 public 이므로 이런 경우 변경자를 생략해도 된다.
- **클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.**
- 자바에서는 필드와 접근자를 한데 묶어 **프로퍼티**(property)라고 부르며, 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.
- **자바로 변환시 읽기 전용 프로퍼티(val)의 경우 게터만 만들어내고, 쓸 수 있는 프로퍼티(var)의 경우는 게터, 세터를 만들어낸다.**
  - intellij 에서 코틀린 파일을 자바로 확인하는 방법
    - Tools - Kotlin - Show Kotlin ByteCode - Decompile 선택
- 자바로 변환시 게터와 세터의 이름을 정하는 규칙의 예외
  - 이름이 is 로 시작하는 프로퍼티의 게터에는 get 이 붙지 않고 원래 이름 그대로 사용하며, 세터에는 is 를 set 으로 바꾼 이름을 사용한다.
- 디렉터리와 패키지
  - 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다.
    - **자바와 코틀린은 할께 사용하는 경우를 고려해서 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다.**
  - 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.
  - 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다.

### 2.3 enum 과 when

- when
  - if 와 마찬가지로 when 도 값을 만들어내는 식이다. 따라서 식이 본문인 함수에 when 을 바로 사용 할 수 있다.
  - 자바와 달리 각 분기의 끝에 break 를 넣지 않아도 된다.
  - 한 분기 안에서 여러 값을 매치 패턴으로 사용 할 수 있고, 그럴 경우 값 사이를 콤마(,)로 분리한다.
  - 자바에서 처럼 상수 값을 임포트해서 사용 할 수 있다.
  - 분기 조건에 상수만을 사용할 수 있는 자바 switch 와 달리 코틀린 when 의 분기 조건은 임의의 객체를 허용한다.
  - 인자가 없는 when 식을 사용하면 불필요한 객체 생성을 막을 수 있다. 하지만 코드는 약간 읽기 어려워진다. 성능 향상과 가독성의 필요성에 따라 적절하게 사용하자.
  - **when 에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.**
- 스마트 캐스트: 타입 검사와 타입 캐스트를 조합
  - 코틀린에서는 is 를 사용해 어떤 변수가 원하는 타입인지 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅 하지 않아도 사용 할 수 있다. 
  - 실제로는 컴파일러가 캐스팅을 수행해주는데 이를 **스마트 캐스트**라고 부른다.
- *블록의 마지막 식이 블록의 결과*라는 규칙은 함수에 대해서는 성립하지 않는다. 식이 본문인 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return 문이 반드시 있어야 한다.

### 2.4 while 과 for 루프

- 코틀린에는 자바의 for 루프에 해당하는 요소가 없다. 가장 흔한 용례인 초깃값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 코틀린에서는 범위(range)를 사용한다.
- 범위는 기본적으로 두 값으로 이루어진 구간이다. .. 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다. 
  - ~~~kotlin
    val oneToTen = 1..10
    ~~~
- 코틀린의 범위는 양끝을 포함하는 구간으로(위예에서는 10)이 항상 범위에 포함된다는 뜻이다.
- step 을 사용해서 증가 값을 사용 할 수 있다.
- downTo 를 이용해 역방향으로 순회할 수 있다.
- .. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다.('A'..'F')
- 리스트 순회시 list.withIndex() 를 사용해 인덱스를 쓸 수 있다.
- !in 을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.
  
### 2.5 코틀린의 예외 처리

- 자바와 달리 코틀린의 throw 는 식이므로 다른 식에 포함될 수 있다.
- **자바 코드와 가장 큰 차이는 throws 절이 코드에 없다는 점이다.**
- 코틀린에서는 체크 예외와 언체크 예외(unchecked)를 구별하지 않는다.
- 코틀린의 try 키워드는 if 나 when 과 마찬가지로 식이다. 따라서 try 의 값을 변수에 대입할 수 있다.

## 3장 함수 정의와 호출

### 3.1 코틀린에서 컬렉션 만들기

- 컬렉션 만들기: setOf(), hashSetOf(), arrayListOf(), hashMapOf()
- 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스다.

### 3.2 함수를 호출하기 쉽게 만들기

- 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있다.
- @JvmOverloads 를 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메소드를 추가해준다. 
- 코틀린에서는 자바의 유틸클래스와 같은 무의미한 클래스가 필요 없다. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다.
- 코틀린 컴파일러는 코틀린 소스 파일의 이름과 대응하는 클래스를 생성한다.
  - 코틀린 최상위 함수가 포함되는 클래스의 이름을 바꾸고 싶다면 파일에 @file:JvmName("생성될 클래스명") 애노테이션을 파일의 맨 앞, 패키지 이름 선언 이전에 위치하면 된다.
- 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.
- const 변경자를 추가하면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다.(단, 원시 타입과 String 타입의 프로퍼티만 const 로 지정할 수 있다.)
  - ~~~kotlin
    const val UNIX_LINE_SEPARATOR = "\n"
    ~~~
    
### 3.3 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

- 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다.
- 확장 함수 만들기
  - 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙인다. 
  - 클래스의 이름을 **수신 객테 타입**(receiver type)이라 부르며, 확장 함수가 호출되는 대상이 되는 값(객체)을 **수신 객체**(receiver object)라고 부른다.
  - 아래에서 String 이 수신객테 타입, this 는 수신 객체
  - 일반 메소드의 본문에서 this 를 사용할 때와 마찬가지로 확장 함수 본문에도 this 를 쓸수도 있고 생략 할 수도 있다.
    - ~~~kotlin
      fun String.lastChar(): char = this.get(this.length - 1)
      ~~~
      ~~~kotlin
      println("Kotlin".lastChar())
      ~~~
- **확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 비공개 멤버나 보호된 멤버를 사용할 수 없다.**
- **내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. 그래서 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점 부가 비용이 들지 않는다.**
  - 자바에서 사용한다고 하면 정적 메소드를 호출하면서 첫 번째 인자로 수신 객체를 넘기기만 하면 된다. 만약 확장 함수를 StringUtil.kt 파일에 정의했다면 다음과 같이 호출 할 수 있다.
    - ~~~ java
      char c = StringUtilKt.lastChar("Java");
      ~~~
- 확장 함수가 정적 메소드와 같은 특징을 가지므로, 확장 함수를 하위 클래스에서 오버라이드 할 수는 없다.
- **확장 함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정되지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다.**
- **어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다.(멤버 함수의 우선순위가 더 높다.)**
- 확장 프로퍼티 
  - **뒷받침하는 필드**(73페이지 참조)가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의를 해야 한다.

### 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

- vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다.(자바에서 타입 뒤에 ... 를 붙이는 것처럼)
  - 가변 일자를 전달할때는 배열 앞에 *를 붙이기만 하면된다.(기술적으로 스프레드 연산자가 배열의 내용을 펼쳐준다.)
- 중위(infix)함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다.
  - 종위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다(이때 객체, 메소드 이름, 유일한 인자 사이에는 공백이 들어가야 한다.). 다음 두 호출은 동일하다.
    - ~~~kotlin
      1.to("one")
      1 to "one"
      ~~~
- 구조 분해 선언(destructuring declaration)을 사용하면 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다.

### 3.5 문자열과 정규식 다루기

- 자바 split 메소드로는 점(.)을 사용해 문자열을 분리 할 수 없다. split 의 구분 문자열은 실제로는 정규식이기 때문이다. 따라서 마침표는 모든 문자를 나타내는 정규식으로 해석된다.
- 코틀린에서는 toRegex 확장 함수를 사용해 문자열을 정규식으로 변환할 수 있다.
  - ~~~kotlin
    println("12.345-6.A".split("\\.|-".toRegex()))
    ~~~
- 3중 따옴표 문자열에서는 역슬래시(\\)를 포함한 어떤 문자도 이스케이프 할 필요가 없다.

### 3.6 코드 다듬기: 로컬 함수와 확장

- 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 그렇게 하면 문법적인 부가 비용을 들이지 않고도 갈끔하게 코드를 조직할 수 있다.
- 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용 할 수 있다.
- 중첩된 함수의 깊이가 깊어지면 코드를 읽기가 어렵기 때문에, 일반적으로 한 단계만 함수를 중첩시키는게 좋다.

## 4장 클래스, 객체, 인터페이스

### 4.1 클래스 계층 정의 

- 자바와 달리 코틀린 선언은 기본적으로 final 이며 public 이다. 
- 중첩 클래스는 기본적으로 내부 클래스가 아니다. 즉, 코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.
- 코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.
  - 자바와 마찬가지로 인터페이스는 제한 없이 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다.
- 코틀린에서 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 **오버라이드 하려면 *override* 변경자를 꼭 사용해야 한다.**
- 상위 타입의 이름을 꺽쇠 괄호(<>) 사이에 넣어서 "super"를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.
- 어떤 클래스의 상속을 허용하려면 클래스 앞에 *open* 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 open 변경자를 붙여야 한다.
- 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오보라이드하는 메소드 앞에 final 을 명시해야 한다.
- 인터페이스 멤버의 경우 final, open, abstract 를 사용하지 않는다. 인터페이스 멤버는 항상 열려 있으며 final 로 변경할 수 없다.
- 자바의 기본 가시성인 패키지 전용은 코틀린에 없고, 코틀린의 기본 가시성은 public 이다.
  - 패키지 전용 가시성에 대한 대안으로 코틀린에는 internal 이라는 새로운 가시성 변경자를 도입했다.
  - internal 은 모듈 내부에서만 볼 수 있음을 뜻한다.
  - 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.
- 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다. protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.
- 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다.
- **코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.**
  - 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 한다.
  - 내부 클래스 Inner 안에서 바깥쪽 클래스 Outer 의 참조에 접근 하려면 this@Outer 라고 써야 한다.
- 클래스 계층 정의 시 계층 확장 제한
  - 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.
  - sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스안에 중첩시켜야 한다.
  - when 식에서 sealed 클래스의 모든 하위 클래스를 처리 한다면 디폴트 분기(else 분기)가 필요 없다.
  - sealed 로 표시된 클래스는 자동으로 open 이기 때문에 별도로 open 변경자를 붙일 필요가 없다.

### 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

- 클래스 초기화: 주 생성자와 초기화 블록
  - 코틀린은 주 생성자와 부 생성자를 구분한다. 또한 코틀린에서는 초기화 블록을 통해 초기화 로직을 추가할 수 있다.
  - 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 **주 생성자**(primary constructor)라고 부른다.
  - **클래스 정의에 있는 상위 클래스 및 인터페이스 목록에서 이름 뒤에 괄호가 붙었는지 살펴보면 쉽게 기반 클래스와 인터페이스를 구별할 수 있다.**
- 부 생성자: 상위 클래스를 다른 방식으로 초기화
  - **인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말라. 대신 파라미터의 디폴트 값을 생성자 시그니처에 직접 명시하라.**
- 인터페이스에 선언된 프로퍼티 구현
  - 코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다.
  - 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수도 있다.
- 게터와 세터에서 뒷밤침하는 필드에 접근
  - 접근자의 본문에서는 *field*라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있다. 게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 쓸 수 있다.
- 접근자의 가시성 변경
  - 접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 하지만 원한다면 get 이나 set 앞에 가시성 변경자를 추가해서 접근자의 가시성을 변경할 수 있다.

### 4.3 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임

- **코틀린에서 == 연산자는 참조 동일성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals 를 호출하는 식으로 컴파일된다.**
- "Any" 는 java.lan.Object 에 대응하는 클래스로, 코틀린의 모든 클래스의 최상위 클래스다.
- 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성
  - data 라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다.(toString, equals, hashCode 등등)
  - 데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 copy() 라는 편의 메소드를 제공한다. 
- 클래스 위임: by 키워드 사용
  - 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.
  - 메소드 중 일부의 동작을 변경하고 싶은 경우 메소드를 오버라이드하면 컴파일러가 생성한 메소드 대신 오버라이드한 메소드가 쓰인다.
  - 기존 클래스의 메소드에 위임하는 기본 구현으로 충분한 메소드는 따로 오버라이드할 필요가 없다.

### 4.4 object 키워드: 클래스 선언과 인스턴스 생성

- 객체 선언: 싱글턴을 쉽게 만들기
  - 코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다.
  - 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.
  - 객체 선언은 object 키워드로 시작하고, 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다.
  - 클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어 갈 수 있지만 생성자는 객체 선언에 쓸 수 없다.
- 동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소
  - 동반 객체는 클래스 안에 정의된 일반 객체다. 
  - 클래스 안에 정의된 객체 중 하나에 *companion*이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다.
  - 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다. 이때 객체의 이름을 따로 지정할 필요가 없다.
  - 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 동반 객체의 바깥쪽 클래스의 private 생성자도 호출할 수 있다.
  - 클래스를 확장해야만 하는 경우에는 동반 객체 멤버를 하위 클래스에서 오버라이드할 수 없으므로 여러 생성자를 사용하는 편이 더 나은 해법이다.
- 동반 객체를 일반 객체처럼 사용
  - 클래스의 이름을 통해 동반 객체에 속한 멤버를 참조할 수도 있고, companion object Loader 같은 방식으로 동반 객체에도 이름을 붙일 수 있다.
  - 동반 객체도 인터페이스를 구현할 수 있다.
- 객체 식: 무명 내부 클래스를 다른 방식으로 작성
  - 무명 객체(anonymous object)를 정의할 때도 object 키워드를 쓴다. 무명 객체는 자바의 무명 내부 클래스를 대신한다.
  - 한 인터페이스만 구현하거나 한 클래스만 확장할 수 있는 자바의 무명 내부 클래스와 달리 코틀린 무명 클래스는 여러 인터페이스를 구현하거나 클래스를 확장하면서 인터페이스를 구현할 수 있다.
  - **객체 선언과 달리 무명 객체는 싱글턴이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.**
  - 객체 식은 무명 객체 안에서 여러 메소드를 오버라이드해야 하는 경우에 훨씬 더 유용하다. 메소드가 하나뿐인 인터페이스를 구현해야 한다면 코틀린의 SAM(Single Abstract Method) 변환 지원을 활용하는 편이 낫다.

## 5장 람다로 프로그래밍

### 5.1 람다 식과 멤버 참조

- 람다 식(lambda expression) 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.
- 코틀린에서는 모든 컬렉션에 대해 maxBy 함수를 호출할 수 있다. maxBy 는 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수를 인자로 받는다.
- 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run 을 사용한다. run 은 인자로 받은 람다를 실행해주는 라이브러리 함수다.
- 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it 을 바로 쓸 수 있다.
  - 람다 파라미터로 이름을 따로 지정하지 않은 경우에만 it 이라는 이름이 자동으로 만들어진다.
  - 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 낫다. 파라미터를 명시하지 않으면 각각의 it 이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기 어려울 수 있다.
  - ~~~kotlin
    people.maxBy { it.age }
    ~~~
- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않기 때문에 파라미터 타입을 명시해야 한다.
- 자바와 다르게 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다. 또한 람다 안에서 바깥의 변수를 변경해도 된다.
- **람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다.**

### 5.2 필수적인 함수: filter 와 map

- filter 함수는 컬렉션에서 원치 않는 원소를 제거한다. 하지만 filter 는 원소를 변환 할 수는 없다. 원소를 변환하려면 map 함수를 사용해야 한다.
- map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.
- **꼭 필요하지 않은 경우 굳이 계산을반복하지 말라!**
- find 함수는 조건을 만족하는 첫 번째 원소를 반환한다.
  - 만족하는 원소가 전혀 없는 경우 null 을 반환한다.
  - find 는 firstOrNull 과 같고, 조건을 만족하는 원소가 없으면 null 이 나온다는 사실을 더 명확히 하고 싶다면 firstOrNull 을 쓸 수 있다.
- all 함수는 모든 원소가 술어를 만족하는지 확인할 때 사용한다.
- any 함수는 술어를 만족하는 원소가 하나라도 있는지 확인할 때 사용한다.
- 어떤 조건에 대해 !all 을 수행한 결과와 그 조건의 부정에 대해 any 를 수행한 결과는 같다. 
  - 어떤 조건에 대해 !any 를 수행한 결과와 그 조건의 부정에 대해 all 을 수행한 결과도 같다. 
  - **가독성을 높이려면 any 와 all 앞에 !를 붙이지 않는 편이 낫다.**
- count 함수는 술어를 만족하는 원소의 개수를 구할 때 사용한다.
  - 아래처럼 처리하면 조건을 만족한는 모든 원소가 들어가는 중간 컬렉션이 생긴다. 
  - 반면 count 는 조건을 만족하는 원소의 개수만을 추적하지 조건을 만족하는 원소를 따로 저장하지 않는다.
  - 따라서 count 가 훨씬 더 효율적이다
    - ~~~kotlin
      println(people.filter(canBeInClub27).size)
      ~~~
- groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경
  - 이 연산의 결과는 컬렉션의 원소를 구분하는 특성이 키이고, 키 값에 따른 각 그룹이 값인 맵이다.
- flatMap 과 flatten: 중첩된 컬렉션 안의 원소 처리
  - 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.
  - 중첩된 리스트의 원소를 한 리스트로 모아야 한다면 flatMap 을, 특별히 변환해야 할 내용이 없이 리스트의 리스트를 평평하게 펼치기만 하면 된다면 flatten() 함수를 사용할 수 있다.

### 5.3 지연 계산(lazy) 컬렉션 연산

- map 이나 filter 같은 컬렉션 함수는 결과를 즉시(eagerly) 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.
- 시퀀스(sequence)를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.
  - ~~~kotlin
      people.asSequence()
          .map(Person::name)
          .filter { it.startWith("A") }
          .toList()
    ~~~ 
- 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다.
- asSequence 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스를 바꿀 수 있다. 시퀀스를 리스트로 만들 때는 toList 를 사용한다.
  - 왜 시퀀스를 다시 컬렉션으로 되돌려야 할까?
    - 컬렉션보다 시퀀스가 훨씬 더 낫다면 그냥 시퀀스를 쓰는 편이 낫지 않을까?
    - 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.
    - 시퀀스의 원소를 차례로 이터레이션해야 한다면 시퀀스를 직접 써도 된다.
- **큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라.**
- **자바 스트림과 코틀린 시퀀스 비교**
  - 코틀린에서 자바의 stream 과 같은 개념의 asSequence 를 제공하는 이유는 안드로이드 등에서 예전 버전 자바를 사용하는 경우 자바8에 있는 스트림이 없기 때문이다.
  - 자바8을 채택한다면 stream 을 사용
- generateSequence 함수를 이용해서 시퀀스를 만들수도 있다.

### 5.4 자바 함수형 인터페이스 활용

- 추상 메소드가 단 하나만 있는 인터페이스를 함수형 인터페이스(functional interface) 또는 SAM 인터페이스라고 한다. SAM 은 단일 추상 메소드(single abstract method) 라는 뜻이다.
- **자바와 달리 코틀린에는 제대로 된 함수 타입이 존재한다. 따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는 함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야 한다.**
- SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경
  - SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다.
  - 예를 들어 함수형 인터페이스의 인스턴스를 반환하는 메소드가 있다면 람다를 직접 반환할 수 없고, 반환하고픈 람다를 SAM 생성자로 감싸야 한다.
- 람다와 리스너 등록/해제하기
  - 람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this 가 없다.
  - 따라서 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다 대신 무명 객체를 사용해 리스너를 구현해야 한다.
  - 무명 객체 안에서는 this 가 그 무명 객체 인스턴스 자신을 가리키기 때문에 리스너를 해제하는 API 함수에게 this 를 넘길 수 있다.
- 가끔 오버로드한 메소드 중에서 어떤 타입의 메소드를 선택해 람다를 변환해 넘겨줘야 할지 모호난 때가 있는데, 그런 경우 명시적으로 SAM 생성자를 적용하면 컴파일 오류를 피할 수 있다.

### 5.5 수신 객체 지정 람다: with 와 apply

- 수신 객체 지정 람다(lambda with receiver): 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것
- with 함수
  - 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.
  - 인자로 받은 람다 본문에서는 this 를 사용해 그 수신 객체에 접근할 수 있다.
  - 일반적인 this 와 마찬가지로 this 와 점(.)을 사용하지 않고 프로퍼티나 메소드 이름만 사용해도 수신 객체의 멤버에 접근 할 수 있다.
- apply 함수
  - with 와 같다. 유일한 차이란 apply 는 항상 자신에게 전달된 객체(즉 수신 객체)를 반환한다는 점 뿐이다.
- buildString 함수는 StringBuilder 를 활용해 String 을 만드는 경우 사용 할 수 있는 우아한 해법이다. 

## 6장 코틀린 타입 시스템

### 6.1 널 가능성

- 널 가능성(nullability) 은 NPE 를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
- 널이 될 수 있는 타입
  - 코틀린과 자바의 첫 번째이자 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다.
  - 널을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표(?)를 명시해야 한다.
    - ~~~kotlin
      fun strLenSafe(s: String?) = ...
      ~~~
  - 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
  - 모든 검사는 컴파일 시점에 수행되기 때문에 코틀린에서 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비굥이 들지 않는다.
- 타입이란: 타입은 분류(classification)로 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.
- 안전한 호출 연산자: ?.
  - ?.은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
  - 아래의 두 코드는 같은 기능을 한다. 호출하려는 값이 null 이면 이 호출은 무시되고 null 이 결과 값이 된다.
    - ~~~kotlin
      s?.toUpperCase()
      ~~~
      ~~~kotlin
      if (s != null) s.toUpperCase() else null
      ~~~
- 엘비스 연산자: ?:
  - 엘비스(elvis) 연산자: null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자
  - 이 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.
  - 코틀린에서는 return 이나 throw 등의 연산도 식이기 때문에 엘비스 연산자의 우항에 넣을 수 있다.
    - 그런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다.
    - 함수의 전제 조건을 검사하는 경우 특히 유용하다.
- 안전한 캐스트: as?
  - as? 연산자는 어떤 값을 지정한 타입으로 캐스트 한다. as? 는 값을 대상 타입으로 변환할 수 없으면 null 을 반환한다.
  - **안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.**
- 널 아님 단언: !!
  - 널 아님 단언(not-null assertion)은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서 무딘 도구다.
  - 느낌표를 이중(!!)으로 사용하면 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다.
  - 실제 널에 대해 !!를 적용하면 NPE 가 발생한다.
  - !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.
  - **어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한줄에 함께 쓰는 일을 피하라.**
- let 함수
  - let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.
  - let 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.
  - 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let 을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let 에 전달한다.
  - 이렇게 하면 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에게 전달하게 된다.
- 나중에 초기화할 프로퍼티
  - **lateinit** 변경자를 붙이면 프로퍼티를 나중에 초기화 할 수 있다.
  - **나중에 초기화하는 프로퍼티는 항상 var 여야 한다.**
  - val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다. 따라서 생성자 밖에서 초기화해야 하는 나중에 초기화하는 프로퍼티는 항상 var 여야 한다.
- 널이 될 수 있는 타입 확장
  - 자바에서는 메소드 안의 this 는 그 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다.
  - 코틀린에서는 널이 될수 있는 타입의 확장 함수 안에서는 this 가 널이 될 수 있다는 점이 자바와 다르다.
- 타입 파라미터의 널 가능성
  - 코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
  - 따라서 **타입 파라미터 T 를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T 가 널이 될 수 있는 타입이다.**
  - 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한(upper bound)을 지정해야 한다.
- 널 가능성과 자바
  - 자바의 @Nullable String 은 코틀린 쪽에서 볼 때 String? 와 같고, 자바의 @NotNull String 은 코틀린쪽에서 볼 때 String 과 같다.
- 플랫폼 타입
  - 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
  - 그 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.
  - **코틀린의 파라미터 값 검사는 함수 내부에서 파라미터를 사용하는 시점이 아니라 함수 호출 시점에 이뤄진다.**
  - 플랫폼 타입의 도입 이유
    - 모든 자바 타입을 널이 될 수 있는 타입으로 다루면 결코 널이 될 수 없는 값에 대해서도 불필요한 널 검사가 들어가기 때문이다.

### 6.2 코틀린의 원시 타입

- 원시 타입: Int, Boolean 등
  - 코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.
  - 대부분의 경우(변수, 프로퍼티, 파라미터, 변환 타입 등) 코톨린의 Int 타입은 자바 int 타입으로 컴파일 된다.
  - 이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우뿐이다.
- 널이 될수 있는 원시 타입: Int?, Boolean? 등
  - null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에 코틀린에서는 널이 될 수 있는 워시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다.
- 숫자 변환
  - **코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식이다.**
  - 코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다. 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.
  - 코트에서 동시에 여러 숫자 타입을 사용하려면 예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야 한다.
  - 코틀린의 10진수 외에 숫자 리터럴
    - L 접미사가 붙은 Long 타입 리터럴: 123L
    - 표준 부동소수점 표기법을 사용한 Double 타입 리터럴: 0.12, 2.0, 1.2e10, 1.2e-10
    - f 나 F 접미사가 붙은 Float 타입 리터럴: 123.4f, 1e3F
    - 0x 나 0X 접두사가 붙은 16진 리터럴: 0xCAFEBABE, 0xbcdL
    - 0b 나 0B 접두사가 붙은 2진 리터럴: 0b0000000101
- Any, Any?: 최상위 타입
  - 자바에서 Object 가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상타입이다.
  - 코틀린에서는 Any 가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다.
  - 자바와 마찬가지로 코틀린에서도 원시 타입 값을 Any 타입의 변수에 대입하면 자동으로 값을 객체로 감싼다.
- Unit 타입: 코틀린의 void
  - 코틀린 Unit 타입은 자바 void 와 같은 기능을 한다.
  - 자바와 다르게 코틀린의 Unit 은 모든 기능을 갖는 일반적인 타입이며, void 와 달리 Unit 을 타입 인자로 쓸 수 있다.
  - 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit 을 쓸 때 유용하다.
- Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다
  - Nothing 타입은 아무 값도 포함하지 않는다. 따라서 Nothing 은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

### 6.3 컬렉션과 배열

- 널 가능성과 컬렉션
  - String.toIntOrNull 을 사용하면 파싱에 실패하면 널을 반환한다.
  - 컬렉션.filterNotNull() 을 사용하면 null 값들을 필터 할 수 있다.
- 읽기 전용과 변경 가능한 컬렉션
  - 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스가 분리되어 있다.
  - kotlin.collections.Collection 은 컬렉션 안의 원소에 대해 이터레이션하고, 크기를 얻고 데이터를 읽는 여러 다른 연산을 수행하지만 원소를 추가하거나 제거하는 메소드가 없다.
  - 컬렉션의 데이터를 수정하려면 kotlin.collections.MutableCollection 인터페이스를 사용해야 한다.(위의 Collection 을 확장하면서 워소 추가,삭제 등의 메소드를 더 제공한다.)
- 코틀린의 Array 클래스는 일반 제네릭 클래스처럼 보이지만 자바 배열로 컴파일 된다.
- 원시 타입의 배열은 IntArray 와 같이 각 타입에 대한 특별한 배열로 표현된다.

# 2부 코틀린답게 사용하기

<br>

## 7장 연산자 오버로딩과 기타 관례

- 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기업을 코틀린에서는 관례라고 부른다.

### 7.1 산술 연산자 오버로딩

- 이항 산술 연산 오버로딩
  - 연산자를 오버로딩하는 함수 앞에는 꼭 operator 가 있어야 한다. operator 키워드를 붙임으로써 어떤 함수가 관례를 따르는 함수임을 명확히 할 수 있다.
  - 연산자를 멤버 함수로 만드는 대신 확장 함수로 정의할 수도 있다.
  - **외부 함수의 클래스에 대한 연산자를 정희할 때는 관례를 따르는 이름의 확장 함수로 구현하는 게 일반적인 패턴이다.**
  - 오버로딩 가능한 이항 산술 연산자
    
      |식|함수 이름|
      |:---|:---|
      |a * b|times|
      |a / b|div|
      |a % b|mod(1.1부터 rem)|
      |a + b|plus|
      |a - b|minus|
  - 일반 함수와 마찬가지로 operator 함수도 오버로딩할 수 있다.
- 복합 대입 연산자 오버로딩
  - 반환 타입이 Unit 인 plusAssign 함수를 정의하면 코틀린은 += 연산자에 그 함수를 사용한다.
    - var 를 val 로 바꾸면 plusAssign 적용이 불가능하게 할수도 있다.
  - **plus 와 plusAssign 연산을 동시에 정의하지 말고 클래스를 일관성 있게 설계하는게 가장 좋다.**
  - +와-는 항상 새로운 컬렉션을 반환하며, +=와 -=연산자는 항상 변경 가능한 컬렉션에 적용해 메모리에 있는 객체 상태를 변화시킨다. 
  - 읽기 전용 컬렉션에서 +=와 -=는 변경을 적용한 복사본을 반환한다.

### 7.2 비교 연산자 오버로딩

- === 는 자신의 두 피연산자가 서로 같은 객체를 가리키는지(원시 타입인 경우 두 값이 같은지) 비교한다.
- 순서 연산자: compareTo
  - 비교 연산자(<,>,<=,>=)는 compareTo 호출로 컴파일된다. compareTo 가 반환하는 값은 Int 다. 
  - 코틀린 표준 라이브러리인 compareValuesBy 는 두 객체와 여러 비교 함수를 인자로 받는다.
    - 첫 번째 비교 함수에 두 객체를 넘겨서 두 객체가 같지 않다는 결과가 나오면 그 결과 값을 즉시 반환한다.
    - 두 객체가 같을 경우 두 번째 비교 함수를 통해 두 객체를 비교한다.
    - 이런 식으로 두 객체의 대소를 알려주는 0 이 아닌 값이 처음 나올 때까지 인자로 받은 함수를 차례로 호출해 두 값을 비교하며, 모든 함수가 0 을 반환하면 0 을 반환한다.

### 7.3 컬렉션과 범위에 대해 쓸 수 있는 관례

- 인덱스로 원소에 접근: get 과 set
  - 인덱스를 사용해 원소를 설정하거나 가져오고 싶을 때는 a[b] 라는 식을 사용한다.(이를 인덱스 연산자라고 부른다.)
  - 인덱스 연산자를 사용해 원소를 읽는 연산은 get 연산자 메소드로 변환되고, 원소를 쓰는 연산은 set 연산자 메소드로 변환된다.
  - get 메소드의 파라미터로 Int 가 아닌 타입도 사용할 수 있다.
- in 관례
  - in 연산자는 원소가 컬렉션이나 범위에 속하는지 검사하거나 컬렉션에 있는 원소를 이터레이션할 때 사용한다.
  - in 연산자와 대응하는 함수는 contains 다.
  - 10 .. 20 은 10이상 20이하인 범위가 생긴다.
  - 10 until 20 은 10이상 19이하인 범위가 생기고 20은 범위 안에 포함되지 않는다.
- rangeTo 관례
  - .. 연산자는 rangeTo 함수 호출로 컴파일 된다.
  - 이 연산자는 아무 클래스에나 정의할 수 있지만 어떤 클래스가 Comparable 인터페이스를 구현하면 rangeTo 를 정의할 필요가 없다.
    - 코틀린 표준 라이브러리에는 모든 Comparable 객체에 대해 적용 가능한 rangeTo 함수가 들어있다.
    - rangeTo 연산자는 다른 산술 연산자보다 우선순위가 낮다. 하지만 혼동을 피하기 위해 괄호로 인자를 감싸주면 더 좋다.
    - rangeTo 라이브러리 함수는 ClosedRange 의 인스턴스를 반환한다.
- for 루프를 위한 iterator 관례
  - iterator 메소드를 확장 함수로 정의할 수 있다. 이런 성질로 인해 자바 문자열에 대한 for 루프가 가능하다.
  - 코틀린 표준 라이브러리는 String 의 상위 클래스인 CharSequence 에 대한 iterator 확장 함수를 제공한다.

### 7.4 구조 분해 선언과 component 함수

- 구조 분해를 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화 할 수 있다.
- 구조 분해 선언의 각 변수를 초기화하기 위해 componentN 이라는 함수를 호출한다.
- data 클래스의 주 생성자에 들어있는 프로퍼티에 대해서는 컴파일러가 자동으로 componentN 함수를 만들어 준다.
- 구조 분해 선언은 함수에서 여러 값을 반환할 때 유용하다.
- 함수 본문 내의 선언문뿐 아니라 변수 선인이 들어갈 수 있는 장소라면 어디든 구조 분해 선언을 사용할 수 있다.

### 7.5 프로퍼티 접근자 로직 재활용: 위임 프로퍼티

- 위임 프로퍼티를 사용하면 값을 뒷밤침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현할 수 있다.
- 위임은 객체가 직접 작업을 수행하지 않고 다른 도우미 객체가 그 작업을 처리하게 맡기는 디자인 패턴을 말한다.
  - 이때 작업을 처리하는 도우미 객체를 위임 객체라고 부른다.
- 코틀린 라이브러리를 프로퍼티 위임을 사용해 프로퍼티 초기화를 지연시켜줄 수 있다.
- 위임 프로퍼티 사용: by lazy() 를 사용한 프로퍼티 초기화 지연
  - 지연 초기화는 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우 초기화할 때 흔히 쓰이는 패턴이다.
  - lazy 함수는 코틀린 관례에 맞는 시그니처의 getValue 메소드가 들어있는 객체를 반환한다.
- by 의 오른쪽에 있는 식이 꼭 새 인스턴스를 만들 필요는 없다. 함수 호출, 다른 프로퍼티, 다른 식 등이 by 의 우항에 올 수 있다.


## 8장 고차 함수: 파라미터와 반환 값으로 람다 사용

### 8.1 고차 함수 정의 

- 고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다.
- 함수 타입을 선언할 때는 반환 타입을 만드시 명시해야 하므로 Unit 을 빼먹어서는 안 된다.
- 함수 타입에서 파라미터 이름을 지정할 수도 있다. 파라미터 이름은 타입 검사 시 무시 된다. 
- 함수를 함수에서 반환 
  - 다른 함수를 반환하는 함수를 정의하려면 함수의 반환 타입으로 함수 타입을 지정해야 한다.
  - 함수를 반환하려면 return 식에 람다나 멤버 참조나 함수 타입의 값을 계산하는 식 등을 넣으면 된다.

### 8.2 인라인 함수: 람다의 부가 비용 없애기

- 람다가 변수를 포획하면 람다가 생성되는 시점마다 새로운 무명 클래스 객체가 생긴다.
- inline 변경자를 어떤 함수에 붙이면 컴파일러는그 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해준다.
  - 다른 말로 하면 함수를 호출하는 코드를 함수를 호출하는 바이트코드 대신에 함수 본문을 번역한 바이트 코드로 컴파일한다는 뜻이다.
- 어떤 함수를 inline 으로 선언하면 그 함수의 본문이 인라인된다.
- 한 인라인 함수를 두 곳에서 각각 다른 람다를 사용해 호출한다면 그 두 호출은 각각 따로 인라이닝된다.
  - 인라인 함수의 본문 코드가 호출 지점에 복사되고 각 람다의 본문이 인라인 함수의 본문 코드에서 람다를 사용하는 위치에 복사된다.
- 인라인 함수의 한계
  - 일반적으로 인라인 함수의 본문에서 람다 식을 바로 호출하거나 람다 식을 인자로 전달받아 바로 호출하는 경우에는 그 람다를 인라이닝할 수 있다.
  - 그런 경우가 아니라면 컴파일러는 Illegal usage of inline-parameter 라는 메시지와 함께 인라이닝을 금지시킨다.
  - 인라이닝하면 안 되는 람다를 파라미터로 받는다면 noinline 변경자를 파라미터 이름 앞에 붙여서 인라이닝을 금지할 수 있다.
- 컬렉션 연산 인라이닝
  - 시퀀스는(람다를 저장해야 하므로) 람다를 인라인하지 않는다.
  - 따라서 지연 계산을 통해 성능을 향상시키려는 이유로 모든 컬렉션 연산에 asSequence 를 붙여서는 안 된다.
  - 시퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우뿐이다.
- 자원 관리를 위해 인라인된 람다 사용
  - use 함수는 닫을 수 있는 자원에 대한 확장 함수며, 람다를 인자로 받는다.
  - use 는 람다를 호출한 다음에 자원을 닫아준다.
  - 이때 람다가 정상 종료한 경우는 물론 람다안에서 예외가 발생한 경우에도 자원을 확실히 닫는다.

### 8.3 고차 함수 안에서 흐름 제어

- 람다 안의 return 문: 람다를 둘러싼 함수로부터 반환
  - 람다 안에서 return 을 사용하면 람다로부터만 반환되는 게 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환된다.
  - 그렇게 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 return 문을 넌로컬(non-local) return 이라 부른다.
  - 이렇게 return 이 바깥쪽 함수를 반환시킬 수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우뿐이다.
  - 인라이닝되지 않는 함수에 전달되는 람다안에서 return 을 사용할 수는 없다.
- 람다로부터 반환: 레이블을 사용한 return
  - 람다 식에서도 로컬 return 을 사용할 수 있다. 람다 안에서 로컬 return 은 for 루프의 break 와 비슷한 역할을 한다.
  - 로컬 return 은 람다의 실행을 끝내고 람다를 호출했던 코드의 실행을 계속 이어간다.
  - 로컬 return 과 넌로컬 return 을 구분하기 위해 레이블을 사용해야 한다.
  - return 으로 실행을 끝내고 싶은 람다 식 앞에 레이블을 붙이고, return 키워드 뒤에 그 레이블을 추가하면 된다.
  - 람다에 레이블을 붙여서 사용하는 대신 람다를 인자로 받는 인라인 함수의 이름을 return 뒤에 레이블로 사용해도 된다.
  - 람다식에는 레이블이 2개 이상 붙을 수 없다.
- 무명 함수: 기본적으로 로컬 return
  - 무명 함수는 코드 블록을 함수에 넘길 때 사용할 수 있는 다른 방법이다.
  - 본문 여러 곳에서 return 해야 하는 코드 블록을 만들어야 한다면 람다 대신 무명 함수를 쓸 수 있다.

## 9장 제네릭스

### 9.1 제네릭 타입 파라미터

- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자로 치환해야 한다.
- 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 프로그래머가 명시하거나 컴파일러가 추론할 수 있어야 한다.
- 타입 파라미터 제약
  - 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
  - 제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 적으면 된다.
- 타입 파라미터를 널이 될 수 없는 타입으로 한정
  - 널 가능성을 제외한 아무론 제약도 필요 없다면 Any? 대신 Any 를 상한으로 사용하라.
  - Any 를 사용하지 않고 다른 널이 될 수 없는 타입을 사용해 상한을 정해도 된다.

### 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

- 실체화한 타입 파라미터를 사용한 함수 선언
  - 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.
  - 표준 라이브러리 함수인 filterIsInstance 는 인자로 받은 컬렉션의 원소 중에서 타입 인자로 지정한 클래스의 인스턴스만을 모아서 만든 리스트를 반환한다.
  - reified 키워드는 이 타입 파라미터가 실행 시점에 지워지지 않음을 표시한다.
  - 자바 코드에서는 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없다.
  - **성능을 좋게 하려면 인라인 함수의 크기를 계속 관찰해야 한다. 함수가 커지면 실체화한 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 편이 낫다.**
- 실체화한 타입 파라미터의 제약
  - 실체화한 타입 파라미터를 사용할 수 있는 경우
    - 타입 검사와 캐스팅(is, !is, as, as?)
    - 코틀린 리플렉션 API(::class)
    - 코틀린 타입에 대응하는 java.lang.Class 를 얻기(::class.java)
    - 다른 함수를 호출할 때 타입 인자로 사용
  - 사용할 수 없는 경우
    - 타입 파라미터 클래스의 인스턴스 생성하기
    - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
    - 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
    - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified 로 지정하기

### 9.3 변성: 제네릭과 하위 타입

- 변성(variance) 개념은 List<String> 와 List<Any> 와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.
- 변성이 있는 이유: 인자를 함수에 넘기기
  - 함수가 읽기 전용 리스트를 받는다면 더 구체적인 타입의 원소를 갖는 리스트를 그 함수에 넘길 수 있다.
  - 하지만 리스트가 변경 가능하다면 그럴 수 없다.
- 클래스, 타입, 하위 타입
  - 어떤 타입 A 의 값이 필요한 모든 장소에 어떤 타입 B 의 값을 넣어도 아무 문제가 없다면 타입 B 는 타입 A 의 하위 타입이다.
  - 상위 타입은 하위 타입의 반대다. A 타입이 B 타입의 하위 타입이라면  B 는 A 의 상위 타입이다.
  - 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용한다.
  - 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다.
  - 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 무공변(invariant)이라고 말한다.
- 공변성: 하위 타입 관계를 유지
  - A 가 B 의 하위 타입이면 List<A>는 List<B>의 하위 타입이다. 그런 클래스나 인터페이스를 공변적(covariant)이라 말한다.
  - 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out 을 넣어야 한다.
  - 클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 모두 인(in)과 아웃 위치로 나뉜다.
    - T 가 함수의 반환 타입에 쓰인다면 T 는 아웃 위치에 있다. 그 함수는 T 타입의 값을 생산한다.
    - T 가 함수의 파라미터로 타입에 쓰인다면 T 는 인 위치에 있다. 그런 함수는 T 타입의 값을 소비한다.
    - **클래스 타입 파라미터 T 앞에 out 키워드를 붙이면 클래스 안에서 T 를 사용하는 메소드가 아웃 위치에서만 T 를 사용하게 허용하고 인 위치에서는 T 를 사용하지 못하게 막는다.**
    - out 키워드는 T 의 사용법을 제한하며 T 로 인해 생기는 하위 타입 관계의 타입 안전성을 보장한다.
    - 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현에는 적용되지 않는다.
- 반공변성: 뒤집힌 하위 타입 관계
  - 반공변 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.