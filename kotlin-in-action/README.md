# Kotlin in Action
- *드미트리 제메로프, 스베트라나 이사코바 저/오현석 역 | 에이콘출판사*

<br>

# 1부 코틀린 소개

<br>

## 1장 코틀린이란 무엇이며, 왜 필요한가?

- 코틀린도 자바와 마찬가지로 정적 타입 지정 언어다. 정적 타입 지정이라는 말은 모든 프로그램 구성 요소의 타입을 
컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 검증해준다는 뜻이다.
- 정적 타입 지정의 장점
  - 성능: 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다.
  - 신뢰성: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
  - 유지 보수성: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 함수형 프로그래밍의 핵심 개념
  - 일급 시민인(first class) 함수: 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
  - 불면성(immutability): 일단 한번 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다. 
  - 부수 효과(side effect) 없음: 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.
- 코틀린은 객체지향과 함수형 프로그래밍 스타일을 모두 지원한다. 코틀인에서는 일급 시민 함수를 사용해 수준 높은 추상화가 가능하고,
불변 값 지원을 통해 다중 스레드 애플리케이션 개발과 테스트를 더 쉽게 할 수 있다.
- 코틀린의 철학
  - 실용성: 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존하면서 실용성을 높였다.
  - 간결성: getter, setter, 생성자 파라미터를 필드에 대입하기 위한 로직 등 여러 가지 번거로운 준비 코드를 묵시적으로 제공하기 때문에 더 간결하다.
  - 안전성: JVM 에서 실행하면서 이미 상당한 안전성을 보장하고, 코틀린의 타입 시스템은 null 이 될 수 없는 값을 추적하며, 실행 시점에 NPE 이 발생할 수 있는 연산을 사용하는 코드를 금지한다.
  - 상호운용성: 다른 일부 JVM 언어와 달리 코틀린은 상호운옹성 측면에서 훨씬 더 많은 것을 제공한다.

## 2장 코틀린 기초

### 2.1 기본 요소: 함수와 변수

- 코틀린 기본 문법
  - 함수를 선언할 때 fun 키워드를 사용한다.
  - 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다. 변수를 선언할 때도 마찬가지 방식으로 타입을 지정한다. 
  - 함수를 최상위 수준에 정의할 수 있다. 자바와 달리 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
  - 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다. 
  - 코틀인 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다. println 도 그런 함수중 하나다.
  - 줄 끝에 세미콜론을 붙이지 않아도 된다.
- 문(statement) 과 식(expression)의 구분
  - **코틀린에서 if 는 식이지 문이 아니다.** 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 할 수 있는 반면
문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.
  - 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다. 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.
  - 코틀린의 if (a > b) a else b 는 자바의 a > b ? a : b 처럼 작동한다.
  - 코틀린에서는 if 가 값을 만들어 내기 때문에 자바와 달리 3항 연산자가 따로 없다.
- 본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.
- 변수
  - 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.
    - ~~~kotlin
      val question = "삶, 우주에 대한 질문"
      val answer: Int = 42
      ~~~
  - 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
  - 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 따라서 그런 경우 타입을 반드시 지정해야 한다.
  - **변경 가능한 변수와 변경 불가능한 변수**
    - val(값을 뜻하는 value 에서 따옴): 변경 불가능한(immutable) 참조를 지정하는 변수다. 자바로 말하면 final 변수 
    - var(변수를 뜻하는 variable 에서 따옴): 변경 가능한(mutable) 참조다. 자바의 일반 변수
    - **기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var 로 변경하라.**
  - 문자열 템플릿
    - 컴파일러는 각 식을 정적으로 (컴파일 시점에) 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.
    - '$' 문자를 문자열에 넣고 싶으면 println("\$x") 와 같이 \ 를 사용해 $ 를 이스케이프(escape) 시켜야 한다.  

### 2.2 클래스와 프로퍼티

- 코드가 없이 데이터만 저장하는 클래스를 **값 객체**(value object)라 부르며, 다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.
- 코틀린의 기본 가시성은 public 이므로 이런 경우 변경자를 생략해도 된다.
- **클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.**
- 자바에서는 필드와 접근자를 한데 묶어 **프로퍼티**(property)라고 부르며, 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.
- **자바로 변환시 읽기 전용 프로퍼티(val)의 경우 게터만 만들어내고, 쓸 수 있는 프로퍼티(var)의 경우는 게터, 세터를 만들어낸다.**
  - intellij 에서 코틀린 파일을 자바로 확인하는 방법
    - Tools - Kotlin - Show Kotlin ByteCode - Decompile 선택
- 자바로 변환시 게터와 세터의 이름을 정하는 규칙의 예외
  - 이름이 is 로 시작하는 프로퍼티의 게터에는 get 이 붙지 않고 원래 이름 그대로 사용하며, 세터에는 is 를 set 으로 바꾼 이름을 사용한다.
- 디렉터리와 패키지
  - 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다.
    - **자바와 코틀린은 할께 사용하는 경우를 고려해서 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다.**
  - 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.
  - 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다.

### 2.3 enum 과 when

- when
  - if 와 마찬가지로 when 도 값을 만들어내는 식이다. 따라서 식이 본문인 함수에 when 을 바로 사용 할 수 있다.
  - 자바와 달리 각 분기의 끝에 break 를 넣지 않아도 된다.
  - 한 분기 안에서 여러 값을 매치 패턴으로 사용 할 수 있고, 그럴 경우 값 사이를 콤마(,)로 분리한다.
  - 자바에서 처럼 상수 값을 임포트해서 사용 할 수 있다.
  - 분기 조건에 상수만을 사용할 수 있는 자바 switch 와 달리 코틀린 when 의 분기 조건은 임의의 객체를 허용한다.
  - 인자가 없는 when 식을 사용하면 불필요한 객체 생성을 막을 수 있다. 하지만 코드는 약간 읽기 어려워진다. 성능 향상과 가독성의 필요성에 따라 적절하게 사용하자.
  - **when 에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.**
- 스마트 캐스트: 타입 검사와 타입 캐스트를 조합
  - 코틀린에서는 is 를 사용해 어떤 변수가 원하는 타입인지 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅 하지 않아도 사용 할 수 있다. 
  - 실제로는 컴파일러가 캐스팅을 수행해주는데 이를 **스마트 캐스트**라고 부른다.
- *블록의 마지막 식이 블록의 결과*라는 규칙은 함수에 대해서는 성립하지 않는다. 식이 본문인 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return 문이 반드시 있어야 한다.

### 2.4 while 과 for 루프

- 코틀린에는 자바의 for 루프에 해당하는 요소가 없다. 가장 흔한 용례인 초깃값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 코틀린에서는 범위(range)를 사용한다.
- 범위는 기본적으로 두 값으로 이루어진 구간이다. .. 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다. 
  - ~~~kotlin
    val oneToTen = 1..10
    ~~~
- 코틀린의 범위는 양끝을 포함하는 구간으로(위예에서는 10)이 항상 범위에 포함된다는 뜻이다.
- step 을 사용해서 증가 값을 사용 할 수 있다.
- downTo 를 이용해 역방향으로 순회할 수 있다.
- .. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다.('A'..'F')
- 리스트 순회시 list.withIndex() 를 사용해 인덱스를 쓸 수 있다.
- !in 을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.
  
### 2.5 코틀린의 예외 처리

- 자바와 달리 코틀린의 throw 는 식이므로 다른 식에 포함될 수 있다.
- **자바 코드와 가장 큰 차이는 throws 절이 코드에 없다는 점이다.**
- 코틀린에서는 체크 예외와 언체크 예외(unchecked)를 구별하지 않는다.
- 코틀린의 try 키워드는 if 나 when 과 마찬가지로 식이다. 따라서 try 의 값을 변수에 대입할 수 있다.

## 3장 함수 정의와 호출

### 3.1 코틀린에서 컬렉션 만들기

- 컬렉션 만들기: setOf(), hashSetOf(), arrayListOf(), hashMapOf()
- 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스다.

### 3.2 함수를 호출하기 쉽게 만들기

- 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있다.
- @JvmOverloads 를 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메소드를 추가해준다. 
- 코틀린에서는 자바의 유틸클래스와 같은 무의미한 클래스가 필요 없다. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다.
- 코틀린 컴파일러는 코틀린 소스 파일의 이름과 대응하는 클래스를 생성한다.
  - 코틀린 최상위 함수가 포함되는 클래스의 이름을 바꾸고 싶다면 파일에 @file:JvmName("생성될 클래스명") 애노테이션을 파일의 맨 앞, 패키지 이름 선언 이전에 위치하면 된다.
- 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.
- const 변경자를 추가하면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다.(단, 원시 타입과 String 타입의 프로퍼티만 const 로 지정할 수 있다.)
  - ~~~kotlin
    const val UNIX_LINE_SEPARATOR = "\n"
    ~~~
    
### 3.3 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

- 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다.
- 확장 함수 만들기
  - 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙인다. 
  - 클래스의 이름을 **수신 객테 타입**(receiver type)이라 부르며, 확장 함수가 호출되는 대상이 되는 값(객체)을 **수신 객체**(receiver object)라고 부른다.
  - 아래에서 String 이 수신객테 타입, this 는 수신 객체
  - 일반 메소드의 본문에서 this 를 사용할 때와 마찬가지로 확장 함수 본문에도 this 를 쓸수도 있고 생략 할 수도 있다.
    - ~~~kotlin
      fun String.lastChar(): char = this.get(this.length - 1)
      ~~~
      ~~~kotlin
      println("Kotlin".lastChar())
      ~~~
- **확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 비공개 멤버나 보호된 멤버를 사용할 수 없다.**
- **내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. 그래서 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점 부가 비용이 들지 않는다.**
  - 자바에서 사용한다고 하면 정적 메소드를 호출하면서 첫 번째 인자로 수신 객체를 넘기기만 하면 된다. 만약 확장 함수를 StringUtil.kt 파일에 정의했다면 다음과 같이 호출 할 수 있다.
    - ~~~ java
      char c = StringUtilKt.lastChar("Java");
      ~~~
- 확장 함수가 정적 메소드와 같은 특징을 가지므로, 확장 함수를 하위 클래스에서 오버라이드 할 수는 없다.
- **확장 함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정되지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다.**
- **어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다.(멤버 함수의 우선순위가 더 높다.)**
- 확장 프로퍼티 
  - **뒷받침하는 필드**(73페이지 참조)가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의를 해야 한다.

### 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

- vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다.(자바에서 타입 뒤에 ... 를 붙이는 것처럼)
  - 가변 일자를 전달할때는 배열 앞에 *를 붙이기만 하면된다.(기술적으로 스프레드 연산자가 배열의 내용을 펼쳐준다.)
- 중위(infix)함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다.
  - 종위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다(이때 객체, 메소드 이름, 유일한 인자 사이에는 공백이 들어가야 한다.). 다음 두 호출은 동일하다.
    - ~~~kotlin
      1.to("one")
      1 to "one"
      ~~~
- 구조 분해 선언(destructuring declaration)을 사용하면 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다.

### 3.5 문자열과 정규식 다루기

- 자바 split 메소드로는 점(.)을 사용해 문자열을 분리 할 수 없다. split 의 구분 문자열은 실제로는 정규식이기 때문이다. 따라서 마침표는 모든 문자를 나타내는 정규식으로 해석된다.
- 코틀린에서는 toRegex 확장 함수를 사용해 문자열을 정규식으로 변환할 수 있다.
  - ~~~kotlin
    println("12.345-6.A".split("\\.|-".toRegex()))
    ~~~
- 3중 따옴표 문자열에서는 역슬래시(\\)를 포함한 어떤 문자도 이스케이프 할 필요가 없다.

### 3.6 코드 다듬기: 로컬 함수와 확장

- 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 그렇게 하면 문법적인 부가 비용을 들이지 않고도 갈끔하게 코드를 조직할 수 있다.
- 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용 할 수 있다.
- 중첩된 함수의 깊이가 깊어지면 코드를 읽기가 어렵기 때문에, 일반적으로 한 단계만 함수를 중첩시키는게 좋다.

## 4장 클래스, 객체, 인터페이스

### 4.1 클래스 계층 정의 

- 자바와 달리 코틀린 선언은 기본적으로 final 이며 public 이다. 
- 중첩 클래스는 기본적으로 내부 클래스가 아니다. 즉, 코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.
- 코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.
  - 자바와 마찬가지로 인터페이스는 제한 없이 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다.
- 코틀린에서 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 **오버라이드 하려면 *override* 변경자를 꼭 사용해야 한다.**
- 상위 타입의 이름을 꺽쇠 괄호(<>) 사이에 넣어서 "super"를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.
- 어떤 클래스의 상속을 허용하려면 클래스 앞에 *open* 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 open 변경자를 붙여야 한다.
- 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오보라이드하는 메소드 앞에 final 을 명시해야 한다.
- 인터페이스 멤버의 경우 final, open, abstract 를 사용하지 않는다. 인터페이스 멤버는 항상 열려 있으며 final 로 변경할 수 없다.
- 자바의 기본 가시성인 패키지 전용은 코틀린에 없고, 코틀린의 기본 가시성은 public 이다.
  - 패키지 전용 가시성에 대한 대안으로 코틀린에는 internal 이라는 새로운 가시성 변경자를 도입했다.
  - internal 은 모듈 내부에서만 볼 수 있음을 뜻한다.
  - 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.
- 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다. protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.
- 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다.
- **코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.**
  - 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 한다.
  - 내부 클래스 Inner 안에서 바깥쪽 클래스 Outer 의 참조에 접근 하려면 this@Outer 라고 써야 한다.
- 클래스 계층 정의 시 계층 확장 제한
  - 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.
  - sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스안에 중첩시켜야 한다.
  - when 식에서 sealed 클래스의 모든 하위 클래스를 처리 한다면 디폴트 분기(else 분기)가 필요 없다.
  - sealed 로 표시된 클래스는 자동으로 open 이기 때문에 별도로 open 변경자를 붙일 필요가 없다.

### 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

- 클래스 초기화: 주 생성자와 초기화 블록
  - 코틀린은 주 생성자와 부 생성자를 구분한다. 또한 코틀린에서는 초기화 블록을 통해 초기화 로직을 추가할 수 있다.
  - 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 **주 생성자**(primary constructor)라고 부른다.
  - **클래스 정의에 있는 상위 클래스 및 인터페이스 목록에서 이름 뒤에 괄호가 붙었는지 살펴보면 쉽게 기반 클래스와 인터페이스를 구별할 수 있다.**
- 부 생성자: 상위 클래스를 다른 방식으로 초기화
  - **인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말라. 대신 파라미터의 디폴트 값을 생성자 시그니처에 직접 명시하라.**
- 인터페이스에 선언된 프로퍼티 구현
  - 코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다.
  - 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수도 있다.
- 게터와 세터에서 뒷밤침하는 필드에 접근
  - 접근자의 본문에서는 *field*라는 특별한 식별자를 통해 뒷받침하는 필드에 접근할 수 있다. 게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 쓸 수 있다.
- 접근자의 가시성 변경
  - 접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 하지만 원한다면 get 이나 set 앞에 가시성 변경자를 추가해서 접근자의 가시성을 변경할 수 있다.

### 4.3 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임

- **코틀린에서 == 연산자는 참조 동일성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals 를 호출하는 식으로 컴파일된다.**
- "Any" 는 java.lan.Object 에 대응하는 클래스로, 코틀린의 모든 클래스의 최상위 클래스다.
- 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성
  - data 라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다.(toString, equals, hashCode 등등)
  - 데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 copy() 라는 편의 메소드를 제공한다. 
- 클래스 위임: by 키워드 사용
  - 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.
  - 메소드 중 일부의 동작을 변경하고 싶은 경우 메소드를 오버라이드하면 컴파일러가 생성한 메소드 대신 오버라이드한 메소드가 쓰인다.
  - 기존 클래스의 메소드에 위임하는 기본 구현으로 충분한 메소드는 따로 오버라이드할 필요가 없다.

### 4.4 object 키워드: 클래스 선언과 인스턴스 생성

- 객체 선언: 싱글턴을 쉽게 만들기
  - 코틀린은 객체 선언 기능을 통해 싱글턴을 언어에서 기본 지원한다.
  - 객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.
  - 객체 선언은 object 키워드로 시작하고, 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다.
  - 클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어 갈 수 있지만 생성자는 객체 선언에 쓸 수 없다.
- 동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소
  - 동반 객체는 클래스 안에 정의된 일반 객체다. 
  - 클래스 안에 정의된 객체 중 하나에 *companion*이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다.
  - 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다. 이때 객체의 이름을 따로 지정할 필요가 없다.
  - 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 동반 객체의 바깥쪽 클래스의 private 생성자도 호출할 수 있다.
  - 클래스를 확장해야만 하는 경우에는 동반 객체 멤버를 하위 클래스에서 오버라이드할 수 없으므로 여러 생성자를 사용하는 편이 더 나은 해법이다.
- 동반 객체를 일반 객체처럼 사용
  - 클래스의 이름을 통해 동반 객체에 속한 멤버를 참조할 수도 있고, companion object Loader 같은 방식으로 동반 객체에도 이름을 붙일 수 있다.
  - 동반 객체도 인터페이스를 구현할 수 있다.
- 객체 식: 무명 내부 클래스를 다른 방식으로 작성
  - 무명 객체(anonymous object)를 정의할 때도 object 키워드를 쓴다. 무명 객체는 자바의 무명 내부 클래스를 대신한다.
  - 한 인터페이스만 구현하거나 한 클래스만 확장할 수 있는 자바의 무명 내부 클래스와 달리 코틀린 무명 클래스는 여러 인터페이스를 구현하거나 클래스를 확장하면서 인터페이스를 구현할 수 있다.
  - **객체 선언과 달리 무명 객체는 싱글턴이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.**
  - 객체 식은 무명 객체 안에서 여러 메소드를 오버라이드해야 하는 경우에 훨씬 더 유용하다. 메소드가 하나뿐인 인터페이스를 구현해야 한다면 코틀린의 SAM(Single Abstract Method) 변환 지원을 활용하는 편이 낫다.

## 5장 람다로 프로그래밍

### 5.1 람다 식과 멤버 참조

- 람다 식(lambda expression) 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.
- 코틀린에서는 모든 컬렉션에 대해 maxBy 함수를 호출할 수 있다. maxBy 는 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수를 인자로 받는다.
- 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run 을 사용한다. run 은 인자로 받은 람다를 실행해주는 라이브러리 함수다.
- 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it 을 바로 쓸 수 있다.
  - 람다 파라미터로 이름을 따로 지정하지 않은 경우에만 it 이라는 이름이 자동으로 만들어진다.
  - 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 낫다. 파라미터를 명시하지 않으면 각각의 it 이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기 어려울 수 있다.
  - ~~~kotlin
    people.maxBy { it.age }
    ~~~
- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않기 때문에 파라미터 타입을 명시해야 한다.
- 자바와 다르게 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다. 또한 람다 안에서 바깥의 변수를 변경해도 된다.
- **람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다.**

### 5.2 필수적인 함수: filter 와 map

- filter 함수는 컬렉션에서 원치 않는 원소를 제거한다. 하지만 filter 는 원소를 변환 할 수는 없다. 원소를 변환하려면 map 함수를 사용해야 한다.
- map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.
- **꼭 필요하지 않은 경우 굳이 계산을반복하지 말라!**
- find 함수는 조건을 만족하는 첫 번째 원소를 반환한다.
  - 만족하는 원소가 전혀 없는 경우 null 을 반환한다.
  - find 는 firstOrNull 과 같고, 조건을 만족하는 원소가 없으면 null 이 나온다는 사실을 더 명확히 하고 싶다면 firstOrNull 을 쓸 수 있다.
- all 함수는 모든 원소가 술어를 만족하는지 확인할 때 사용한다.
- any 함수는 술어를 만족하는 원소가 하나라도 있는지 확인할 때 사용한다.
- 어떤 조건에 대해 !all 을 수행한 결과와 그 조건의 부정에 대해 any 를 수행한 결과는 같다. 
  - 어떤 조건에 대해 !any 를 수행한 결과와 그 조건의 부정에 대해 all 을 수행한 결과도 같다. 
  - **가독성을 높이려면 any 와 all 앞에 !를 붙이지 않는 편이 낫다.**
- count 함수는 술어를 만족하는 원소의 개수를 구할 때 사용한다.
  - 아래처럼 처리하면 조건을 만족한는 모든 원소가 들어가는 중간 컬렉션이 생긴다. 
  - 반면 count 는 조건을 만족하는 원소의 개수만을 추적하지 조건을 만족하는 원소를 따로 저장하지 않는다.
  - 따라서 count 가 훨씬 더 효율적이다
    - ~~~kotlin
      println(people.filter(canBeInClub27).size)
      ~~~
- groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경
  - 이 연산의 결과는 컬렉션의 원소를 구분하는 특성이 키이고, 키 값에 따른 각 그룹이 값인 맵이다.
- flatMap 과 flatten: 중첩된 컬렉션 안의 원소 처리
  - 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.
  - 중첩된 리스트의 원소를 한 리스트로 모아야 한다면 flatMap 을, 특별히 변환해야 할 내용이 없이 리스트의 리스트를 평평하게 펼치기만 하면 된다면 flatten() 함수를 사용할 수 있다.

### 5.3 지연 계산(lazy) 컬렉션 연산

- map 이나 filter 같은 컬렉션 함수는 결과를 즉시(eagerly) 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.
- 시퀀스(sequence)를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.
  - ~~~kotlin
      people.asSequence()
          .map(Person::name)
          .filter { it.startWith("A") }
          .toList()
    ~~~ 
- 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다.
- asSequence 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스를 바꿀 수 있다. 시퀀스를 리스트로 만들 때는 toList 를 사용한다.
  - 왜 시퀀스를 다시 컬렉션으로 되돌려야 할까?
    - 컬렉션보다 시퀀스가 훨씬 더 낫다면 그냥 시퀀스를 쓰는 편이 낫지 않을까?
    - 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.
    - 시퀀스의 원소를 차례로 이터레이션해야 한다면 시퀀스를 직접 써도 된다.
- **큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라.**
- **자바 스트림과 코틀린 시퀀스 비교**
  - 코틀린에서 자바의 stream 과 같은 개념의 asSequence 를 제공하는 이유는 안드로이드 등에서 예전 버전 자바를 사용하는 경우 자바8에 있는 스트림이 없기 때문이다.
  - 자바8을 채택한다면 stream 을 사용
- generateSequence 함수를 이용해서 시퀀스를 만들수도 있다.

### 5.4 자바 함수형 인터페이스 활용

- 추상 메소드가 단 하나만 있는 인터페이스를 함수형 인터페이스(functional interface) 또는 SAM 인터페이스라고 한다. SAM 은 단일 추상 메소드(single abstract method) 라는 뜻이다.
- **자바와 달리 코틀린에는 제대로 된 함수 타입이 존재한다. 따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는 함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야 한다.**
- SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경
  - SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다.
  - 예를 들어 함수형 인터페이스의 인스턴스를 반환하는 메소드가 있다면 람다를 직접 반환할 수 없고, 반환하고픈 람다를 SAM 생성자로 감싸야 한다.
- 람다와 리스너 등록/해제하기
  - 람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this 가 없다.
  - 따라서 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다 대신 무명 객체를 사용해 리스너를 구현해야 한다.
  - 무명 객체 안에서는 this 가 그 무명 객체 인스턴스 자신을 가리키기 때문에 리스너를 해제하는 API 함수에게 this 를 넘길 수 있다.
- 가끔 오버로드한 메소드 중에서 어떤 타입의 메소드를 선택해 람다를 변환해 넘겨줘야 할지 모호난 때가 있는데, 그런 경우 명시적으로 SAM 생성자를 적용하면 컴파일 오류를 피할 수 있다.

### 5.5 수신 객체 지정 람다: with 와 apply

- 수신 객체 지정 람다(lambda with receiver): 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것
- with 함수
  - 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.
  - 인자로 받은 람다 본문에서는 this 를 사용해 그 수신 객체에 접근할 수 있다.
  - 일반적인 this 와 마찬가지로 this 와 점(.)을 사용하지 않고 프로퍼티나 메소드 이름만 사용해도 수신 객체의 멤버에 접근 할 수 있다.
- apply 함수
  - with 와 같다. 유일한 차이란 apply 는 항상 자신에게 전달된 객체(즉 수신 객체)를 반환한다는 점 뿐이다.
- buildString 함수는 StringBuilder 를 활용해 String 을 만드는 경우 사용 할 수 있는 우아한 해법이다. 

## 6장 코틀린 타입 시스템

### 6.1 널 가능성

- 널 가능성(nullability) 은 NPE 를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.
- 널이 될 수 있는 타입
  - 코틀린과 자바의 첫 번째이자 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다.
  - 널을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표(?)를 명시해야 한다.
    - ~~~kotlin
      fun strLenSafe(s: String?) = ...
      ~~~
  - 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
  - 모든 검사는 컴파일 시점에 수행되기 때문에 코틀린에서 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비굥이 들지 않는다.
- 타입이란: 타입은 분류(classification)로 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.
- 안전한 호출 연산자: ?.
  - ?.은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
  - 아래의 두 코드는 같은 기능을 한다. 호출하려는 값이 null 이면 이 호출은 무시되고 null 이 결과 값이 된다.
    - ~~~kotlin
      s?.toUpperCase()
      ~~~
      ~~~kotlin
      if (s != null) s.toUpperCase() else null
      ~~~
- 엘비스 연산자: ?:
  - 엘비스(elvis) 연산자: null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자
  - 이 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.