# 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴
- *최범균 저 | 인투북스*

### Chapter 01 들어가기
- 객체 지향 기법을 적용하면 소프트웨어를 더 쉽게 변경할 수 있는 유연함(flexibility)을 얻을 수 있게 되고 이는 곧 요구 사항의 변화를 더 빠르게 수용할 수 있다는 것을 뜻한다.

### Chapter 02 객체 지향
- 다수의 프로시저들이 데이터를 공유하는 방식으로 만들어지기 때문에, 절차 지향 프로그램은 자연스럽게 데이터를 중심으루 구현하게 된다.
- 한 데이터를 사용하는 프로시저가 많아질수록 그 데이터의 타입을 변경하기 어려워진다.
- 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이다.
- **객체는 객체가 제공하는 기능으로 정의되는데, 이는 다시 말하면 객체마다 자신만의 책임(responsibility)이 있다는 의미를 갖는다.** 
- 객체가 갖는 책임의 크기는 작을수록 좋다. 객체가 갖는 책임이 작다는 것은 객체가 제공하는 기능의 개수가 적다는 걸 의미한다.
- 객체가 갖는 책임의 크기는 작아질수록 객체 지향의 장점인 변경의 유연함을 얻을 수 있게 된다.
- 객체가 책임을 갖는다는 것은 객체가 역할(role)을 수행한다는 의미를 갖는다. 
- **캡슐화**(encapsulation)는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다. 이를 통해 내부의 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 
영향을 받지 않도록 만들어 준다. 즉, 내부 구현 변경의 유연함을 주는 기법이 바로 캡슐화이다.
- 캡슐화를 위한 두 개의 규칙
    - Tell, Don`t Ask
        - **데이터를 물어보지 않고, 기능을 실행해 달라고 말하라!**
    - 데미테르의 법칙(Law Of Demeter)
        - 메서드에서 생성한 객체의 메서드만 호출
        - 파라미터로 받은 객체의 메서드만 호출
        - 필드로 참조하는 객체의 메서드만 호출
- 객체 지향 설계 과정
    - 1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다.
        - 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다.
        - 기능은 최대한 캡슐화해서 구현한다.
    - 2. 객체 간에 어떻게 메시지를 주고받을 지 결정한다.
    - 3. 과정 1과 과정 2를 개발하는 동안 지속적으로 반복한다.
- **객체 설계는 한 번에 완성되지 않고 구현을 진행해 나가면서 점진적으로 완성된다. 이는 최초에 만든 설계가 완벽하지 않으며, 개발이 진행되면서 설계도 함께 변경된다는 것을 의미한다.
따라서 설계를 할 때에는 변경되는 부분을 고려한 유연한 구조를 갖도록 노력해야 한다.**

### Chapter 03 다형성과 추상 타입
- 추상화는 공통된 개념을 도출해서 추상 타입을 정의해 주기도 하지만, 또한, 많은 책임을 가진 객체로부터 책임을 분리하는 촉매제가 되기도 한다.
- **하위 수준의 상세 구현보다는 변하지 않는 상위 수준의 로직을 재사용할 수 있도록 설계하는 것이 더 중요하다.**
- 인터페이스에 대고 프로그래밍하기(program to interface)
    - 실제 구현을 제공하는 콘크리트 클래스를 사용해서 프로그래밍하지 말고, 기능을 정의한 인터페이스를 사용해서 프로그래밍하라는 뜻이다.
    - 인터페이스는 최초 설계에서 바로 도출되기 보다는, 요구 사항의 변화와 함께 점진적으로 도출이 된다. 즉, 인터페이스는 새롭게 발견된 추상 개념을 통해서 도출 되는 것이다. 
    - 인터페이스를 사용해야 할 때는 변화 가능성이 높은 경우에 한해서 사용해야 한다.

### Chapter 04 재사용: 상속보단 조립
- 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 잘못된 사용으로 인한 문제가 발생하게 된다.
- **한 객체가 다른 객체를 조립해서 필드로 갖는다는 것은 다른 객체의 기능을 사용한다는 의미를 내포한다.**
- 조립 상식은 런타임에 조립 대상 객체를 교체할 수 있다. 상속의 경우 소스 코드를 작성할 때 관계가 형성되기 때문에 런타임에 상위 클래스를 교체할 수 없다.
- 상속은 명확한 IS-A 관계에서 점진적으로 상위 클래스의 기능을 확장해 나갈 때 사용할 수 있다. 단, 최초에는 명확한 IS-A 관계로 보여서 상속을 이용해서 기능을 확장했다고
하더라도, 이후에 클래스의 개수가 불필요하게 증가하는 문제가 발생하거나 상위 클래스의 변경이 어려워지는 등 상위 클래스를 상속받을 때의 단점이 발생한다면, 조립으로 전환하는 것을 고려해야 한다.
  
### Chapter 05 설계 원칙: SOLID
- 단일 책임 원칙(Single responsibility principle: SRP)
    - **클래스는 단 한개의 책임을 가져야 한다.**
    - 클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에, 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 한다.
- 개방 폐쇄 원칙(Open-close principle: OCP)    
    - **확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**
    - 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
    - instanceof 와 같은 타입 확인 연산자가 사용된다면 해당 코드는 개방 폐쇄 원칙을 지키지 않을 가능성이 높다.
- 리스코프 치환 원칙(Liskov substitution principle: LSP)
    - **상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.**
- 인터페이스 분리 원칙(Interface segregation principle: ISP)
    - **인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.**
- 의존 역전 원칙(Dependency inversion principle: DIP)
    - **고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.**
    - 고수준 모듈은 어떤 의미 있는 단일 기능을 제공하는 모듈이라고 정의할 수 있으며, 저수준 모듈은 고수준 모듈의 기능을 구현하기 위해
    필요한 하위 기능의 실제 구현으로 정의할 수 있다.
    - 고수준 모듈은 상대적으로 큰 틀(즉, 상위 수준)에서 프로그램을 다룬다면, 저수준 모듈은 각 개별 요소(즉, 상세)가 어떻게 구현될지에 대해서 다룬다.
    - **의존 역전 원칙은 런타임의 의존이 아닌 소스 코드의 의존을 역전시킴으로써 변경의 유연함을 확보할 수 있도록 만들어 주는 원칙이지,
    런타임에서의 의존을 역전시키는 것은 아니다.**
- SOLID 정리
    - 단일 책임 원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아준다.
    - 리스코프 치환 원칙과 의존 역전 원칙은 개방 폐쇄 원칙을 지원한다. 
    - 개방 폐쇄 원칙은 변화되는 부분을 추상화 하고 다형성을 이용함으로써 기능 확장을 하면서도 기존 코드를 수정하지 않도록 만들어 준다. 여기서, 변화되는 부분을
    추상화할 수 있도록 도와주는 원칙이 바로 의존 역전 원칙이고, 다형성을 도와주는 원칙이 리스코프 치환 원칙이다.
      
### Chapter 06 DI 와 서비스 로케이터
- 순환 의존이 발생할 경우 한 패키지의 변경이 다른 패키지에 영향을 줄 가능성이 높아지기 때문에, 순환 의존은 발생시키지 않는 것이 향후 유지 보수에 유리하다.
- DI(Dependency Inject:의존 주입) 는 필요한 객체를 직접 생성하거나 찾지 않고 외부에서 넣어 주는 방식이다.
- 생성자 주입 방식은 생성자를 통해서 필요한 의존 객체를 전달받기 때문에, 객체를 생성하는 시점에서 의존 객체가 정상인지 확인할 수 있다. 
- 설정 메서드 주입 방식은 의존 객체를 설정하지 못한 상태에서 객체를 사용할 수 있게 되므로, 객체의 메서드를 실행하는 과정에서 NullPointerException 이 발생할 수 있다.

### Chapter 07 주요 디자인 패턴
- 전략(Strategy) 패턴
    - 특정 콘텍스트에서 알고리즘(전략)을 별도로 분리하는 설계 방법
    - 전략 패턴에서 콘텍스트는 사용할 전략을 직접 선택하지 않는다. 대신, 콘텍스트의 클라이언트가 콘텍스트에 사용할 전략을 전달해 준다.
    즉, DI(의존 주입)를 이용해서 콘텍스트에 전략을 전달해 준다.
    - 전략 패턴을 적용할 때 얻을 수 있는 이점은 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점이다.
    - 전략 패턴은 동일한 기능의 알고리즘 변경이 필요할 때 사용된다.
- 템플릿 메서드(Template Method) 패턴
    - 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있다.
    - 템플릿 메서드 패턴의 두가지 구성요소
        - 실행 과정을 구현한 상위 클래스
        - 실행 과정의 일부 단계를 구현한 하위 클래스
    - 템플릿 메서드 패턴을 사용하게 되면, 동일한 실행 과정의 구현을 제공하면서 동시에 하위 타입에서 일부 단계를 구현하도록 할 수 있다.
    - 하위 클래스가 아닌 상위 클래스에서 흐름 제어를 한다. 상위 타입의 템플릿 메서드가 모든 실행 흐름을 제어하고, 하위 타입의 메서드는
    템플릿 메소드에서 호출되는 구조를 갖게 된다.
- 상태(State) 패턴
    - 기능이 상태에 따라 다르게 동작해야 할 때 사용할 수 있다.
    - 상태 패턴에서 중요한 점은 상태 객체가 기능을 제공한다는 점이다.
    - **콘텍스트는 필드로 상태 객체를 갖고 있다. 콘텍스트는 클라이언트로부터 기능 실행 요청을 받으면, 상태 객체에 처리를 위임하는 방식으로 구현한다.**
    - 상태 패턴의 장점은 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화된다는 점이다.
    - 상태가 많아질 경우 조건문을 이용한 방식은 코드가 복잡해져서 유지 보수를 어렵게 만들지만, 상태 패턴의 경우 상태가 많아지더라도(클래스의 개수는 증가하지만)
    코드의 복잡도는 증가하지 않기 때문에 유지보수에 유리하다.
    - 상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기 때문에 상태 별 동작을 수정하기 쉽다. **조건문을 이용한 방식을 사용할 경우
    수정하려면 각 메서드를 찾아다니면서 모두 수정해 주어야 한다.**
- 데코레이터(Decorator) 패턴
    - 데코레이터 패턴은 상속이 아닌 위임을 하는 방식으로 기능을 확장해 나간다. 
    - 상속을 이용한 기능 확장 방법이 쉽긴 하지만, 다양한 조합의 기능 확장이 요구될 때 클래스가 불필요하게 증가하는 문제가 발생된다. 
    - 데코레이터 패턴을 사용하면 각 확장 기능들의 구현이 별도의 클래스로 분리되기 때문에, 각 확장 기능 및 원래 기능을 서로 영향 없이 변경할 수 있도록 만들어 준다.
    - 데코레이터의 단점은 사용자 입장에서 데코레이터 객체와 실제 구현 객체의 구분이 되지 않기 때문에 코드만으로는 기능이 어떻게 동작하는지 이해하기 어렵다는 점이다.
- 프록시(Proxy) 패턴
    - 실제 객체를 대신하는 프록시 객체를 사용해서 실제 객체의 생성이나 접근 등을 제어할 수 있도록 해주는 패턴이다.
    - 위임 기반의 프록시 패턴 구현은 데코레이터 패턴의 구현과 매우 유사한데, 이 두 패턴은 의도에서 분명한 차이를 보인다.
    프록시 패턴의 경우 실제 객체에 대한 접근을 제어하는데 초점이 맞춰져 있는 반면에 데코레이터 패턴은 기존 객체의 기능을 확장하는데 초점을 맞추고 있다.
      따라서 클래스의 이름을 부여할 때에는 의도에 맞는 단어를 선택해야 한다.
- 어댑터(Adapter) 패턴
    - 클라이언트가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 패턴이다.
    - 어댑터에 해당하는 클래스는 인터페이스에 맞춰 주는 책임을 갖는다. 
    - 어댑터 패턴이 적용된 예는 SLF4J 라는 로깅 API 가 있다. SLF4J 는 단일 로깅 API 를 사용하면서 자바 로깅, log4j, LogBack 등의 로깅 프레임워크를 선택적으로 사용할 수 있도록 해주는데, 
    이 때 SLF4J 가 제공하는 인터페이스와 각 로깅 프레임워크를 맞춰 주기 위해 어댑터를 사용하고 있다.
    - 어댑터 패턴은 개방 폐쇄 원칙을 따를 수 있도록 도와준다.
- 옵저버(Observer) 패턴
    - 한 객체의 상태 변화를 정해지지 않은 여러 다른 객체에 통지하고 싶을 때 사용되는 패턴이다.
    - 옵저버 패턴에는 크게 주제(subject) 객체와 옵저버(observer) 객체가 등장하는데, 주제 객체는 다음의 두 가지 책임을 갖는다.
        - 옵저버 목록을 관리하고, 옵저버를 등록하고 제거할 수 있는 메서드를 제공한다.
        - 상태의 변경이 발생되면 등록된 옵저버에 변경 내역을 알린다.
    - 옵저버 객체를 구현한 클래스는 주제 객체가 호출하는 메서드에 필요한 기능을 구현하면 된다.
    - 옵저버 패턴을 적용할 때의 장점은 주제 클래스 변경 없이 상태 변경을 통지 받을 옵저버를 추가 할 수 있다는 점이다. 
    - 주제 객체의 상태가 바뀔 때마다 옵저버에게 통지를 해 주어야 한다면, 주제 객체에서 직접 통지 기능을 실행하는 것이 구현에 유리하다. 왜냐면, 주제 객체를 사용하는 코드에서 통지 기능을
    실행한다면 상태를 변경하는 모든 코드에서 통지 기능을 함께 호출해 주어야 하는데, 이런 방식은 통지 기능을 호출하지 않는 등 개발자의 실수를 유발할 수 있기 때문이다.
    - 반대로, 한 개 이상의 주제 객체의 연속적인 상태 변경 이후에 옵저버에게 통지를 해야 한다면, 주제 객체가 아닌 주제 객체의 상태를 변경하는 코드에서 통지 기능을 
    실행해 주도록 구현하는 것이 통지 시점을 관리하기가 수월하다.
    - 한 주제 객체가 통지할 수 있는 상태 변경 내역의 종류가 다양한 경우에는 각 종류 별로 옵저버 인터페이스를 분리해서 구현하는 것이 좋다. 
    모든 종류의 상태 변경을 하나의 옵저버 인터페이스로 처리할 경우, 옵저버 인터페이스가 너무 거대해진다.
    - 통지 시점에서 주제 객체의 상태에 결함이 없어야 한다.
- 미디에이터(Mediator) 패턴
    - 미디에이터 패턴은 각 객체들이 직접 메시지를 주고받는 대신, 중간에 중계 역할을 수행하는 미디에이터 객체를 두고 미디에이터를 통해서 각 객체들이 간접적으로 메시지를 주고받도록 한다.
    - 다른 협업 객체들은 모든 요청을 미디에이터에 보내며, 미디에이터는 그 요청을 처리할 알맞은 객체를 실행한다.
    - 미디에이터 패턴은 각 협업 클래스에 흩어져 있는 흐름 제어를 미디에이터로 모으기 때문에, 각 협업 클래스의 코드가 단순해진다.
    - 협업 객체 간의 동일한 메시지 흐름이 서로 다른 기능에서 반복해서 사용될 경우, 미디에이터 추상 클래스를 사용함으로써 미디에이터 자체의 재사용을 높일 수 있다.
- 파사드(Facade) 패턴
    - 코드 중복과 직접적인 의존을 해결하는데 도움을 주는 패턴이다. 
    - 서브 시스템을 감춰 주는 상위 수준의 인터페이스를 제공한다.
    - 파사드 패턴을 적용하면 클라이언트는 파사드에만 의존하기 때문에, 서브 시스템의 일부가 변경되더라도 그 여파는 파사드로 한정될 가능성이 높다.
    - 파사드 패턴을 클래스와 비교해 보면, 파사드는 마치 서브 시스템의 상세함을 감춰주는 인터페이스와 유사하다. 파사드를 통해서 서브 시스템의 상세한 구현을 캡슐화 하고, 
    이를 통해 상세한 구현이 변경되더라도 파사드를 사용하는 코드에 주는 영향을 줄일 수 있게 된다.
- 추상 팩토리(Abstract Factory) 패턴
    - 추상 팩토리 패턴에서는 관련된 객체 군을 생성하는 책임을 갖는 타입을 별도로 분리한다.
    - 추상 팩토리 패턴을 사용할 때의 장점은 클라이언트에 영향을 주지 않으면서 사용할 제품(객체)군을 교체할 수 있다는 점이다.
- 컴포지트(Composite) 패턴
    - 거의 동일한 코드가 중복된다는 점은 결국 복잡도를 높여서 코드의 수정이나 확장을 어렵게 만드는데, 이런 단점을 해소하기 위해 사용되는 패턴이 바로
    컴포지트 패턴이다. 컴포지트 패턴은 이 문제를 전체-부분을 구성하는 클래스가 동일 인터페이스를 구현하도록 만듦으로써 해결한다.
    - 컴포지트 패턴에서 컴포지트의 책임
        - 컴포넌트 그룹을 관리한다.
        - 컴포지트에 기능 실행을 요청하면, 컴포지트는 포함하고 있는 컴포넌트들에게 기능 실행 요청을 위임한다.
- 널(Null) 객체 패턴
    - 널 객체 패턴을 사용할 때의 장점은 null 검사 코드를 사용할 필요가 없기 때문에 코드가 간결해진다는 점이다. 코드가 간결해진다는 것은 그 만큼 코드 가독성을 
    높여 주므로, 향후에 코드 수정을 보다 쉽게 만들어 준다.
